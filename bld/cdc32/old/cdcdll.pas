unit cdcdll;

{
WARNING: this file is out of date as of 2013

// delphi DLL interface for cdccore
}
{
NOTES: there are several calls that you MUST make BEFORE
calling dwyco_init when  using the server.

you must call "dwyco_set_login_password" before calling
dwyco_init since dwyco_init initiates login to the server.
this is especially important the very first time a user
runs the server enabled software, since the first login
will SET his password on the server.

also dwyco_set_cmd_path must be called with the complete
pathname of the exe (like c:\program files\foocorp\fooapp.exe)
in order for the windows firewall to be opened up for the
application.

the DwycoServerLoginCallback will be fired when the
login is complete (either ok, or failed.) If it
is OK, then you don't have to do anything else. If it
FAILS, then either the password was wrong, or the connection
to the server is hosed. The DLL will continue to try to
connect to the server periodically. If you set the password
again, that new password will be used the next time the
server connection is attempted. You can call dwyco_database_login()
to initiate a login immediately (that call does nothing if it
is already connected.)

IMPORTANT IMPORTANT IMPORTANT
you must also do some windows mickeymouse as well:
call dwyco_set_main_msg_window with the HWND of the
main window of the application (the one that gets
all the messages). after that, you must have a
delphi OnMessage handler for the Application object
that calls 

dwyco_handle_msg((const char *)&Msg, sizeof(Msg), Msg.message, Msg.wParam, Msg.lParam);

this allows the DLL to properly handle asynch DNS lookups.

AUTOUPDATE NOTES
------------------
You MUST call dwyco_setup_autoupdate before calling
dwyco_init, since the server connects may be done
at that point, and having the autoupdate signature
in place is required by the servers now.

STORE and FORWARD notes:
* there are no changes to sending messages.

* FOR TESTING: if you want to ALWAYS send thru server, you
can set the always-send-via-server flag:
dwyco_set_zap_data(1 <-- always-send-via-server flag, ....)

*NOTE: if you send someone a message that doesn't have an
account on the server (ie, someone who has never used the
serve enabled software), the message will not be delivered.

* to tell if a message needs to be fetched from the server:
check the QMS_IS_DIRECT flag on the message summary. if it's type
is NIL, then you have to fetch it with dwyco_fetch_server_message.

* NOTE: you CANNOT CALL anything other than "dwyco_fetch_server_message"
and dwyco_delete_unsaved on a msg that is stored on the server. 

* you will get DwycoMsgDownload and Status callbacks as the message fetch progresses.

* HERE IS THE WEIRD PART: if you get a DWYCO_MSG_DOWNLOAD_OK, then
the message was successfully downloaded. the NEW msgid is given
in the argument to the DOWNLOAD_OK callback. the msgid should be
the same as the msg id that was being fetch (it will now look like
a direct message instead of a server message).

* User info is now fetched from the server asynchronously
when a message arrives from someone that you haven't got
any messages from before. therefor, you might see extra
"refresh users" flags at that point.

KNOWN PROBLEMS TO BE FIXED SOON
----
* some of the error handling isn't quite debugged yet, so
if you pass bogus args to the new calls, things might get weird.
* there is no way to cancel a download at the moment
* there is no way to change your password on the server
* there is no way to find another user based on id or name
* the pal list/ignore list isn't stored on the server
* too many refresh-users, refresh-msgs going on. need better
callbacks so messages can be gotten by the client one
at a time rather than having to make them reread everything.

}
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date:   4/5/2001                                            }
{    Generated Time: 12:28:01 PM                                              }
{                                                                          }
{**************************************************************************}

interface


{=> CDCDLL.H <=}

{$IFNDEF DLLI_H}
  {$DEFINE DLLI_H}
{$ENDIF}

type DWYCO_LIST = Pointer;
type DWYCO_USER_LIST = DWYCO_LIST;
type DWYCO_DIR_LIST = DWYCO_LIST;
type DWYCO_UNSAVED_MSG_LIST = DWYCO_LIST;
type DWYCO_SAVED_MSG_LIST = DWYCO_LIST;
type DWYCO_SERVER_LIST = DWYCO_LIST;
type DWYCO_BOOL = Integer;

{note: this is a bogus type, really should figure out
how to make it open-ended like the DLL can handle}

type
DwycoArrayOfPointers = array[0..200] of PChar;

{:'a,'bs/function \([^(]*\)/\1 = function/}

type
DwycoChannelDestroyCallback = function(id: Integer; 
                                       user_arg: Pointer) : Integer; stdcall  ;

type
DwycoCallEstablishedCallback = function(id: Integer; 
                                        user_arg: Pointer;
                                        uid: PChar;
                                        len_uid: integer)  :Integer ; stdcall;

type
DwycoStatusCallback = function(id: Integer;
                               msg: PChar;
                               percent_done: Integer;
                               user_arg: Pointer)  :Integer  ; stdcall;

type
DwycoVideoDisplayCallback = function(ui_id: Integer;
                                     img: Pointer;
                                     cols: Integer;
                                     rows: Integer;
                                     depth: Integer)  : Integer ; stdcall;

type
DwycoCallAppearanceCallback = function(id: Integer;
                                       name: PChar;
                                       location: PChar;
                                       uid: PChar;
                                       len_uid: integer)  :Integer ; stdcall;

type
DwycoZapAppearanceCallback = function(id: Integer;
                                      name: PChar;
                                      size: Integer;
                                      uid: PChar;
                                      len_uid: integer)  : Integer ; stdcall;

type
DwycoCallAppearanceDeathCallback = function(id: Integer): Integer   ; stdcall;

type
DwycoCallScreeningCallback = function(chan_id: Integer;
	                              remote_wants_to_recv_your_video:Integer;
                                      remote_wants_to_send_you_video:Integer;
                                      remote_wants_to_recv_your_audio:Integer;
                                      remote_wants_to_send_you_audio:Integer;
                                      remote_wants_to_exchange_pubchat:Integer;
                                      remote_wants_to_exchange_privchat:Integer;
                                      call_type: PChar;
                                      len_call_type: Integer;
                                      uid: Pchar;
                                      len_uid: Integer;
                                      var accept_call_style: Integer;
	                              var error_msg: PChar):  Integer   ; stdcall;

type
DwycoDirectoryDownloadedCallback = function(dl: DWYCO_DIR_LIST) : Integer ; stdcall ;

// if what is MSG_SEND_FAILED and server_msg is non-zero it is a string with a
// short explanation about why the message couldn't be delivered.
type
DwycoMessageSendCallback = function(id: Integer;
                                    what: Integer;
                                    recipient: PChar;
                                    reciplen: Integer;
                                    server_msg: PChar;
                                    user_arg: Pointer)  : Integer ; stdcall;

type
DwycoPublicChatInitCallback = function(ui_id: Integer):  Integer  ; stdcall;

type
DwycoPrivateChatInitCallback = function(chan_id: Integer; ui_id: Integer;
                                        header: PChar):   Integer ; stdcall;

type
DwycoPrivateChatDisplayCallback = function(ui_id: Integer;
                                           com: PChar;
                                           arg1: Integer;
                                           arg2: Integer;
                                           str: PChar;
                                           len: Integer):   Integer ; stdcall;

type
DwycoPublicChatDisplayCallback = function(who: PChar;
                                          len_who: Integer;
                                          line: PChar;
                                          len_line: Integer;
                                          uid: PChar;
                                          len_uid: Integer):  Integer  ; stdcall;

type
DwycoVideoDisplayInitCallback = procedure(chan : Integer;
                                          ui_id : Integer)  ; stdcall;

type
DwycoCommandCallback = procedure(cmd: PChar; user_arg: Pointer; succ: Integer; fail_msg: PChar); stdcall;

type
DwycoAutoUpdateDownloadCallback = procedure(status: Integer); stdcall;

type
DwycoAutoUpdateStatusCallback = procedure(status: Integer; desc: PChar); stdcall;

type
DwycoProfileCallback = procedure(succ: integer;
	                         reason: PChar;
	                         s1: PChar; len_s1: integer;
	                         s2: PChar; len_s2:integer;
                                 s3: PChar; len_s3:integer;
                                 filename: PChar;
                                 uid: PChar; len_uid: integer;
                                 user_arg: Pointer); stdcall;


// The DLL calls this callback when it gets an unrecoverable problem. if
// must_exit is non-zero, the application MUST cleanup and EXIT as soon as
// possible, otherwise the DLL state could be corrupted in any number of ways.
// The UI should popup a box with an informative message for the user before
// performing cleanup and exit.
// if must_exit is 0, it doesn't matter if the UI exits (either because the
// error wasn't a big deal, OR the dll is going to exit immediately when the
// callback returns anyways.)
//
// the args are:
// whats_the_problem - one of
// #define DWYCO_EMERGENCY_DB_CHANGE 1 // when the callback returns, program continues as usual
// #define DWYCO_EMERGENCY_GENERAL_PANIC 2       // on callback return, the dll exits the program
// the "dll_msg" should be helpful to tech support or for debugging.

type
DwycoEmergencyCallback = procedure(whats_the_problem: Integer; must_exit: Integer; dll_msg: PChar); stdcall;
const DWYCO_EMERGENCY_DB_CHANGE = 1;
const DWYCO_EMERGENCY_GENERAL_PANIC = 2;

{
this type of callback is used for handling situations related to server-hosted
public chat (see below for details).
}
type
DwycoChatCtxCallback = procedure(cmd: Integer;
                                 id: Integer;
                                 uid: PChar; len_uid: Integer;
                                 name: PChar; name_len: Integer;
                                 dtype: Integer;
                                 str: PChar; len_str: Integer;
	                         qid: Integer;
	                         extra_arg:Integer); stdcall;
// 2010.1
type
DwycoChatCtxCallback2 = procedure(cmd: Integer;
                                  id: Integer;
                                  uid: PChar; len_uid: Integer;
                                  name: PChar; name_len: Integer;
                                  lst: DWYCO_LIST;
	                          qid: Integer;
	                          extra_arg:Integer); stdcall;

type
DwycoServerLoginCallback = procedure(str: PChar; what: Integer); stdcall;

// this is called when the activity timer expires.
// the timeout arg is the current timeout value in seconds
type
DwycoActivityCallback = procedure(timeout: Integer); stdcall;

{ ************************************************************************** }
{                                                                            }
{ Activity reporting                                                         }
{                                                                            }
{ As a default, the basic idea is that the dll sets a timer and starts it    }
{ running. if the timer expires, the dll goes into "inactive" state. you     }
{ could imagine all kind of stuff regarding this state, like giving up the   }
{ camera, turning off audio, etc. but for now, we just tell the servers our  }
{ state so it can be reflected to others.                                    }
{                                                                            }
{ IF you want to implement your own activity checking, you can call this     }
{ function, which automatically disables all of the dll's internal activity  }
{ monitoring and status updating.                                            }
{                                                                            }
{ You'll have to perform all your own checking, and status updating (see     }
{ chatq_send_activity below).                                                }
{                                                                            }
{ "timeout" is in seconds                                                    }
{                                                                            }
{ Calling this function with on = 1, timeout > 0, cb != 0 results in the     }
{ timer being reset and the timer to start counting down. when the           }
{ countdown == 0, the callback is called.                                    }
{                                                                            }
{ Calling this function with on = 0 will cause the timer to stop.            }
{                                                                            }
{ ************************************************************************** }
procedure dwyco_enable_activity_checking(on: Integer; timeout: Integer; cb: DwycoActivityCallback); stdcall;

// you can call this if you want to use the internal dll activity checking, but
// just want to tweak the timer value it uses.
// when you call this, it resets the current timer immediately.
procedure dwyco_set_inactivity_time(secs: Integer); stdcall;

{$IFDEF IMW32}
{
/ External IM errors.
// this is the only way errors and statuses are
// returned at the moment. it is very primitive now...
// str can be:
//  "login" - means the eim has been successfully logged in. what = 1
//  "error" - means an error occurred on the eim, what = error code. the codes are defined below.
//          note: in the current setup, there is no way to matchup
//          errors with certain operations (in the case of remove users, msg sends, etc.)
//          read the errors below carefully to figure out what will happen
//          when the error occurs.
//  "disconnect" - the eim has been disconnected by the system. what = 0
//
// note: in order to avoid having to include the
// imw headers, these statuses are copied from
// the imw headers, bad, but the alternative is worse.
}
const DWYCO_EIM_ERROR_CANT_ADD_USER = 1;     //error occurs while adding user	(i.e. such user doesn't exist)
const DWYCO_EIM_ERROR_CANT_RENAME_USER = 2;  //error occurs while renaming user (i.e. no such user in CL)
const DWYCO_EIM_ERROR_CANT_REMOVE_USER = 3;  //error occurs while removing user (i.e. no such user in CL)
const DWYCO_EIM_ERROR_CANT_SEND_MESSAGE = 4; //error occurs while sending message (for example user is offline in MSN)
const DWYCO_EIM_ERROR_RECONNECTING = 7;      //connection fails and transport reconnects

// NOTE: when any of these errors occurs, the DLL automatically turns off
// auto-login for that EIM. this is because it is unlikely the login will
// ever succeed until the user fixes something. also, this avoids a problem
// where yahoo corrupts its address book while two clients fight over the
// account.
const DWYCO_EIM_ERROR_ACCOUNT_USED_ON_ANOTHER_PC = 5; //somebody uses the same account on another PC and our connection has been failed
const DWYCO_EIM_ERROR_WRONG_LOGIN_PASSWORD = 6;       //authorization error
const DWYCO_EIM_ERROR_CONNECTION_FAILED = 8;          //connection to the service has been failed after several tries of reconnect
const DWYCO_EIM_ERROR_CANT_RESOLVE_NAME = 9;          //can't connect to the service because of inability to resolve server name

type
DwycoEIMServerLoginCallback = procedure(eim: Integer; msg: PChar; code: Integer); stdcall;
{$ENDIF}

type
DwycoMessageDownloadCallback = procedure(id: Integer; what: Integer; msgid: PChar; mdc_arg: Pointer); stdcall;

type
DwycoPalAuthCallback = procedure(uid: PChar; len: Integer; what: Integer); stdcall;
    
function dwyco_set_public_chat_init_callback(cb: DwycoPublicChatInitCallback): Integer ;stdcall   ;
function dwyco_set_private_chat_init_callback(cb: DwycoPrivateChatInitCallback): Integer ;stdcall   ;
function dwyco_set_private_chat_display_callback(cb: DwycoPrivateChatDisplayCallback): Integer ;stdcall   ;
function dwyco_set_public_chat_display_callback(cb: DwycoPublicChatDisplayCallback): Integer ;stdcall   ;
procedure dwyco_set_video_display_callback(cb: DwycoVideoDisplayCallback) ;stdcall   ;
procedure dwyco_set_video_display_init_callback(cb: DwycoVideoDisplayInitCallback) ;stdcall  ;
procedure dwyco_set_motd_callback(cb: DwycoStatusCallback) ;stdcall  ;
{procedure dwyco_set_unregister_callback(cb: DwycoStatusCallback) ;stdcall  ;}
procedure dwyco_set_emergency_callback(cb: DwycoEmergencyCallback);stdcall  ;

{ see dlli.h for details on call screening }
const DWYCO_CSC_ACCEPT_CALL = 1;
const DWYCO_CSC_DEFER_CALL = 2;
const DWYCO_CSC_REJECT_CALL = 3;
procedure dwyco_set_call_screening_callback(cb: DwycoCallScreeningCallback);stdcall  ;

{
 // the chat context callback is called when you are connected to a
 // chatroom. the id's are session unique. names and uids must be copied out
 // before the callback returns. a START_UPDATE callback is called before
 // any update to the context. this can be used to batch updates in cases
 // where you are initially logging in, and doing a single UI update for each
 // user in the room would cause too much flicker.
 // note: ca 3/15/2006, only one chat ctx is alive at once
 }
const DWYCO_CHAT_CTX_NEW = 0;          // when ctx is first created, id is new, all other parms 0
const DWYCO_CHAT_CTX_DEL = 1;          // when ctx is deleted, means you have logged out of the chat server
const DWYCO_CHAT_CTX_ADD_USER = 2;     // for each user that comes into the chat room, uid and name parms valid.
const DWYCO_CHAT_CTX_DEL_USER = 3;     // for each user that leaves, only uid is valid
const DWYCO_CHAT_CTX_UPDATE_AH = 4;    // update asshole-factor, doesn't work in this version, should be ignored
const DWYCO_CHAT_CTX_START_UPDATE = 5; // happens before all update ops, can safely be ignored if flicker is not an issue
const DWYCO_CHAT_CTX_END_UPDATE = 6;   // at the end of a batch of updates
const DWYCO_CHAT_CTX_Q_ADD = 7;        // uid added to q. uid, qid, extra_arg = 0 for end-of-q, 1 for top of q
const DWYCO_CHAT_CTX_Q_DEL = 8;        // uid removed from q
const DWYCO_CHAT_CTX_Q_GRANT = 9;      // uid granted the podium, extra_arg = time in seconds to talk
// note: the following is useful for displaying status info such as
// "user is transmitting" or something like that. in the case of audio, you
// don't have to do anything with the data, it is handled automatically
// before you get this callback
const DWYCO_CHAT_CTX_Q_DATA = 10;      // uid is sending data. name param contains the data
// see comments in dlli.h regarding these messages
const DWYCO_CHAT_CTX_SYS_ATTR = 11;
const DWYCO_CHAT_CTX_UPDATE_ATTR = 12;

// 2010.1
// User-defined lobbies
// Only available via ChatCtxCallback2, since there is a fair bit of
// info that comes with these msgs. Essentially, these are lobbies that
// act more or less like the old static chat lobbies, except instead of using
// switch_to_chat_server(index), you use dwyco_switch_to_chat_server2(lobby-id)
// where the lobby-id is available from the add_lobby msg.
// note: for compatibility, a directory server comes with the
// the chat server "for free". this is mainly because we want to have
// access to profiles, and the directory is what provides these at the
// moment.
const DWYCO_CHAT_CTX_ADD_LOBBY = 13;
const DWYCO_CHAT_CTX_DEL_LOBBY = 14;

const DWYCO_SL_ULOBBY_ID = '000';
const DWYCO_SL_ULOBBY_HOSTNAME = '001';
const DWYCO_SL_ULOBBY_IP = '002';
const DWYCO_SL_ULOBBY_PORT = '003';
const DWYCO_SL_ULOBBY_RATING = '004';
const DWYCO_SL_ULOBBY_DISPLAY_NAME = '005';
const DWYCO_SL_ULOBBY_CATEGORY = '006';
const DWYCO_SL_ULOBBY_BACKUP = '007';
// note: internal pvt name at 008
const DWYCO_SL_ULOBBY_MAX_USERS = '009';
const DWYCO_SL_ULOBBY_SUBGOD_UID = '010';
// DWYCO_TYPE_NIL = no password, otherwise, special hash
// that is used internally.
const DWYCO_SL_ULOBBY_PW_do_not_use = '011';

// GOD tracking, this is dynamic. When a god comes online you
// get an add_god message, no matter where they are.
// As a god moves around between servers, you will get
// a del-god when they leave, and a subsequent add when they
// enter a new server. You get a record of info indicating what
// kind of god-powers they have, and where they are (what server.)
const  DWYCO_CHAT_CTX_ADD_GOD = 15;   // a vector of extra info is sent as well in the callback
const  DWYCO_CHAT_CTX_DEL_GOD = 16;   // just the UID of the god that is gone

// This the info you get when you get a add-god msg
//name where god demigod subgod
const  DWYCO_GT_NAME = '000';
const  DWYCO_GT_WHERE = '001';
const  DWYCO_GT_GOD = '002';
const  DWYCO_GT_DEMIGOD = '003';
const  DWYCO_GT_SUBGOD = '004';
const  DWYCO_GT_SERVER_ID = '005';
// when you get a ui-call-vector message, the value vector is accessed
// as a DWYCO_LIST with these columns;
const  DWYCO_CV_MAX_AUDIO      = '000';
const  DWYCO_CV_MAX_VIDEO      = '001';
const  DWYCO_CV_CHAT           = '002';
const  DWYCO_CV_MAX_AUDIO_RECV = '003';
const  DWYCO_CV_MAX_VIDEO_RECV = '004';

// "popup" sysattr
const DWYCO_POPUP_FROM_UID    = '000';
const DWYCO_POPUP_FROM_HANDLE = '001';
const DWYCO_POPUP_MSG         = '002';

// this is a generic function used to set persistent sys-attrs in the
// server. some sys attrs are used by the dll to configure bandwidths
// and so on. you must be a god in order to use this command.
// sysattrs that are set with this command are automatically sent to all
// users of the chat server (via a SYS_ATTR msg).
// NOTE: there is no limit on the name and value (except the name has to be
// a string). so you can set your own sysattrs, and they
// will automatically be remembered by the server. you might use this for
// example to implement client-specific functions such as server-wide
// popups, etc. NOTE: currently ANY SYSATTR THAT STARTS WITH "us-" is
// reserved for the DLL.
// you can send in either a DWYCO_TYPE_NIL (in which case all the val
// params are ignored) DWYCO_TYPE_INT, in which case val_int param
// is used, or DWYCO_TYPE_STRING, in which case val and val_len are
// used.
function dwyco_chat_set_sys_attr(name: PChar; name_len : Integer;
	                         dwyco_type: Integer;
                                 val: PChar; val_len: Integer;
                                 val_int: Integer) : Integer ;stdcall  ;

// this is the request to take the podium. you will receive
// a "grant" message if and when you get the podium (which may be
// never.) this always adds you to the end. if you call it multiple times
// while on the q, each time, you are put back down to the end of the q.
function dwyco_chat_addq(q: Integer): Integer;stdcall  ;

// if you set uid = 0 in this call, it uses the UID of the current user.
// if uid != 0 and uid != current user, you must be a god.
// use this call to recind your q add request. calling it if you are not
// on the q is a noop. 
function dwyco_chat_delq(q: Integer; uid: PChar; len_uid: Integer): Integer;stdcall  ;

// use this to indicate that you want to transition thru the grace-period
// timeout directly to the "talk-time" limit. normally this is handled
// automatically by the dll when audio is acquired and starts streaming
// into the chat server. this is useful mostly for testing without audio
function dwyco_chat_talk(q: Integer) : Integer;stdcall  ;

// don't send me any audio if on == 1
function dwyco_chat_mute(q: Integer; enable: Integer) : Integer; stdcall  ;
// only allows gods, demigods, or a particular uid to have the podium. gods can set any flag. demigods can set the
// demigod flag and the uid. whenever you call this function, everyone is kicked off the q and must readd themselves.
function dwyco_chat_set_filter(q, gods_only, demigods_only : Integer; uid: Pchar; len_uid : Integer): Integer;stdcall  ;
// only gods can use the next 2 functions
function dwyco_chat_set_demigod(uid : PChar; len_uid: Integer; enabled: Integer): Integer;stdcall  ;
function dwyco_chat_clear_all_demigods(): Integer;stdcall  ;

// users are normally in an unblocked state.
// sets the unix time at which a users input will be unblocked nutil the current time
// PLUS the tm parameter (tm in seconds). set tm to -1 to immediately unblock a user.
// set tm to a positive number to block input from the user (for example, setting tm
// to 60 blocks a user for 60 seconds). only demigods can use this function.
// when a user is blocked, all of their input is discarded.
// a user that is blocked is immediately kicked off the q/podium.
// as of 5/15/07, blocked users are also disconnected from the server
function dwyco_chat_set_unblock_time(q: Integer; uid: PChar; len_uid: Integer; tm: Integer): Integer;stdcall  ;
function dwyco_chat_set_unblock_time2(q: Integer; uid: PChar; len_uid: Integer; tm: Integer; reason: PChar): Integer;stdcall  ;

// this function prompts the server to belch out the current demigod and
// block lists. they come in as SYS_ATTRs, and the block records come in
// as vectors, and you can use these constants to access the record:
const DWYCO_BLOCK_REC_BLOCKEE_UID = '000';
const DWYCO_BLOCK_REC_UNBLOCK_TIME = '001'; // absolute time (unix time) when record become invalid
const DWYCO_BLOCK_REC_BLOCKER_UID = '002';
const DWYCO_BLOCK_REC_BLOCKED_WHEN = '003'; // absolute time (unix time) when the block was issued
const DWYCO_BLOCK_REC_REASON = '004' ;
function  dwyco_chat_get_admin_info(): Integer; stdcall  ;

procedure dwyco_set_chat_ctx_callback(cb: DwycoChatCtxCallback);stdcall  ;
procedure dwyco_set_chat_ctx_callback2(cb: DwycoChatCtxCallback2);stdcall  ;
procedure dwyco_set_chat_server_status_callback(cb: DwycoStatusCallback);stdcall  ;

procedure dwyco_chat_create_user_lobby(dispname: PChar;
	                               category: PChar;
	                               subgod_uid: PChar; len_sub_god_uid: Integer;
	                               pw: PChar;
	                               user_limit: Integer;
                                       cb: DwycoCommandCallback;
	                               user_arg: Pointer);stdcall  ;

procedure dwyco_chat_remove_user_lobby(lobby_id: PChar;
	                               cb: DwycoCommandCallback;
	                               user_arg: Pointer);stdcall  ;

// it returns 1 if it finds the
// id, and 0 otherwise. the list returned will be a singleton list
// (1 row, no columns).

function dwyco_get_lobby_name_by_id2(id: PChar; var list_out: DWYCO_LIST): Integer; stdcall;

// returns 1 if chan_id found, and the channels current streaming
// media types. returns 0 otherwise.
function dwyco_channel_streams(chan_id: Integer; 
	var send_video: Integer;
	var recv_video: Integer;
	var send_audio: Integer;
	var recv_audio: Integer;
	var pub_chat: Integer;
	var priv_chat: Integer): Integer; stdcall;


// send the ui-activity attribute to chat-local users and
// to pals (not impl).
// WARNING: DLL uses nil and "idle" for internal states
// if active == 1, the dll will send "nil" for the attribute
// if active == 0, the dll will send "idle"
// in both cases, "state" argument is ignored
// if active == -1, the dll will send the value of "state"
// make it something descriptive, but you must coordinate with other
// clients, since there will be incompatibilities otherwise.

function dwyco_chat_set_activity_state(active: Integer; state: Pchar; len_state: Integer): Integer; stdcall;

// send a popup message to all local users as a "sys_attr".
// if global == 1, then it sends it to *all* users connected to all
// chat servers in the system. you can send local popups if you
// are a sub-god or demi-god or god.
// you must be a god to send a global popup.

function dwyco_chat_send_popup(text: PChar; len_text: Integer; global: Integer) : Integer; stdcall;

// pals-only filtering
// if on == 1, then filtering is turned on, and all
// messages and calls will be rejected from users not on the pal list.
// if on == 0, then no pal filtering is done. to test: turning pal
// filtering on/off while there are q'd messages is likely to be
// broken in some way (ie, the filtering is done when the msg is
// received, not when it is accessed.)
// in addition, this function informs chat-local users of your
// pal-filtering state.
procedure dwyco_set_pals_only(on: Integer); stdcall;
function dwyco_get_pals_only(): Integer; stdcall;

// To toggle sending auto-replies, see set_zap_data/send_auto_reply.
//
// By default, if there is no auto-reply message set, the dll will send
// a default text auto-reply stating the user is only accepting calls and
// messages from pals.
// This call makes it possible for the message to be any zap message.
// The text and media referenced by the composer are saved into a local
// message that is stored as a "sent" message in the current users own
// message box. It becomes a normal message, and the msgid is stored
// by the DLL to be used for auto-replies. To form the auto-reply, the
// DLL forwards the message to the recipient.
// To revert back to the default auto-reply, call this function with
// "text" == 0 or compid == 0.
// The message is not removed, just the msgid refering to it.
// There is no way to reinstate a previous message with this simple api at the moment.
// There is no way to remove the message other than the usual remove message call
// There is no way to get the msgid.
// obviously, this api needs to be improved a bit to make it possible to
// provide an easier UI.
function dwyco_set_auto_reply_msg(text: PChar; len_text: Integer; compid: Integer): Integer; stdcall;


procedure dwyco_set_old_pal_recv(i: Integer);stdcall  ;


// use this version if you just want an integer back.
// returns -1 if the asshole factor isn't valid yet
// returns -2 if the users isn't registered and the trial as expired
// otherwise returns an integer between 0 and 99 (inclusive)
function dwyco_get_ah2(uid: PChar; len_uid: Integer): Integer; stdcall;

//NOTE: PAL AUTHORIZATION IS DEFUNCT CA nov 2009
//
//{PAL AUTHORIZATION RELATED FUNCTIONS}
//{
//This callback is fired after a call to "pal_add" IF
//the target user requires pal authorization. Note that
//it is not a problem if the pal is in the pal list and
//authorization is not granted. The pal server will not honor
//the pal request unless the receiving party grants authorization.
//See the constants below for various status conditions reported
//by this callback.
//
//When this callback is fired, here is where you start the
//pal authorization chain of events.
//}
//procedure dwyco_set_pal_auth_callback(cb: DwycoPalAuthCallback); stdcall;
//{
//
//// NOTE: callback "succ" arg has special meaning:
//// 1: user requires authorization
//// 0: FAILED (couldn't get state for some reason)
//// -1: user doesn't require authorization
//NOTE: YOU SHOULD NOT NEED TO USE THIS FUNCTION DIRECTLY
//UNLESS YOU NEED TO KNOW THE PAL AUTH STATE EXPLICITLY (like for
//display or something). normally, the pal_auth_callback will be
//fired after a pal_add for cases where pal authorization is needed.
//}
//procedure dwyco_get_pal_auth_state(uid: PChar; len_uid: Integer; cb: DwycoCommandCallback; user_arg:Pointer); stdcall;
//
//{
//// sets our pal auth state in the server so others
//// know what our preference is.
//// state is:
//// 1: requires authorization
//// 0: doesn't require authorization
//}
//procedure dwyco_set_pal_auth_state(state: Integer; cb: DwycoCommandCallback; user_arg:Pointer); stdcall;
//
//{
//// gets the local pal auth state: 1=requires auth, 0=not
//NOTE: THE RESULTS OF THIS FUNCTION ARE INVALID UNTIL YOU
//HAVE LOGGED INTO THE DATABASE SERVER.
//}
//function dwyco_get_my_pal_auth_state(): Integer ; stdcall;
//
//{
//// this will return 1 if the authorization list you have
//// does not match your id# (ie, you changed your id#
//// by changing the auth file or something.)
//// when this happens, the user should have the option
//// of removing all the authorizations (they won't work
//// anymore), or leaving them.
//}
//function dwyco_get_pal_auth_warning(): Integer; stdcall;
//
//{
//Returns  1 if the user appears to be authorized by you
//}
//function dwyco_pal_auth_granted(uid: PChar; len_uid:Integer): Integer; stdcall;
//
//{
//This removes the authorization for a user locally. After calling
//this function, that remote user will no longer be able to track
//you via their pal list. NOTE: THIS DOES NOT REMOVE THE USER FROM
//THE REMOTE PERSONS PAL LIST. If you want to do that, try the
//"pal reject" special message.
//}
//procedure dwyco_revoke_pal_auth(uid: Pchar; len_uid: Integer); stdcall;
//
//{
//This function removes all pal authorization information
//and resets the igrant/theygrnt files to the current UID.
//}
//procedure dwyco_clear_pal_auths(); stdcall;
//
//{
//This function is used to process the special messages that
//are received during pal authorization negotiation.
//// msg_id should refer to a local message that is
//// a special pal auth message.
//// call this function in response to receiving a
//// pal authorization request and getting a positive user response:
//// suggestions for buttons on request dialog:
//// YES = grant authorization, but do not take advantage of
//// reverse authorization (ie, don't put them on your list.)
//// YES+ADD = grant authorization and accept pre-authorization from user. (set add_them to 1)
//// NO = do not call this function. just delete message and do nothing.
//// NO+IGNORE = do not call this function. delete message and ignore the user.
////
//// also, call this function immediately when you get a "palrej" or "palok"
//// message.
////
//
//function dwyco_handle_pal_auth(msg_id :Pchar; add_them:Integer):Integer ; stdcall;



//  This function is used for making messages that have special meaning
//  (or payloads). For now, this is used to send special "pal authorization"
//  messages via the server.
//  special_type = (one of the constants below, PAL_REQ, etc.) all the other
//  args are ignored for now. eventually they will be used for passing user
//  defined messages between clients.
function dwyco_make_special_zap_composition(special_type: Integer;
                                            user_id: PChar;
                                            user_block: PChar;
                                            len: Integer): Integer ;  stdcall;

function dwyco_is_special_message(mid: PChar;  var what:Integer): Integer; stdcall;
function dwyco_make_file_zap_composition(filename: PChar; len_filename: Integer): Integer ;  stdcall;
function dwyco_copy_out_file_zap(uid: PChar;
	                         len_uid: Integer;
	                         msg_id: PChar;
	                         dst_filename:PChar): Integer ;  stdcall;
function dwyco_is_file_zap(compid: Integer): Integer ;  stdcall;
function dwyco_selective_chat_recipient_enable(uid: PChar; len_uid: integer; enable:integer): integer;stdcall  ;
function dwyco_selective_chat_enable(enable: integer): integer ;stdcall  ;
procedure dwyco_reset_selective_chat_recipients();stdcall  ;
function dwyco_is_selective_chat_recipient(uid: PChar; len_uid: integer): integer ;stdcall  ;

//  password change values for the "succ" arg on the CommandCallback
//  for the "fetch password" command }
const DWYCO_CMD_FETCH_PW_EMAIL = 2;    // return "err" is email address password was mailed to
const DWYCO_CMD_FETCH_PW_PASSWORD = 3; // return "err" is actual password

// message send callback status
const DWYCO_MSG_SEND_OK = 1;
const DWYCO_MSG_SEND_FAILED = 2;
const DWYCO_MSG_IGNORED = 3;
const DWYCO_MSG_ATTACHMENT_DECLINED = 4;
const DWYCO_MSG_ATTACHMENT_FAILED = 5;

// message download callback statuses
const DWYCO_MSG_DOWNLOAD_FAILED = 0;
const DWYCO_MSG_DOWNLOAD_SAVE_FAILED = 1;
const DWYCO_MSG_DOWNLOAD_FETCHING_ATTACHMENT = 3;
const DWYCO_MSG_DOWNLOAD_ATTACHMENT_FETCH_FAILED = 4;
const DWYCO_MSG_DOWNLOAD_OK = 5;
const DWYCO_MSG_DOWNLOAD_RATHOLED = 6;

// ratings
const DWYCO_RATING_ADULT = 0;
const DWYCO_RATING_GENERAL = 1;

// AutoUpdate download status indicators
const DWYCO_AUTOUPDATE_SIGNATURE_FAILED = 0;
const DWYCO_AUTOUPDATE_DOWNLOAD_FAILED = 1;
const DWYCO_AUTOUPDATE_RUN_FAILED = 2;

//  NOTE: on Windows, if this status is returned to the callback, the
//  autoupdate has been started and is waiting on a MUTEX that is created
//  when dwyco_init is called. The autoupdate process waits in the background
//  until the mutex is released, and then performs whatever update it needs to.
//  This is primarily because you can't update an executable while it is being
//  used under Windows
const DWYCO_AUTOUPDATE_IN_PROGRESS = 3;

// AutoUpdate CHECK status
const DWYCO_AUTOUPDATE_CHECK_FAILED = 0;
const DWYCO_AUTOUPDATE_CHECK_NOT_NEEDED = 1;
const DWYCO_AUTOUPDATE_CHECK_AVAILABLE = 2;
const DWYCO_AUTOUPDATE_CHECK_COMPULSORY1 = 3;
const DWYCO_AUTOUPDATE_CHECK_COMPULSORY2 = 4;

// directory sort columns
const DWYCO_SORT_HANDLE = 0;
const DWYCO_SORT_DESCRIPTION = 1;
const DWYCO_SORT_LOCATION = 2;

//  These are what is returned from dwyco_authenticate_body (ORed together)
//  NOTE: because some old messages have no authentication AUTH_OK can be or'ed
//  with NO_INFO. which would warrant a warning to the user.
const DWYCO_VERF_AUTH_NO_INFO = 1;
const DWYCO_VERF_AUTH_FAILED = 2;
const DWYCO_VERF_AUTH_OK = 4;

// "what" returns from the dwyco_is_special_message function
const DWYCO_SUMMARY_PAL_AUTH_REQ  = 0;
const DWYCO_SUMMARY_PAL_OK  = 1;
const DWYCO_SUMMARY_PAL_REJECT  = 2;
const DWYCO_SUMMARY_SPECIAL_USER_DEFINED  = 3;
const DWYCO_PAL_AUTH_REQ  = 4;
const DWYCO_PAL_OK  = 5;
const DWYCO_PAL_REJECT  = 6;
const DWYCO_SPECIAL_USER_DEFINED  = 7;

// these come in via the "what" arg in the PalAuthCallback
const DWYCO_PAL_AUTH_STATUS_FAILED = 0;
const DWYCO_PAL_AUTH_STATUS_REQUIRES_AUTHORIZATION = 1;
const DWYCO_PAL_AUTH_STATUS_ALREADY_AUTHORIZED = 2;

{
// these are used as arguments to the
// dwyco_make_special_zap_composition
}
const DWYCO_PAL_AUTH_ASK  = 1;
const DWYCO_PAL_AUTH_REJECT  = 2;
const DWYCO_PAL_AUTH_ACCEPT  = 3;
const DWYCO_SPECIAL_TYPE_USER  = 4;


{/// there are some access functions for }
{/// getting at the components of these }
{/// lists. they are accessed basically like }
{/// a 2-d array. all results are strings that }
{/// must be copied out. }

procedure dwyco_get_my_uid(var uid_out: PChar; var len_out: Integer);  stdcall   ;
function dwyco_enable_video_capture_preview(onoff: Integer; var uid_out: Integer): Integer; stdcall   ;
procedure dwyco_add_entropy_timer(crap: PChar; len: integer); stdcall   ;

function dwyco_get_refresh_users: Integer ;stdcall   ;
procedure dwyco_set_refresh_users(i: Integer);stdcall   ;
function dwyco_get_rescan_messages: Integer ;stdcall   ;
procedure dwyco_set_rescan_messages(i: Integer) ;stdcall   ;

function dwyco_load_users: Integer ;stdcall   ; 

function dwyco_get_user_list(var list_out: DWYCO_USER_LIST; 
                             var nelems: Integer): Integer ;stdcall   ; 

function dwyco_get_message_bodies(var list_out: DWYCO_SAVED_MSG_LIST; 
                                  uid: PChar;
                                  len_uid: Integer;
                                  load_sent: Integer): Integer ;stdcall   ; 

function dwyco_get_unsaved_messages(var list_out: DWYCO_UNSAVED_MSG_LIST; 
                                    uid: PChar; len_uid: Integer): Integer ;stdcall   ;

function dwyco_unsaved_message_to_body(var list_out: DWYCO_SAVED_MSG_LIST;
                                       msg_id: PChar): Integer ;stdcall   ;



//  this returns a list with no columns, and one row containing the formatted
//  text of the message, *including* any forwarded messages. it is HIGHLY
//  RECOMMENDED that you use this instead of accessing the fields
//  QM_BODY_TEXT/NEW_TEXT directly, because this functions knows how to
//  unwind forwarded messages.
function dwyco_get_body_text(m: DWYCO_SAVED_MSG_LIST): DWYCO_LIST; stdcall   ;

{
In the past, you had to directly access the message body dwyco_list using
DWYCO_QM_BODY_TEXT. Unfortunately, directly accessing the text for a
FORWARDED message wasn't easy, and resulted in having to use
dwyco_get_body_text, which only had fixed formatting (which broke the HTML
stuff.)

dwyco_get_body_array returns a list, each ROW of the list is a MESSAGE. in
the case of messages that were not forwarded, you'll get one row with a
message. access the DWYCO_QM_BODY_NEW_TEXT2 attribute to get the text.

in the case where a message is FORWARDED, each ROW in the body array will be
a message. ROW 0 is the latest text, ROW 1 is the message that was originally
created (in ICUII there will only ever be rows 0 and 1, because strip_chain
is wired to strip out intermediate forwards. but in general, there could be
lots of messages inside a forwarded message.)

by using get_body_array, you can format a forwarded message any way you want.
see main.cpp "show_body_array" for an example of using the function.

in order to help you find where you use BODY_TEXT directly, i have renamed
them in the header so your code won't compile immediately. everywhere you use
this directly, you should consider putting a call to a function that uses
get_body_array to format a message. this *should* allow you to properly
HTML-ize messages, even forwarded ones, without having to rely on the goofy
formatting available from "get_body_text". if you are absolutely dying to use
the attribute directly for some reason, read the header,
i just added a "2" on the end.
}
function dwyco_get_body_array(m: DWYCO_SAVED_MSG_LIST): DWYCO_LIST; stdcall   ;

function dwyco_authenticate_body(m: DWYCO_SAVED_MSG_LIST; recip_uid: PChar; len_uid: Integer): Integer; stdcall   ;

function dwyco_delete_unsaved_message(msgid: PChar): Integer; stdcall   ;
function dwyco_delete_saved_message(uid: PChar; len_uid: Integer; msg_id: PChar): Integer;stdcall   ;
function dwyco_save_message(msg_id: PChar): Integer;  stdcall   ;
function dwyco_get_saved_message(var list_out: DWYCO_SAVED_MSG_LIST; uid: PChar; len_uid: Integer; msg_id: PChar): Integer;stdcall   ; 
function dwyco_fetch_server_message(msgid: PChar; cb: DwycoMessageDownloadCallback; mdc_arg: Pointer; scb: DwycoStatusCallback; scb_arg: Pointer): Integer; stdcall;
procedure dwyco_cancel_message_fetch(fetch_id: Integer);stdcall;
procedure dwyco_update_user_info(uid: PChar; len: Integer);stdcall;

procedure dwyco_list_release(l: DWYCO_LIST) ;stdcall   ;

function dwyco_list_numelems(l: DWYCO_LIST; 
                             var rows: Integer; 
                             var cols: Integer): Integer ;stdcall   ; 

function dwyco_list_get(l: DWYCO_LIST; 
                        row: Integer; 
                        col: PChar; 
                        var val_out: PChar; 
                        var len_out: Integer; 
                        var type_out: Integer): Integer ;stdcall   ; 

function dwyco_list_print(l: DWYCO_LIST): Integer ;stdcall   ; 

procedure dwyco_simple_diagnostics(var res_out: PChar; var len_out: Integer);stdcall   ;

{ ************************************************************************** }
{                                                                            }
{ WARNING: this function is BLOCKING, and it uses external programs to       }
{ find ip addresses, so you will see cmd prompts pop up when you call it.    }
{                                                                            }
{ ************************************************************************** }
procedure dwyco_network_diagnostics(var res: PChar; var len_res: Integer);stdcall   ;

//  bandwdiths returned are in BITS per SECOND the "res" return contains some
//  text that may have errors and other useful info for tech support
//  WARNING: this function is BLOCKING, it will not return until the test
//  is complete, which may be some seconds on slow modems
procedure dwyco_estimate_bandwidth(var out_bw: Integer; var in_bw: Integer; var res: PChar; var len: Integer); stdcall   ;

function dwyco_uid_g(uid: PChar; len_uid: Integer): Integer ;stdcall   ;

// types returned by get_list
const DWYCO_TYPE_NIL = 0;
const DWYCO_TYPE_STRING = 1;
const DWYCO_TYPE_INT = 2;
const DWYCO_TYPE_VECTOR = 3;

// use this for dwyco_lists that are a single column
const DWYCO_NO_COLUMN = '';

// return from dwyco_uid_to_info
const DWYCO_INFO_HANDLE = '000';
const DWYCO_INFO_LOCATION = '001';

// return from dwyco_get_vfw_drivers
const DWYCO_VFW_DRIVER_INDEX = '000';
const DWYCO_VFW_DRIVER_NAME = '001';
const DWYCO_VFW_DRIVER_VERSION = '002';

// index strings for various data structures used by the core.
// Server list records
const DWYCO_SL_SERVER_HOSTNAME = '000';
const DWYCO_SL_SERVER_IP = '001';
const DWYCO_SL_SERVER_PORT = '002';
const DWYCO_SL_SERVER_RATING = '003';
const DWYCO_SL_SERVER_NAME = '004';
const DWYCO_SL_SERVER_CATEGORY = '005';

// User list records
const DWYCO_UL_DIRNAME = '000';        // xxx.usr
const DWYCO_UL_INFO = '001';           // info vec from server
const DWYCO_UL_QIR_FROM = '001000';
const DWYCO_UL_QIR_HANDLE = '001001';
const DWYCO_UL_QIR_EMAIL = '001002';
const DWYCO_UL_QIR_ICQ = '001003';
const DWYCO_UL_QIR_FIRST = '001004';
const DWYCO_UL_QIR_LAST = '001005';
const DWYCO_UL_QIR_DESCRIPTION = '001006';
const DWYCO_UL_QIR_LOCATION = '001007';
// note: may be runtime fields added here by cdc UI stuff (this is wrong, really...

{/// Directory records }
{/// v[0] is ip with port address }
{/// v[1] is vector of info }
{/// v[2] is inhibit flag }
{/// v[3] is extra info, if non-nil }
const DWYCO_DIR_IP = '000';
const DWYCO_DIR_INFO_HOSTNAME = '001000';
const DWYCO_DIR_INFO_USERNAME = '001001';
const DWYCO_DIR_INFO_DESC = '001002';
const DWYCO_DIR_INFO_CALLACCEPT = '001003';
const DWYCO_DIR_INFO_CA_MAX_AUDIO = '001003000';
const DWYCO_DIR_INFO_CA_MAX_VIDEO = '001003001';
const DWYCO_DIR_INFO_CA_CHAT = '001003002';
const DWYCO_DIR_INFO_CA_MAX_AUDIO_RECV = '001003003';
const DWYCO_DIR_INFO_CA_MAX_VIDEO_RECV = '001003004';
const DWYCO_DIR_INFO_UID = '001004';
const DWYCO_DIR_INFO_REG = '001005';
const DWYCO_DIR_INFO_ONLINE = '001006';
const DWYCO_DIR_INFO_SHITLISTED = '001007';
const DWYCO_DIR_INFO_RATING = '001008';
const DWYCO_DIR_INFO_DIRECT = '001009';
const DWYCO_DIR_INFO_LOCATION = '001010';
const DWYCO_DIR_INFO_CLIENT_TYPE = '001011';
const DWYCO_DIR_INFO_PROFILE = '001012';
const DWYCO_DIR_INFO_IS_GOD = '001014';
const DWYCO_DIR_INHIBIT = '002';
const DWYCO_DIR_EXTRA = '003';

{/// Message summary records }
{/// 0: who from }
{/// 1: len }
{/// 2: id on server }
{/// 3: date vector }
const DWYCO_QMS_FROM = '000';
const DWYCO_QMS_LEN = '001';
const DWYCO_QMS_ID = '002';
const DWYCO_QMS_DATE_SENT = '003';
const DWYCO_QMS_DS_YEAR = '003000';
const DWYCO_QMS_DS_JDAY = '003001';
const DWYCO_QMS_DS_HOUR = '003002';
const DWYCO_QMS_DS_MINUTE = '003003';
const DWYCO_QMS_DS_SECOND = '003004';
{/// added locally: }
const DWYCO_QMS_PENDING_DEL = '004';
const DWYCO_QMS_IS_DIRECT = '005';
{/// oops, server has to put this way out here because }
{/// old software expects to see the above structure... }
{/// 6: rating of sender }
const DWYCO_QMS_SENDER_RATING = '006';
const DWYCO_QMS_ONLINE = '007';

{/// Message bodies after they are saved locally }
const DWYCO_QM_BODY_ID = '000';
const DWYCO_QM_BODY_FROM = '001';
const DWYCO_QM_BODY_TEXT_dont_use_directly = '002';
const DWYCO_QM_BODY_TEXT2 = '002';
const DWYCO_QM_BODY_ATTACHMENT = '003';
const DWYCO_QM_BODY_DATE = '004';
const DWYCO_QM_BODY_DATE_YEAR = '004000';
const DWYCO_QM_BODY_DATE_JDAY = '004001';
const DWYCO_QM_BODY_DATE_HOUR = '004002';
const DWYCO_QM_BODY_DATE_MINUTE = '004003';
const DWYCO_QM_BODY_DATE_SECOND = '004004';
{/// locally set }
const DWYCO_QM_BODY_SENT = '005';
{/// from server }
const DWYCO_QM_BODY_RATING = '006';
const DWYCO_QM_BODY_TIME_RECV = '007';
const DWYCO_QM_BODY_AUTOPLAY = '008';
const DWYCO_QM_BODY_AUTH_VEC = '007';
const DWYCO_QM_BODY_FORWARDED_BODY = '008';
const DWYCO_QM_BODY_NEW_TEXT_dont_use_directly = '009';
const DWYCO_QM_BODY_NEW_TEXT2 = '009';
const DWYCO_QM_BODY_FILE_ATTACHMENT = '012';

procedure dwyco_set_login_password(pw: PChar; len_pw: Integer); stdcall;
procedure dwyco_set_login_result_callback(cb: DwycoServerLoginCallback); stdcall;
procedure dwyco_database_login(); stdcall;
procedure dwyco_change_login_password(old_pw: PChar; len_opw: Integer; new_pw: PChar; len_npw: Integer; cb: DwycoCommandCallback);stdcall;
procedure dwyco_fetch_login_password(typed_pw: Integer; cb: DwycoCommandCallback);stdcall;

function dwyco_set_cmd_path(cmd: PChar; len: Integer): Integer; stdcall   ;
function dwyco_init: Integer ;stdcall   ;
function dwyco_exit: Integer ;stdcall   ; 

function dwyco_service_channels(var spin: Integer): Integer ;stdcall   ; 
procedure dwyco_set_client_version(str: PChar; len_str: Integer); stdcall;

function dwyco_set_all_mute(a: Integer) : Integer ;stdcall   ;
function dwyco_get_all_mute: Integer ;stdcall   ;
function dwyco_set_auto_squelch(a: Integer) : Integer ;stdcall   ;
function dwyco_get_auto_squelch: Integer ;stdcall   ;
procedure dwyco_set_full_duplex(a: Integer) ;stdcall   ;
function dwyco_get_full_duplex: Integer ;stdcall   ;
function dwyco_get_audio_output_in_progress(): Integer; stdcall   ;
function dwyco_get_squelched(): Integer; stdcall   ;
// This function only affects the limit used by the call-q when
// setting up multiple queued calls. If you don't call this, the default
// is 4. NOTE: this does NOT affect the number of calls you can queue up.
// This limits the number of concurrent calls that are streaming that
// have originated from the call queue.
// This function returns the previous value of the limit.
function dwyco_set_max_established_originated_calls(n: Integer): Integer; stdcall;


{
procedure dwyco_connect_all(var ip_list: DwycoArrayOfPointers;
                            var uid_list: DwycoArrayOfPointers;
                            num: Integer; 
                            dcb: DwycoChannelDestroyCallback; 
                            dcb_arg1: Pointer; 
                            ecb: DwycoCallEstablishedCallback; 
                            ecb_arg1: Pointer; 
                            scb: DwycoStatusCallback; 
                            scb1_arg1: Pointer; 
                            send_video: Integer; 
                            recv_video: Integer; 
                            send_audio: Integer; 
                            recv_audio: Integer; 
                            private_chat: Integer; 
                            public_chat: Integer; 
                            pw: PChar 
                            )
 ;stdcall   ; 
}

type
DwycoCallDispositionCallback = procedure(call_id: Integer;
                                         chan_id: Integer;
                                         what: Integer;
                                         user_arg: Pointer;
                                         uid: PChar; len_uid: integer); stdcall;

const DWYCO_CALLDISP_ESTABLISHED = 1;                 // call is connected and accepted, use "chan_id" to destroy call 
const DWYCO_CALLDISP_FAILED = 2;                      // call setup failed, never was able to connect to callee, ignore "chan_id" 
const DWYCO_CALLDISP_TERMINATED = 3;                  // call which was "established" is now ended (from either side.)
const DWYCO_CALLDISP_REJECTED = 4;                    // call connected, but call screening rejected the call on the callee side
const DWYCO_CALLDISP_REJECTED_PASSWORD_INCORRECT = 5; // call reject by password screening
const DWYCO_CALLDISP_REJECTED_BUSY = 6;               // call rejected by resource limit or user action
const DWYCO_CALLDISP_CANCELED = 7;                    // call setup was canceled locally before connect succeeded
const DWYCO_CALLDISP_STARTED = 8;                     // call initiated
// this interface is a little better than the old one
// in that you can specifically say if you want the
// call queued up (duplicates not allowed), or not (duplicates
// allowed, and the call is initiated immediately.)
// set q_calls = 1 if you want the calls q'd
procedure dwyco_connect_all3(var ip_list: DwycoArrayOfPointers;
                             var uid_list: DwycoArrayOfPointers;
                             num: Integer;
                             cdc: DwycoCallDispositionCallback;
                             cdc_arg1: Pointer;
                             scb: DwycoStatusCallback;
                             scb1_arg1: Pointer;
                             send_video: Integer;
                             recv_video: Integer;
                             send_audio: Integer;
                             recv_audio: Integer;
                             private_chat: Integer;
                             public_chat: Integer;
                             pw: PChar ;
                             call_type: PChar;
                             len_call_type: Integer;
                             q_calls: Integer) ;stdcall   ;

// old interface, do not use if you can avoid it.
// this one implicitly started calls immediately if you
// handed it a single callee, or queued it if more than
// one was specified, which is confusing
procedure dwyco_connect_all2(var ip_list: DwycoArrayOfPointers;
                             var uid_list: DwycoArrayOfPointers;
                             num: Integer;
                             cdc: DwycoCallDispositionCallback;
                             cdc_arg1: Pointer;
                             scb: DwycoStatusCallback;
                             scb1_arg1: Pointer;
                             send_video: Integer;
                             recv_video: Integer;
                             send_audio: Integer;
                             recv_audio: Integer;
                             private_chat: Integer;
                             public_chat: Integer;
                             pw: PChar ;
                             call_type: PChar;
                             len_call_type: Integer) ;stdcall   ;

procedure dwyco_cancel_call(call_id: Integer); stdcall;
{ chan to call returns -1 if the chan isn't associated with a call}
function dwyco_chan_to_call(chan_id: Integer): Integer; stdcall;

procedure dwyco_set_call_appearance_callback(cb: DwycoCallAppearanceCallback) ;stdcall   ; 

procedure dwyco_set_zap_appearance_callback(cb: DwycoZapAppearanceCallback) ;stdcall   ; 

procedure dwyco_set_call_appearance_death_callback(cb: DwycoCallAppearanceDeathCallback) ;stdcall   ; 

function dwyco_call_accept(id: Integer): Integer ;stdcall   ; 

function dwyco_call_reject(id: Integer; session_ignore: Integer): Integer ;stdcall   ;

function dwyco_zap_accept(id: Integer; always_accept: Integer): Integer ;stdcall   ;

function dwyco_zap_reject(id: Integer; session_ignore: Integer): Integer ;stdcall   ;


procedure dwyco_set_directory_downloaded_callback(cb: DwycoDirectoryDownloadedCallback) ;stdcall   ;
procedure dwyco_set_debug_message_callback(cb: DwycoStatusCallback);stdcall   ;
procedure dwyco_debug_dump();stdcall   ;

// 2010.1
//function dwyco_directory_starting: Integer ;stdcall   ;
//
//function dwyco_directory_online: Integer ;stdcall   ;
//
//function dwyco_directory_downloading: Integer ;stdcall   ;

procedure dwyco_set_directory_sort_column(col: integer);stdcall   ;

function dwyco_get_server_list(var list_out: DWYCO_SERVER_LIST;
                               var numlines: Integer): Integer ;stdcall   ;

// 2010.1
//function dwyco_switch_to_server(i: Integer): Integer ;stdcall   ;
//function dwyco_disconnect_server: Integer ;stdcall   ;

function dwyco_switch_to_chat_server(i: Integer): Integer ;stdcall   ;


// this can be used to check a lobby password without
// affecting current connections. you *must* be connected to
// some lobby for this to work.
// Return values:
// 0 = cid is invalid, or some other error. note that if you are not
// connected to a lobby, this will always return 0.
// 1 = lobby doesn't require a password
// 2 = lobby requires a password and the pw is ok
// -1 = lobby requires a password but supplied password is incorrect.

function dwyco_check_chat_server_pw(cid: PChar; pw: PChar): Integer; stdcall;

// returns:
// -1 : cid is invalid, or not connected to a server
// 0 : cid does not require a password
// 1 : cid has a password set
function dwyco_chat_server_has_pw(cid: PChar): Integer; stdcall;

// Return values:
// 0 = cid is invalid, or some immediate resource problem connecting to server.
// in both cases, the current lobby info is still valid.
// -1 = password incorrect. the current lobby info and connection is unaffected
// 1 = switch is in progress, all current lobby info is invalidated until
// the server switch is completed successfully.
// if the server switch fails, you will have to switch back to a system
// server using switch_to_chat_server in order to revalidate user lobby info.

function dwyco_switch_to_chat_server2(cid: PChar; pw: PChar): Integer ;stdcall;
function dwyco_disconnect_chat_server: Integer ;stdcall   ;

// 2010.1
//procedure dwyco_room_create(name: PChar; pw: PChar; cb: DwycoCommandCallback; user_arg: Pointer); stdcall;
//procedure dwyco_room_enter(name: PChar; pw: PChar; cb: DwycoCommandCallback; user_arg: Pointer); stdcall;
//procedure dwyco_room_delete(name: PChar; cb: DwycoCommandCallback; user_arg: Pointer); stdcall;

procedure dwyco_set_invisible_state(invis: Integer); stdcall;
function dwyco_get_invisible_state(): Integer; stdcall;
procedure dwyco_refresh_directory(); stdcall;
{/// message composition functions }

function dwyco_make_zap_composition(must_be_zero: PChar): Integer ;stdcall   ;
function dwyco_dup_zap_composition(compid: Integer): Integer; stdcall;
function dwyco_make_forward_zap_composition(uid : PChar; {must be 0 to forward unsaved message, uid for saved messages}
	                                    len_uid: Integer;
	                                    msg_id: PChar;
	                                    strip_forward_text: Integer): Integer ;stdcall   ;

function dwyco_is_forward_composition(compid: Integer): Integer; stdcall   ;
function dwyco_flim(compid: Integer): Integer; stdcall   ;

function dwyco_delete_zap_composition(compid: Integer): Integer ;stdcall   ;

function dwyco_zap_record(compid: Integer; 
                          video: Integer; 
                          audio: Integer; 
                          pic: Integer; 
                          frames: Integer; 
                          dcb: DwycoChannelDestroyCallback; 
                          dcb_arg1: Pointer; 
                          var ui_id_out: Integer): Integer ;stdcall   ; 

function dwyco_zap_stop(compid: Integer): Integer ;stdcall   ;

function dwyco_zap_play(compid: Integer;
                        dcb: DwycoChannelDestroyCallback;
                        dcb_arg1: Pointer;
                        var ui_id_out: Integer): Integer ;stdcall   ;

function dwyco_zap_send(compid: Integer;
                        var recipient_list: DwycoArrayOfPointers;
                        nrecip: Integer;
                        text: PChar;
                        mscb: DwycoMessageSendCallback;
                        mscb_arg1: Pointer;
                        dscb: DwycoStatusCallback;
                        dscb_arg1: Pointer): Integer ;stdcall   ;

function dwyco_zap_send2(compid: Integer;
                        var recipient_list: DwycoArrayOfPointers;
                        nrecip: Integer;
                        text: PChar;
                        no_forward: Integer;
                        mscb: DwycoMessageSendCallback;
                        mscb_arg1: Pointer;
                        dscb: DwycoStatusCallback;
                        dscb_arg1: Pointer): Integer ;stdcall   ;

function dwyco_zap_send_sms(compid: Integer;
                            phone_number: PChar;
                            text: PChar;
                            mscb: DwycoMessageSendCallback;
                            mscb_arg1: Pointer;
                            dscb: DwycoStatusCallback;
                            dscb_arg1: Pointer): Integer ;stdcall   ;


function dwyco_zap_send_cancel(compid: Integer): Integer ;stdcall   ;

{/// functions for just viewing a zap message attachment }
function dwyco_make_zap_view(list: DWYCO_SAVED_MSG_LIST;
                             recip_uid: PChar;
                             len_uid: Integer;
                             unsaved: Integer): Integer ;stdcall   ;

function dwyco_delete_zap_view(compid: Integer): Integer ;stdcall   ;

function dwyco_zap_play_view(viewid: Integer; 
                             dcb: DwycoChannelDestroyCallback; 
                             dcb_arg1: Pointer; 
                             var ui_id_out: Integer): Integer ;stdcall   ; 

function dwyco_zap_stop_view(viewid: Integer): Integer ;stdcall   ; 
(*
function dwyco_make_zap_view_file(filename: PChar) : Integer ;stdcall  ;
*)
function dwyco_zap_play_preview(viewid: Integer;
                                dcb: DwycoChannelDestroyCallback;
                                dcb_arg1: Pointer;
                                var ui_id_out: Integer): Integer ;stdcall   ;

function dwyco_zap_quick_stats_view(viewid: Integer;
                                    var has_video: Integer;
                                    var has_audio: Integer;
                                    var short_video: Integer): Integer ;stdcall   ;

procedure dwyco_command_from_keyboard(id : Integer;
				      com: Integer;
				      arg1: Integer;
				      arg2: Integer;
				      str: PChar;
				      len: Integer) ;stdcall  ;

procedure dwyco_line_from_keyboard(id: Integer;
				   line: PChar;
				   len: Integer) ;stdcall  ;

procedure dwyco_destroy_channel(chan_id: Integer) ;stdcall  ;
procedure dwyco_destroy_by_ui_id(ui_id: Integer) ;stdcall  ;
procedure dwyco_hangup_all_calls() ;stdcall  ;
procedure dwyco_pause_all_channels(pause_state: Integer); stdcall  ;
procedure dwyco_set_channel_destroy_callback(chan_id: Integer;
				             cb: DwycoChannelDestroyCallback;
				             user_arg: Pointer) ;stdcall  ;

procedure dwyco_set_call_acceptance_callback(cb: DwycoCallAppearanceCallback) ;stdcall  ;

function dwyco_set_profile(s1: PChar; len_s1: integer;
                           s2: PChar; len_s2: integer;
                           s3: PChar; len_s3: integer;
                           filename: PChar;
                           cb: DwycoProfileCallback;
                           user_arg: Pointer) : integer ;stdcall  ;
function dwyco_get_profile(uid: PChar; len_uid: integer;
                           cb: DwycoProfileCallback;
                           user_arg1: Pointer): integer ;stdcall  ;

procedure dwyco_inhibit_sac(flag: Integer) ;stdcall  ;
procedure dwyco_inhibit_lanmap(flag: Integer); stdcall;

type DwycoVVCallback = procedure (a: Pointer) ; stdcall;
type DwycoIVCallback = function (a: Pointer) : Integer; stdcall;
type DwycoIVICallback = function (a: Pointer; i: Integer) : Integer; stdcall;
type DwycoVidGetDataCallback = function(a: Pointer;
                                        var r: Integer;
                                        var c: Integer;
                                        var y: Pointer;
                                        var cr: Pointer;
                                        var cb: Pointer;
                                        var fmt: Integer;
                                        var captime: Integer) : Pointer; stdcall;

procedure dwyco_set_external_video_capture_callbacks(
	nw: DwycoVVCallback;
	del: DwycoVVCallback;
	init: DwycoIVICallback;
	has_data: DwycoIVCallback;
	need: DwycoVVCallback;
	pass: DwycoVVCallback;
	stop: DwycoVVCallback;
	get_data: DwycoVidGetDataCallback;
	free_data: DwycoVVCallback
	); stdcall;

procedure dwyco_set_external_video(i: Integer); stdcall;
	
type DwycoAudGetDataCallback = function(a: Pointer; var b:Integer; var c:Integer): Pointer;stdcall;

procedure dwyco_set_external_audio_capture_callbacks(
	nw: DwycoVVCallback;
	del: DwycoVVCallback;
	init: DwycoIVCallback;
	has_data: DwycoIVCallback;
	need: DwycoVVCallback;
	pass: DwycoVVCallback;
	stop: DwycoVVCallback;
	on: DwycoVVCallback;
	off: DwycoVVCallback;
	reset: DwycoVVCallback;
	status: DwycoIVCallback;
	get_data: DwycoAudGetDataCallback
	); stdcall;


type DwycoDevOutputCallback = function(a: Pointer; b: Pointer; c: Integer; d:Integer): Integer; stdcall;
type DwycoDevDoneCallback = function(a: Pointer; var b:Pointer; var c: Integer; var d:Integer): Integer; stdcall;
type DwycoIICallback = function(a: Pointer; b: Integer): Integer; stdcall;

procedure dwyco_set_external_audio_output_callbacks(
	nw: DwycoVVCallback;
	del: DwycoVVCallback;
	init: DwycoIVCallback;
	output: DwycoDevOutputCallback;
	done: DwycoDevDoneCallback;
	stop: DwycoIVCallback;
	reset: DwycoIVCallback;
	status: DwycoIVCallback;
	close: DwycoIVCallback;
	buffer_time: DwycoIICallback;
	play_silence: DwycoIVCallback;
	bufs_playing: DwycoIVCallback
	); stdcall;


{ ************************************************************************** }
{                                                                            }
{ dwyco_set_setting and dwyco_get_setting                                    }
{                                                                            }
{ You can use these functions in place of the (set,get)_xyz_data functions   }
{ below if you need to set or get just a single setting.                     }
{                                                                            }
{ The "name" parameter is the name of the setting to operate on and it has   }
{ the form:                                                                  }
{                                                                            }
{   group/setting-name                                                       }
{                                                                            }
{ where "group" is one of:                                                   }
{                                                                            }
{   net, call_acceptance, display, raw_files, user,                          }
{   video_format, video_input, zap                                           }
{                                                                            }
{ The setting name is one of the parameter names below in the set/get_data   }
{ calls.                                                                     }
{                                                                            }
{ The following example will set the email address in the user data:         }
{                                                                            }
{   dwyco_set_setting("user/email", "foo@bar.com");                          }
{                                                                            }
{ likewise                                                                   }
{                                                                            }
{   dwyco_get_setting("user/email", val, len, type);                         }
{                                                                            }
{ Will get the same setting, where val, len, and type are the same as for    }
{ dwyco_list_get calls.                                                      }
{                                                                            }
{ NOTE: When setting values that are integers, you still have to pass in a   }
{       string representing the value. the dll knows what type to            }
{       regurgitate in the get_setting (or corresponding get_*_data call.    }
{                                                                            }
{ These functions return 1 if the operation is successful, or 0 otherwise    }
{ (usually you have a wrong setting name.)                                   }
{                                                                            }
{ SPECIAL NOTE: there is one setting you can set with these settings that    }
{               isn't represented in the other functions below:              }
{                                                                            }
{ zap_data/send_auto_reply = integer, "0" = don't send, "1" = send auto reply}
{ zap_data/auto_reply_mid  = string, the message-id of the auto-reply zap    }
{                                                                            }
{ ************************************************************************** }
function dwyco_set_setting(name: PChar; value: PChar): Integer; stdcall;
function dwyco_get_setting(name: PChar; var value: PChar; var len:Integer; var dwyco_type:Integer): Integer; stdcall;


function dwyco_set_user_data(description: PChar;
                             username: PChar;
                             email: PChar;
                             last_name: PChar;
                             first_name: PChar;
                             dummy : Integer
                             ): Integer ;stdcall   ;

function dwyco_get_user_data(var description: PChar;
                             var username: PChar;
                             var email: PChar;
                             var last_name: PChar;
                             var first_name: PChar;
                             dummy : Integer
                             ): Integer ;stdcall   ;

function dwyco_set_vidcap_data(device: PChar; 
                               and_mask: PChar;
                               or_mask: PChar;
                               xor_mask: PChar;
                               offset: PChar;
                               blue: DWYCO_BOOL;
                               green: DWYCO_BOOL;
                               red: DWYCO_BOOL;
                               rgb16: DWYCO_BOOL;
                               rgb24: DWYCO_BOOL;
                               use_one_plane: DWYCO_BOOL;
                               yuv9: DWYCO_BOOL;
                               upside_down: DWYCO_BOOL;
                               palette: DWYCO_BOOL;
                               automatic: DWYCO_BOOL;
                               enable_color: DWYCO_BOOL;
                               yuv12: DWYCO_BOOL;
                               swap_uv: DWYCO_BOOL;
                               dummy : Integer
                               ): Integer ;stdcall   ;

function dwyco_get_vidcap_data(var device: PChar;
                               var and_mask: PChar;
                               var or_mask: PChar;
                               var xor_mask: PChar;
                               var offset: PChar;
                               var blue: DWYCO_BOOL;
                               var green: DWYCO_BOOL;
                               var red: DWYCO_BOOL;
                               var rgb16: DWYCO_BOOL;
                               var rgb24: DWYCO_BOOL;
                               var use_one_plane: DWYCO_BOOL;
                               var yuv9: DWYCO_BOOL;
                               var upside_down: DWYCO_BOOL;
                               var palette: DWYCO_BOOL;
                               var automatic: DWYCO_BOOL;
                               var enable_color: DWYCO_BOOL;
			       var yuv12 : DWYCO_BOOL;
			       var swap_uv : DWYCO_BOOL;
                               dummy : Integer
                               ): Integer ;stdcall   ;

function dwyco_set_config_display(fit_video: DWYCO_BOOL;
                                  integral_zoom: DWYCO_BOOL;
                                  jumbo_buttons: DWYCO_BOOL;
                                  no_buttons: DWYCO_BOOL;
                                  small_buttons: DWYCO_BOOL;
                                  mini_toolbar: DWYCO_BOOL;
                                  blinky: DWYCO_BOOL;
                                  dummy : Integer
                                  ): Integer ;stdcall   ;

function dwyco_get_config_display(var fit_video: DWYCO_BOOL;
                                  var integral_zoom: DWYCO_BOOL;
                                  var jumbo_buttons: DWYCO_BOOL;
                                  var no_buttons: DWYCO_BOOL;
                                  var small_buttons: DWYCO_BOOL;
                                  var mini_toolbar: DWYCO_BOOL;
                                  var blinky: DWYCO_BOOL;
                                  dummy : Integer
                                  ): Integer ;stdcall   ;

function dwyco_set_conn_remote_data(connrecv: DWYCO_BOOL;
                                    connsend: DWYCO_BOOL;
                                    connchat: DWYCO_BOOL;
                                    connrecv_audio: DWYCO_BOOL;
                                    connsend_audio: DWYCO_BOOL;
                                    block_on_connect: DWYCO_BOOL;
                                    pchat: DWYCO_BOOL;
                                    pw: PChar;
                                    dummy : Integer
                                    ): Integer ;stdcall   ;

function dwyco_get_conn_remote_data(var connrecv: DWYCO_BOOL;
                                    var connsend: DWYCO_BOOL;
                                    var connchat: DWYCO_BOOL;
                                    var connrecv_audio: DWYCO_BOOL;
                                    var connsend_audio: DWYCO_BOOL;
                                    var block_on_connect: DWYCO_BOOL;
                                    var pchat: DWYCO_BOOL;
                                    var pw: PChar;
                                    dummy : Integer
                                    ): Integer ;stdcall   ;

function dwyco_set_raw_files(raw_files_list: PChar;
                             raw_files_pattern: PChar;
                             use_list_of_files: DWYCO_BOOL;
                             use_pattern: DWYCO_BOOL;
                             preload: DWYCO_BOOL;
                             dummy : Integer
                             ): Integer ;stdcall   ;

function dwyco_get_raw_files(var raw_files_list: PChar;
                             var raw_files_pattern: PChar;
                             var use_list_of_files: DWYCO_BOOL;
                             var use_pattern: DWYCO_BOOL;
                             var preload: DWYCO_BOOL;
                             dummy : Integer
                             ): Integer ;stdcall   ;

function dwyco_set_video_input(device_name: PChar;
                               coded: DWYCO_BOOL;
                               raw: DWYCO_BOOL;
                               vfw: DWYCO_BOOL;
                               no_video: DWYCO_BOOL;
                               device_index: Integer;
                               dummy : Integer
                               ): Integer ;stdcall   ;

function dwyco_get_video_input(var device_name: PChar;
                               var coded: DWYCO_BOOL;
                               var raw: DWYCO_BOOL;
                               var vfw: DWYCO_BOOL;
                               var no_video: DWYCO_BOOL;
                               var device_index: Integer;
                               dummy : Integer
                               ): Integer ;stdcall   ;

function dwyco_set_call_accept(max_audio: Integer;
                               max_chat: Integer;
                               max_video: Integer;
                               max_audio_recv: Integer;
                               max_video_recv: Integer;
                               max_pchat: Integer;
                               pw: PChar;
                               auto_accept: DWYCO_BOOL;
                               require_pw: DWYCO_BOOL;
                               accept_any_rating: DWYCO_BOOL;
                               no_listen: DWYCO_BOOL;
                             dummy : Integer
                               ): Integer ;stdcall   ;

function dwyco_get_call_accept(var max_audio: Integer;
                               var max_chat: Integer;
                               var max_video: Integer;
                               var max_audio_recv: Integer;
                               var max_video_recv: Integer;
                               var max_pchat: Integer;
                               var pw: PChar;
                               var auto_accept: DWYCO_BOOL;
                               var require_pw: DWYCO_BOOL;
                               var accept_any_rating: DWYCO_BOOL;
                               var no_listen: DWYCO_BOOL;
                               dummy : Integer
                               ): Integer ;stdcall   ;

function dwyco_set_zap_data(always_server: DWYCO_BOOL;
                            always_accept: DWYCO_BOOL;
                            ignore: DWYCO_BOOL;
                            recv_all: DWYCO_BOOL;
                            zsave: DWYCO_BOOL;
                            use_old_timing: DWYCO_BOOL;
                            save_sent: DWYCO_BOOL;
                            no_forward_default: DWYCO_BOOL;
                            dummy : Integer
                            ): Integer ;stdcall   ;

function dwyco_get_zap_data(var always_server: DWYCO_BOOL;
                            var always_accept: DWYCO_BOOL;
                            var ignore: DWYCO_BOOL;
                            var recv_all: DWYCO_BOOL;
                            var zsave: DWYCO_BOOL;
                            var use_old_timing: DWYCO_BOOL;
                            var save_sent: DWYCO_BOOL;
                            var no_forward_default: DWYCO_BOOL;
                            dummy : Integer
                            ): Integer ;stdcall   ;



function dwyco_set_rate_tweaks(expected_rate: LongInt;
                               frame_rate: Double;
                               max_udp_bytes: LongInt;
                               ref_interval: LongInt;
                               link_speed: LongInt;
                               link_speed_recv: LongInt;
                               dummy : Integer
                               ): Integer ;stdcall   ;



function dwyco_get_rate_tweaks(var expected_rate: LongInt;
                               var frame_rate: Double;
                               var max_udp_bytes: LongInt;
                               var ref_interval: LongInt;
                               var link_speed: LongInt;
                               var link_speed_recv: LongInt;
                               dummy : Integer
                               ): Integer ;stdcall   ;

// used for media select arg in the net data
//
const DWYCO_MEDIA_SELECT_DIRECT_ONLY = 0; // not impl.
const DWYCO_MEDIA_SELECT_TCP_ONLY = 1;    // force tcp SAC only
const DWYCO_MEDIA_SELECT_UDP_ONLY = 2;    // force udp SAC only
const DWYCO_MEDIA_SELECT_HANDSHAKE = 3;   // try to figure out cheapest way

function dwyco_set_net_data(primary_port: Integer;
                            secondary_port: Integer;
                            pal_port: Integer;
                            force_non_firewall_friendly: DWYCO_BOOL;
                            nat_primary_port: Integer;
                            nat_secondary_port: Integer;
                            nat_pal_port: Integer;
                            advertise_nat_ports: DWYCO_BOOL;
                            disable_upnp : Integer;
                            media_select : Integer;
                            dummy : Integer
                            ): Integer ;stdcall   ;

function dwyco_get_net_data(var primary_port: Integer;
                            var secondary_port: Integer;
                            var pal_port: Integer;
                            var force_non_firewall_friendly: DWYCO_BOOL;
                            var nat_primary_port: Integer;
                            var nat_secondary_port: Integer;
                            var nat_pal_port: Integer;
                            var advertise_nat_ports: DWYCO_BOOL;
                            var disable_upnp: Integer;
                            var media_select: Integer;
                            dummy : Integer
                            ): Integer ;stdcall   ;

{$IFDEF WIN32}

function dwyco_get_vfw_drivers(): DWYCO_LIST; stdcall;
function dwyco_start_vfw(driver_idx: integer; main_hwnd: Pointer; client_hwnd: Pointer) : Integer; stdcall;
function dwyco_shutdown_vfw() : Integer; stdcall;
function dwyco_change_driver(new_idx : Integer) : Integer; stdcall;
function dwyco_is_preview_on() : Integer; stdcall;
function dwyco_preview_on(display_hwnd: Pointer) : Integer; stdcall;
function dwyco_preview_off() : Integer; stdcall;
function dwyco_vfw_format() : Integer; stdcall;
function dwyco_vfw_source() : Integer; stdcall;
procedure dwyco_set_main_msg_window(hwnd: Pointer); stdcall;
procedure dwyco_handle_msg(msg: PChar; msg_len: Integer; msgnum: Integer; wp: Integer; lp: Integer); stdcall;

{$ENDIF}

function dwyco_uid_online(uid: PChar; len_uid: Integer): Integer; stdcall;
// dwyco_uid_status returns:
// 0 for offline
// 1 for online, not available
// 3 for online, available
function  dwyco_uid_status(uid: Pchar; len_uid: Integer): Integer; stdcall;
function dwyco_uid_to_ip(uid: PChar; len_uid: Integer; var can_do_direct: Integer; var str_out:PChar): LongInt; stdcall;
procedure dwyco_pal_add(uid: PChar; len_uid: Integer); stdcall;
procedure dwyco_pal_delete(uid: PChar; len_uid: Integer); stdcall;
function dwyco_is_pal(uid: PChar; len_uid: Integer): Integer; stdcall;
function dwyco_pal_get_list() : DWYCO_LIST;stdcall;
procedure dwyco_pal_relogin();stdcall;
function dwyco_is_ignored(user_id: PChar; len_uid: Integer): integer;stdcall;
procedure dwyco_ignore(user_id: PChar; len_uid: Integer);stdcall;
procedure dwyco_unignore(user_id: PChar; len_uid: Integer);stdcall;
procedure dwyco_session_ignore(user_id: PChar; len_uid: Integer);stdcall;
function dwyco_ignore_list_get(): DWYCO_LIST;stdcall;
function dwyco_session_ignore_list_get(): DWYCO_LIST;stdcall;
procedure dwyco_add_old_timing(user_id: PChar; len_uid: Integer);stdcall;
procedure dwyco_del_old_timing(user_id: PChar; len_uid: Integer);stdcall;
function dwyco_uid_to_info(user_id: PChar; len_uid: Integer; var cant_resolve_now: integer): DWYCO_LIST;stdcall;
//2010.1
//NOTE: DND never really worked right
//procedure dwyco_set_dnd(dnd: Integer);stdcall;
//function dwyco_get_dnd(): Integer;stdcall;

procedure dwyco_set_moron_dork_mode(m: integer); stdcall;
function dwyco_get_moron_dork_mode(): integer;stdcall;
procedure dwyco_set_autosave_config(m: integer);stdcall;
procedure dwyco_set_auto_authenticate(m: integer);stdcall;

function dwyco_delete_user(uid: PChar; len_uid: Integer): Integer;stdcall;
function dwyco_empty_trash(): Integer;stdcall;
function dwyco_is_capturing_video(): Integer;stdcall;
function dwyco_count_trashed_users(): Integer;stdcall;

procedure dwyco_setup_autoupdate(f1: PChar; f2: PChar; f3: PChar; f4: PChar);stdcall;
procedure dwyco_force_autoupdate_check();stdcall;
procedure dwyco_set_autoupdate_status_callback(cb: DwycoAutoUpdateStatusCallback);stdcall;
function dwyco_start_autoupdate_download(cb: DwycoStatusCallback; arg1: Pointer; dcb: DwycoAutoUpdateDownloadCallback): Integer;stdcall;
procedure dwyco_abort_autoupdate_download();stdcall;

procedure dwyco_set_rating(rating: Integer);stdcall;
function dwyco_get_rating(): Integer;stdcall;

{ REGCODE and TRIAL functions }
{function dwyco_is_registered(): Integer; stdcall;}
{ WARNING: returns 1 for NOT EXPIRED, 0 otherwise}
{function dwyco_get_expired(): Integer; stdcall;}
procedure dwyco_set_regcode(s: PChar); stdcall;
procedure dwyco_sub_get(var code_out: PChar; var len_out: Integer); stdcall;

// 2010.1
//NOTE: pal visibility defunct as of NOV 2009
//{
//* val = 0 to UNset the attribute, nonzero SETS the attribute
//* setting to always-visible UNsets the never-visible attribute
//and vice-versa.
//* normal state is BOTH never-vis and always-vis OFF
//* each call to the set functions will cause a re-login to the
//pal server, so don't do them too often.
//}
//procedure dwyco_always_visible(uid: PChar; len_uid: Integer; val: Integer); stdcall;
//procedure dwyco_never_visible(uid: PChar; len_uid: Integer; val: Integer); stdcall;
//function dwyco_is_never_visible(uid: PChar; len_uid: Integer) : Integer; stdcall;
//function dwyco_is_always_visible(uid: PChar; len_uid: Integer) : Integer; stdcall;


{$IFDEF IMW32}
// EXTERNAL INSTANT MESSAGE SYSTEM INTERFACE
// note: the DLL internally maps external IM
// systems ids (uin for icq, login names for aim, for example)
// into dwyco uids (normally 80-bit unique identifiers).
// these uids act the same as normal DLL uids, except
// some operations are no-ops (like adding to
// the dwyco pal list), and some are handled internally
// for whatever system the uid is from (send message, for
// example, needs to send the messages via the proper
// messenger.
// unfortunately, there isn't an easy mapping back and
// forth between these uids because of differences in
// length and so on, so unless you are actively logged
// into a system, you won't be able to know what type
// of uid it is. this normally isn't a problem.

// external IM handling defines and function (ICQ, AIM)
// note: all uids will return as "dwyco" type if you
// are not logged into icq/aim, whatever. this is
// because we can't map uids to uin and back
// before we know the complete pal list from these
// other systems.
//#define DWYCO_EIM_SYSTEM_CANT_RESOLVE -1
const DWYCO_EIM_SYSTEM_DWYCO=0; // note: returned by pal_type, not used otherwise
const DWYCO_EIM_SYSTEM_ICQ=1;
const DWYCO_EIM_SYSTEM_AIM=2;
const DWYCO_EIM_SYSTEM_MSN=3;
const DWYCO_EIM_SYSTEM_YAHOO=4;

// these can be (and probably should be) called before
// dwyco_init in order to set up external IM auto-logins
procedure dwyco_eim_stop(which: Integer); stdcall;
procedure dwyco_eim_start(which: Integer; cb: DwycoEIMServerLoginCallback); stdcall;
function dwyco_eim_status(which: Integer) : Integer;  stdcall;
procedure dwyco_eim_set_acct_info(which: Integer; uin: PChar; pw: PChar );stdcall;
// END call before dwyco_init
// this takes a dwyco uid, and tells you what type of IM system it
// is from. should be used for display, and ui tweaks only.
function dwyco_pal_type(uid: Pchar; len_uid: Integer): Integer;stdcall;

procedure dwyco_eim_pal_add(eim: Integer; sn: PChar; len_sn: Integer; nick: PChar; len_nick: Integer);stdcall;
procedure dwyco_eim_pal_del(eim: Integer; sn: PChar; len_sn: Integer);stdcall;
{$ENDIF}

implementation

{$IFDEF WIN32}
{$IFDEF IMW32}
procedure dwyco_eim_stop; external 'CDCDLL.DLL';
procedure dwyco_eim_start; external 'CDCDLL.DLL';
procedure dwyco_eim_set_acct_info; external 'CDCDLL.DLL';
function dwyco_pal_type; external 'CDCDLL.DLL';
{$ENDIF}
function dwyco_uid_status; external 'CDCDLL.DLL';
function dwyco_set_public_chat_init_callback; external 'CDCDLL.DLL';
function dwyco_set_private_chat_init_callback; external 'CDCDLL.DLL';
function dwyco_set_private_chat_display_callback; external 'CDCDLL.DLL';
function dwyco_set_public_chat_display_callback; external 'CDCDLL.DLL';
procedure dwyco_set_video_display_callback; external 'CDCDLL.DLL';
function dwyco_get_refresh_users; external 'CDCDLL.DLL';
function dwyco_get_rescan_messages; external 'CDCDLL.DLL';
function dwyco_load_users; external 'CDCDLL.DLL';
function dwyco_get_user_list; external 'CDCDLL.DLL';
function dwyco_get_message_bodies; external 'CDCDLL.DLL';
function dwyco_get_unsaved_messages; external 'CDCDLL.DLL';
function dwyco_unsaved_message_to_body; external 'CDCDLL.DLL';
procedure dwyco_list_release; external 'CDCDLL.DLL';
function dwyco_list_numelems; external 'CDCDLL.DLL';
function dwyco_list_get; external 'CDCDLL.DLL';
function dwyco_list_print; external 'CDCDLL.DLL';
function dwyco_init; external 'CDCDLL.DLL';
function dwyco_exit; external 'CDCDLL.DLL';
function dwyco_service_channels; external 'CDCDLL.DLL';
function dwyco_set_all_mute; external 'CDCDLL.DLL';
function dwyco_get_all_mute; external 'CDCDLL.DLL';
function dwyco_set_auto_squelch; external 'CDCDLL.DLL';
function dwyco_get_auto_squelch; external 'CDCDLL.DLL';
procedure dwyco_set_full_duplex; external 'CDCDLL.DLL';
function dwyco_get_full_duplex; external 'CDCDLL.DLL';
//procedure dwyco_connect_all; external 'CDCDLL.DLL';
procedure dwyco_set_call_appearance_callback; external 'CDCDLL.DLL';
procedure dwyco_set_zap_appearance_callback; external 'CDCDLL.DLL';
procedure dwyco_set_call_appearance_death_callback; external 'CDCDLL.DLL';
function dwyco_call_accept; external 'CDCDLL.DLL';
function dwyco_call_reject; external 'CDCDLL.DLL';
function dwyco_zap_accept; external 'CDCDLL.DLL';
function dwyco_zap_reject; external 'CDCDLL.DLL';
procedure dwyco_set_directory_downloaded_callback; external 'CDCDLL.DLL';
// 2010.1
//function dwyco_directory_starting; external 'CDCDLL.DLL';
//function dwyco_directory_online; external 'CDCDLL.DLL';
//function dwyco_directory_downloading; external 'CDCDLL.DLL';

function dwyco_get_server_list; external 'CDCDLL.DLL';
// 2010.1
//function dwyco_switch_to_server; external 'CDCDLL.DLL';
//function dwyco_disconnect_server; external 'CDCDLL.DLL';

function dwyco_make_zap_composition; external 'CDCDLL.DLL';
function dwyco_dup_zap_composition; external 'CDCDLL.DLL';
function dwyco_delete_zap_composition; external 'CDCDLL.DLL';
function dwyco_zap_record; external 'CDCDLL.DLL';
function dwyco_zap_stop; external 'CDCDLL.DLL';
function dwyco_zap_play; external 'CDCDLL.DLL';
function dwyco_zap_send; external 'CDCDLL.DLL';
function dwyco_zap_send2; external 'CDCDLL.DLL';
function dwyco_zap_send_cancel; external 'CDCDLL.DLL';
function dwyco_make_zap_view; external 'CDCDLL.DLL';
function dwyco_delete_zap_view; external 'CDCDLL.DLL';
function dwyco_zap_play_view; external 'CDCDLL.DLL';
function dwyco_zap_stop_view; external 'CDCDLL.DLL';
function dwyco_set_user_data; external 'CDCDLL.DLL';
function dwyco_get_user_data; external 'CDCDLL.DLL';
function dwyco_set_vidcap_data; external 'CDCDLL.DLL';
function dwyco_get_vidcap_data; external 'CDCDLL.DLL';
function dwyco_set_config_display; external 'CDCDLL.DLL';
function dwyco_get_config_display; external 'CDCDLL.DLL';
function dwyco_set_conn_remote_data; external 'CDCDLL.DLL';
function dwyco_get_conn_remote_data; external 'CDCDLL.DLL';
function dwyco_set_raw_files; external 'CDCDLL.DLL';
function dwyco_get_raw_files; external 'CDCDLL.DLL';
function dwyco_set_video_input; external 'CDCDLL.DLL';
function dwyco_get_video_input; external 'CDCDLL.DLL';
function dwyco_set_call_accept; external 'CDCDLL.DLL';
function dwyco_get_call_accept; external 'CDCDLL.DLL';
function dwyco_set_zap_data; external 'CDCDLL.DLL';
function dwyco_get_zap_data; external 'CDCDLL.DLL';
function dwyco_set_rate_tweaks; external 'CDCDLL.DLL';
function dwyco_get_rate_tweaks; external 'CDCDLL.DLL';
procedure dwyco_set_video_display_init_callback; external 'CDCDLL.DLL';
procedure dwyco_command_from_keyboard; external 'CDCDLL.DLL';
procedure dwyco_line_from_keyboard; external 'CDCDLL.DLL';
procedure dwyco_destroy_channel; external 'CDCDLL.DLL';
procedure dwyco_destroy_by_ui_id; external 'CDCDLL.DLL';
procedure dwyco_hangup_all_calls; external 'CDCDLL.DLL';
procedure dwyco_set_channel_destroy_callback; external 'CDCDLL.DLL';
procedure dwyco_set_call_acceptance_callback; external 'CDCDLL.DLL';
function dwyco_zap_play_preview; external 'CDCDLL.DLL';
{function dwyco_make_zap_view_file; external 'CDCDLL.DLL';}
function dwyco_start_vfw; external 'CDCDLL.DLL';
function dwyco_shutdown_vfw; external 'CDCDLL.DLL';
function dwyco_change_driver; external 'CDCDLL.DLL';
function dwyco_is_preview_on; external 'CDCDLL.DLL';
function dwyco_preview_on; external 'CDCDLL.DLL';
function dwyco_preview_off; external 'CDCDLL.DLL';
function dwyco_vfw_format; external 'CDCDLL.DLL';
function dwyco_vfw_source; external 'CDCDLL.DLL';
procedure dwyco_set_external_audio_output_callbacks; external 'CDCDLL.DLL';
procedure dwyco_set_external_audio_capture_callbacks; external 'CDCDLL.DLL';
procedure dwyco_set_external_video_capture_callbacks; external 'CDCDLL.DLL';
function dwyco_uid_online; external 'CDCDLL.DLL';
function dwyco_uid_to_ip; external 'CDCDLL.DLL';
procedure dwyco_pal_add; external 'CDCDLL.DLL';
procedure dwyco_pal_delete; external 'CDCDLL.DLL';
function dwyco_is_pal; external 'CDCDLL.DLL';
// 2010.1
//procedure dwyco_room_create; external 'CDCDLL.DLL';
//procedure dwyco_room_enter; external 'CDCDLL.DLL';
//procedure dwyco_room_delete; external 'CDCDLL.DLL';

procedure dwyco_set_invisible_state; external 'CDCDLL.DLL';
procedure dwyco_refresh_directory; external 'CDCDLL.DLL';
function dwyco_pal_get_list; external 'CDCDLL.DLL';
function dwyco_is_ignored; external 'CDCDLL.DLL';
procedure dwyco_ignore; external 'CDCDLL.DLL';
procedure dwyco_unignore; external 'CDCDLL.DLL';
procedure dwyco_session_ignore; external 'CDCDLL.DLL';
function dwyco_ignore_list_get; external 'CDCDLL.DLL';
function dwyco_session_ignore_list_get; external 'CDCDLL.DLL';
procedure dwyco_add_old_timing; external 'CDCDLL.DLL';
procedure dwyco_del_old_timing; external 'CDCDLL.DLL';
function dwyco_uid_to_info; external 'CDCDLL.DLL';
// 2010.1
//procedure dwyco_set_dnd; external 'CDCDLL.DLL';
//function dwyco_get_dnd; external 'CDCDLL.DLL';

function dwyco_get_vfw_drivers; external 'CDCDLL.DLL';
procedure dwyco_set_refresh_users; external 'CDCDLL.DLL';
procedure dwyco_set_rescan_messages; external 'CDCDLL.DLL';
function dwyco_delete_unsaved_message; external 'CDCDLL.DLL';
function dwyco_delete_saved_message; external 'CDCDLL.DLL';
function dwyco_save_message; external 'CDCDLL.DLL';
function dwyco_get_saved_message; external 'CDCDLL.DLL';
procedure dwyco_get_my_uid; external 'CDCDLL.DLL';
function dwyco_enable_video_capture_preview; external 'CDCDLL.DLL';
procedure dwyco_add_entropy_timer; external 'CDCDLL.DLL';
procedure dwyco_setup_autoupdate; external 'CDCDLL.DLL';
procedure dwyco_force_autoupdate_check; external 'CDCDLL.DLL';
procedure dwyco_set_autoupdate_status_callback; external 'CDCDLL.DLL';
function dwyco_start_autoupdate_download; external 'CDCDLL.DLL';
procedure dwyco_abort_autoupdate_download; external 'CDCDLL.DLL';
procedure dwyco_set_rating; external 'CDCDLL.DLL';
function dwyco_get_rating; external 'CDCDLL.DLL';
function dwyco_delete_user; external 'CDCDLL.DLL';
function dwyco_empty_trash; external 'CDCDLL.DLL';
function dwyco_is_capturing_video; external 'CDCDLL.DLL';
function dwyco_count_trashed_users; external 'CDCDLL.DLL';
procedure dwyco_pause_all_channels; external 'CDCDLL.DLL';
function dwyco_get_audio_output_in_progress; external 'CDCDLL.DLL';
function dwyco_get_squelched; external 'CDCDLL.DLL';
{function dwyco_is_registered; external 'CDCDLL.DLL';}
{function dwyco_get_expired; external 'CDCDLL.DLL';}
procedure dwyco_set_regcode; external 'CDCDLL.DLL';
procedure dwyco_set_debug_message_callback; external 'CDCDLL.DLL';
procedure dwyco_pal_relogin; external 'CDCDLL.DLL';
procedure dwyco_debug_dump; external 'CDCDLL.DLL';
procedure dwyco_set_motd_callback; external 'CDCDLL.DLL';
{procedure dwyco_set_unregister_callback ; external 'CDCDLL.DLL';}
function dwyco_get_profile; external 'CDCDLL.DLL';
function dwyco_set_profile; external 'CDCDLL.DLL';
procedure dwyco_set_directory_sort_column; external 'CDCDLL.DLL';
function dwyco_selective_chat_recipient_enable; external 'CDCDLL.DLL';
function dwyco_selective_chat_enable; external 'CDCDLL.DLL';
procedure dwyco_reset_selective_chat_recipients; external 'CDCDLL.DLL';
function dwyco_is_selective_chat_recipient; external 'CDCDLL.DLL';
function dwyco_get_invisible_state; external 'CDCDLL.DLL';
procedure dwyco_set_moron_dork_mode; external 'CDCDLL.DLL';
function dwyco_get_moron_dork_mode; external 'CDCDLL.DLL';
function dwyco_fetch_server_message; external 'CDCDLL.DLL';
procedure dwyco_set_login_password; external 'CDCDLL.DLL';
procedure dwyco_set_login_result_callback; external 'CDCDLL.DLL';
procedure dwyco_database_login; external 'CDCDLL.DLL';
procedure dwyco_set_main_msg_window; external 'CDCDLL.DLL';
procedure dwyco_handle_msg; external 'CDCDLL.DLL';
procedure dwyco_cancel_message_fetch; external 'CDCDLL.DLL';
procedure dwyco_change_login_password; external 'CDCDLL.DLL';
procedure dwyco_fetch_login_password; external 'CDCDLL.DLL';
procedure dwyco_update_user_info; external 'CDCDLL.DLL';
procedure dwyco_set_autosave_config; external 'CDCDLL.DLL';
function dwyco_set_net_data; external 'CDCDLL.DLL';
function dwyco_get_net_data; external 'CDCDLL.DLL';
// 2010.1
//procedure dwyco_always_visible; external 'CDCDLL.DLL';
//procedure dwyco_never_visible; external 'CDCDLL.DLL';
//function dwyco_is_never_visible; external 'CDCDLL.DLL';
//function dwyco_is_always_visible; external 'CDCDLL.DLL';

function dwyco_get_body_text; external 'CDCDLL.DLL';
function dwyco_get_body_array; external 'CDCDLL.DLL';
function dwyco_authenticate_body; external 'CDCDLL.DLL';
function dwyco_make_forward_zap_composition; external 'CDCDLL.DLL';
function dwyco_is_forward_composition; external 'CDCDLL.DLL';
function dwyco_flim; external 'CDCDLL.DLL';
// 2010.1
//procedure dwyco_set_pal_auth_callback ; external 'CDCDLL.DLL'   ;
//procedure dwyco_get_pal_auth_state ; external 'CDCDLL.DLL'   ;
//procedure dwyco_set_pal_auth_state ; external 'CDCDLL.DLL'   ;
//function dwyco_get_my_pal_auth_state ; external 'CDCDLL.DLL'   ;
//function dwyco_get_pal_auth_warning ; external 'CDCDLL.DLL'   ;
//function dwyco_pal_auth_granted; external 'CDCDLL.DLL'   ;
//procedure dwyco_revoke_pal_auth; external 'CDCDLL.DLL'   ;
//procedure dwyco_clear_pal_auths; external 'CDCDLL.DLL'   ;
//function dwyco_handle_pal_auth ; external 'CDCDLL.DLL'   ;

function dwyco_make_special_zap_composition; external 'CDCDLL.DLL';
function dwyco_is_special_message; external 'CDCDLL.DLL';
procedure dwyco_set_old_pal_recv; external 'CDCDLL.DLL';
{$IFDEF IMW32}
procedure dwyco_eim_pal_add; external 'CDCDLL.DLL';
procedure dwyco_eim_pal_del; external 'CDCDLL.DLL';
function dwyco_eim_status; external 'CDCDLL.DLL';
{$ENDIF}
procedure dwyco_set_external_video; external 'CDCDLL.DLL';
procedure dwyco_set_auto_authenticate; external 'CDCDLL.DLL';
procedure dwyco_set_emergency_callback; external 'CDCDLL.DLL';
procedure dwyco_simple_diagnostics; external 'CDCDLL.DLL';
function dwyco_uid_g; external 'CDCDLL.DLL';
procedure dwyco_set_chat_ctx_callback; external 'CDCDLL.DLL';
procedure dwyco_set_chat_ctx_callback2; external 'CDCDLL.DLL';
procedure dwyco_set_chat_server_status_callback; external 'CDCDLL.DLL';
procedure dwyco_chat_create_user_lobby; external 'CDCDLL.DLL';
procedure dwyco_chat_remove_user_lobby; external 'CDCDLL.DLL';
procedure dwyco_network_diagnostics; external 'CDCDLL.DLL';
function dwyco_set_cmd_path; external 'CDCDLL.DLL';
function dwyco_switch_to_chat_server;external 'CDCDLL.DLL';
function dwyco_switch_to_chat_server2;external 'CDCDLL.DLL';
function dwyco_disconnect_chat_server;external 'CDCDLL.DLL';
function dwyco_zap_send_sms;external 'CDCDLL.DLL';
procedure dwyco_estimate_bandwidth; external 'CDCDLL.DLL';
procedure dwyco_connect_all2; external 'CDCDLL.DLL';
procedure dwyco_connect_all3; external 'CDCDLL.DLL';
procedure dwyco_cancel_call; external 'CDCDLL.DLL';
procedure dwyco_inhibit_sac; external 'CDCDLL.DLL';
function dwyco_zap_quick_stats_view; external 'CDCDLL.DLL';
function dwyco_make_file_zap_composition; external 'CDCDLL.DLL';
function dwyco_is_file_zap; external 'CDCDLL.DLL';
function dwyco_copy_out_file_zap; external 'CDCDLL.DLL';
procedure dwyco_set_call_screening_callback; external 'CDCDLL.DLL';
function dwyco_chat_addq; external 'CDCDLL.DLL';
function dwyco_chat_delq; external 'CDCDLL.DLL';
function dwyco_chat_talk; external 'CDCDLL.DLL';
function dwyco_chat_mute; external 'CDCDLL.DLL';
function dwyco_chat_set_filter; external 'CDCDLL.DLL';
function dwyco_chat_set_demigod; external 'CDCDLL.DLL';
function dwyco_chat_set_unblock_time; external 'CDCDLL.DLL';
function dwyco_chat_set_unblock_time2; external 'CDCDLL.DLL';
function dwyco_chat_clear_all_demigods; external 'CDCDLL.DLL';
procedure dwyco_sub_get; external 'CDCDLL.DLL';
function dwyco_chan_to_call; external 'CDCDLL.DLL';
function  dwyco_chat_get_admin_info; external 'CDCDLL.DLL';
function dwyco_chat_set_sys_attr; external 'CDCDLL.DLL';
procedure dwyco_enable_activity_checking; external 'CDCDLL.DLL';
function dwyco_chat_set_activity_state; external 'CDCDLL.DLL';
procedure dwyco_set_inactivity_time; external 'CDCDLL.DLL';
function dwyco_chat_send_popup; external 'CDCDLL.DLL';
procedure dwyco_set_pals_only; external 'CDCDLL.DLL';
function dwyco_get_pals_only; external 'CDCDLL.DLL';
procedure dwyco_inhibit_lanmap; external 'CDCDLL.DLL';
function dwyco_channel_streams; external 'CDCDLL.DLL';
function dwyco_get_lobby_name_by_id2; external 'CDCDLL.DLL';
function dwyco_set_auto_reply_msg; external 'CDCDLL.DLL';
function dwyco_get_setting; external 'CDCDLL.DLL';
function dwyco_set_setting; external 'CDCDLL.DLL';
function dwyco_get_ah2; external 'CDCDLL.DLL';
function dwyco_set_max_established_originated_calls; external 'CDCDLL.DLL';
procedure dwyco_set_client_version; external 'CDCDLL.DLL';
function dwyco_check_chat_server_pw; external 'CDCDLL.DLL';
function dwyco_chat_server_has_pw; external 'CDCDLL.DLL';

{$ENDIF}
{$IFDEF LINUX}
{ really out of date, so just get rid of it for now }
{$ENDIF}
end.
