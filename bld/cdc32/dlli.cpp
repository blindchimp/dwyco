
/* ===
; Copyright (c) 1995-present, Dwyco, Inc.
; 
; This Source Code Form is subject to the terms of the Mozilla Public
; License, v. 2.0. If a copy of the MPL was not distributed with this file,
; You can obtain one at https://mozilla.org/MPL/2.0/.
*/
//
// C API for Dwyco Video Conferencing
//
// NOTES on formatting function definitions so they can be
// automatically wrapped to create debugging wrappers:
// general format is:
//
// DWYCOEXPORT
// ret-type
// funname(argtype argname, <etc.>)
//
// the argument list MUST be all on one line.
//
// if you have composite arguments that represent counted buffers,
// name the arguments like this (put "len" somewhere in the name of the count
// parameter):
// funname(const char *foo, int len_foo)
//
// the wrapper generated will format this a little differently so it is
// easier to read.
//
// if you have "out" parameters that are filled in by the callee, name
// the arguments with a "_out" suffix, like this:
// funname(int bar, int *bar_out)
//
// the wrappers will display the "out" param both before and after the call.
//
// if you have counted byte buffers that are "out" params:
// funname(int bar, const char *foo_out int *len_foo_out)
//
// the wrapper program will only wrap generic "C" style functions, not
// whacky c++ stuff.
//
// the "runtime" for the wrapper makes some assumptions specific to this
// API in order to print things in easier to read format: byte buffers
// with arguments whose names are "uid" or "user_id", it will print them
// as 10-byte hex UID's, despite the length being something else (this is
// a convention for UID, they are 10 bytes random strings.)
//
//
// Here is some general information about the Dwyco
// core API:
//
// Threads:
// The main DLL should only be called by your app's main
// thread. All callbacks are synchronous, and only happen
// when you enter "service_channels". There is no need to
// assume the callbacks might fire via other threads.
//
// The basic architecture of the DLL is oriented around polling.
//
// The DLL does most of its processing when you call "service_channels",
// (ie, from your main thread.) Another thread  starts
// when there is audio playing. There are other threads started by
// platform specific systems, like audio capture and playback, but
// generally you do not need to worry about them.
//
// Just about all events in the UI are signaled by a callback.
// IT IS VERY IMPORTANT THAT THE CLIENT OF THIS DLL BE IMMUNE
// TO SITUATIONS WHERE A CALLBACK IS FIRED, BUT NO UI ELEMENTS
// OR CONTEXT EXISTS RELATED TO THAT CALLBACK.
// What this means is, you should expect the
// DLL to be sloppy about providing callbacks in a particular
// order (unless ordering is specifically noted below).
// It may provide more callbacks than you need, etc.
// It is the client's job to notice that the callback is useless
// and do nothing.
//
// Some events are signaled by polling special functions
// associated with the event (events like "the user list changed").
//
// Basic Data structures used at the interface.
//---------------------------------------------
// The interface was explicitly designed to use only
// vanilla C with the most basic data items, in order to improve
// portability to different platforms. Generally, memory
// returned via this api contains information that must be
// copied out before the next call to a function in the api.
// You can't assume memory is managed by the same runtime either.
// Calls that require an explicit "free" are noted so you can
// copy out the data, then call this api's free function.

// The only data structure that needs extra explanation
// is the DWYCO_LIST.
//
// The DWYCO_LIST encapsulates a complicated C++ class
// that is used internally, but which isn't
// practical to expose in this API.
//
// DWYCO_LIST's are returned by functions that have
// composite results (such as
// message listings, etc. which have 100's of rows in many cases)
// There are access functions that treat DWYCO_LIST's like
// tables, so you can retrieve items in a list using
// row, column coordinates. Rows that have structures
// that are defined by the API (like the message listing)
// have #defines in the API header file for each field
// in the listing.
//
// Identifiers used by the API
// ---------------------------
//
// Many of the functions and callbacks that require interaction with
// the UI have "id" parameters. These id's are generated
// by the API, and are unique
// (and never reused) throughout the life of the program.
//
// * User ID's are random strings that are
// unique for every user account managed by the system.
// Right now, all clients
// use 80-bit random numbers for user ID's. The random
// numbers are generated by the API from an entropy pool
// that must be fed from good entropy sources, like
// mouse movements, key times, etc.
//
// * Message ID's are ascii hex strings, usually generated from
// the same entropy pool as user ID's. They are globally
// unique for each message in the world (with any luck.)
// At this point, all message ID's are 20 characters
// long (they are generated from 80-bit random numbers.)
//
//
// Real-time PAL reporting:
// ------------------------
// This is also handled completely by the system.
// You can set an "interest list" of uid's that the system
// will track globally and notify you of status changes.
//
// XXXX------------------
// NOTE NOTE NOTE!
// This API provided some level of calling and call screening
// but around 2014 I dumped it in favor of having the client
// of the API implement its own call screening and setup.
//
// all this described calling stuff is old-hat, telephony style
// handling of calls... which i dumped in favor of something more
// streamlined. i'm not sure how much of this stuff still works
// after my hackery... real time calls work fine, just the call
// setup and stuff mentioned here may not function right.
// XXXX------------------

// "Real-time" calls
// -----------------
//
// Initiating calls
//-----------------
// There is a single function that you call to start the call
// process. During the process, you get callbacks at various
// points as the call progresses (setup, ringing, final connection, etc.)
// If the call is accepted by the remote party, the DLL starts
// streaming all the media selected when the call was set up.
// You will start receiving "video display" callbacks for that
// channel if incoming video was selected. For outgoing preview
// there will also be "video display" callbacks, but they will
// be for another channel (described below) that is specifically
// for previewing outgoing video.
// In windows, audio is handled completely internally, playing
// and mixing all incoming audio, and sensing and sending
// local audio to the remote side. For other platforms some
// other mechanism will have to be devised.
// Text chat callbacks will also start arriving, and depending
// on the type of chat (real-time or line-by-line) the UI
// will have to parse and display the chat commands appropriately.
//
// Receiving calls
// ----------------
// Receiving a call begins with a "call appearance" callback.
// The DLL handles all call screening (passwords, call limits,
// ignore list, ratings filters, etc.) before the call appearance
// callback is issued.
// The call appearance callback should arrange to display
// some kind of accept/reject box in order to allow the user
// to indicate whether to take the call. The call appearance
// can disappear while the user is thinking about it (for example
// if the remote user cancels the call before it is picked-up by the
// callee.)
// (note: this is a little messed up now, if you have autoaccept turned on
// you won't get a "call appearance", but you really need a callback
// to say a new call is setup without going thru the accept/reject deal.)
//
// NOTE: i think this is sorta fixed in the latest dll where you can
// at least set up a call screening callback that does nothing, but
// you can use to get notification of an auto-accepted call.

// Ending calls
// ------------
// If the remote end hangs up a call, the local DLL will sense
// the termination, and start issuing "channel destroy" callbacks
// for channels associated with that network connection.
// The destroy callback functions will have to map the
// channel to the appropriate UI elements that need to be
// changed when a call is terminated.
//
// If the local end wants to hang up a call, you can
// issue the "hangup all calls" or "hangup all channels associated
// with this ui_id". Destroy callbacks will then fire
// as the appropriate local channels are destroyed. The
// remote end senses this, and remote call teardown is handled as
// mentioned above.
//
// Multi-user calls
//------------------
// Multi-user calls are basically like N > 1 single-user
// calls. The DLL is put into "conferencing" mode, which
// changes the way call screening works (can't remember the
// exact changes, will have to note that below.) The main
// problem with multi-user calls is providing an easy
// way of getting into them for a user. The directory
// structure provides "conference rooms" for this purpose.
// In CDC32 and ICUII4,
// a user enters a "room"  and clicks one button, and it
// is assumed they want to connect to everyone in the room.
// This is one way of doing it, but the DLL doesn't enforce
// this (ie, it has no idea what a room is). Any good method of
// getting a set of IP addresses and UID's to connect with
// should work.
//
// The method of chat is also usually changed for multi-user
// calls to "line-by-line" chat. "Public chat" channels are
// assumed to be transmitted to all connected parties
// while private chats are one-to-one.
// XXXXXX----------------
//
//
// Zap messages:
// 	Message composing:
//
//	Composing a message requires the UI to create a
// 	composition context. The context has operations that
//	allow a message with any sort of media to be composed.
//	The composition is assumed to be done when the
//      "send" is issued, or
//	a "cancel" is issued to the composition object. There
//	are functions to record media to the message,
//  stop recording, send message, etc.
//
//	Message receiving:
//	Zap messages also go thru a "call screening" process
//  when they are sent directly between clients. If autoaccepting
//  zaps is NOT on, a "zap appearance" callback is issued
//  which should popup an accept/reject box for the message.
//  If autoaccept is on, the incoming message is processed
//  without intervention.
//
//  When a new message arrives, a callback is fired that
//  contains the message components for display. NO
//  DATA MANAGEMENT IS NECESSARY BY CLIENTS. The message
//  is stored internally in a list that can be manipulated
//  later.
//
//	Message displaying:
//	Each message has a unique id that can be used to
//	create a display context for the message. Using the
//	display context, the UI can call functions to play
//	the video part, stop playing, etc.
//
//	Message archiving:
//	All data management functions for messages are handled
//	by the DLL. The UI traverses the "user list", "message list"
//	and "unread message list" in order to display and select
//	messages to manipulate. This is important because where
//	messages reside (for example, on a server) is complicated
//	and needs to be managed the same for all clients of the DLL.
//
//

#undef TEST_NOT_REGISTERED

#ifdef DWYCO_TRACE
#include "dwyco_rename.h"
#endif
#define DEFAULT_INACTIVITY_TIME (5 * 60)
//#define DEFAULT_INACTIVITY_TIME 5 // for testing
static int Inactivity_time = DEFAULT_INACTIVITY_TIME;


//#undef NO_RTLOG
#include "dlli.h"
#include "trc.h"
#include "doinit.h"
#include "mmchan.h"
#include "uicfg.h"
#include "qmsg.h"
#include "aq.h"
#include "dwrtlog.h"
#include "audi.h"
#include "audo.h"
#include "audout.h"
#include "aconn.h"
#if defined(_Windows) && defined(USE_VFW)
#include "vfwmgr.h"
#endif
#include "audth.h"
#include "dirth.h"
#include "qauth.h"
#include "vccrypt2.h"
#include "msgdisp.h"
#include "mcc.h"
#include "aqkey.h"
#include "chatdisp.h"
#include "pbmcfg.h"
#include "qdirth.h"

#include "vfwinvst.h"
#include "cllaccpt.h"
#include "zapadv.h"
#include "rawfiles.h"
#include "vidinput.h"
#include "usercnfg.h"
#include "ratetwkr.h"

#include "vccomp.h"
#ifdef DWYCO_CDC_LIBUV
#include "vcuvsock.h"
#endif
#include "codec.h"
#include "filetube.h"

#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1
#include "md5.h"
#include "sha.h"
using namespace CryptoPP;
using namespace Weak;
#include "filters.h"
#include "files.h"
#include "autoup.h"
#include "fnmod.h"
#include "prfcache.h"
#include "pkcache.h"
#include "msgddll.h"
#include "callq.h"
#include "mmcall.h"
#include "calldll.h"
#include "chatgrid.h"
#include "chatops.h"
#include "netdiag.h"
#include "calllive.h"
#include "chatq.h"
#include "ezset.h"
#include "asshole.h"
#include "se.h"
#include "fl.h"
#include "pgdll.h"
#include "lanmap.h"
#include "theoracol.h"
#include "tpgmdec.h"
#include "imgmisc.h"
#include "ser.h"
#if defined(_MSC_VER)
#include <io.h>
#endif
#ifdef _Windows
#include <io.h>
#ifdef _MSC_VER
#include <direct.h>
#include <sys/utime.h>
#endif
#include <sys\stat.h>
#include <time.h>
#endif

#ifdef VIDGRAB_HACKS
#include "vgexp.h"
#endif

#ifdef LINUX
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#endif
#include "sepstr.h"
#include "xinfo.h"
#include "dhsetup.h"
#include "dhgsetup.h"
#include "qsend.h"
#include "directsend.h"
#include "msend.h"
#include "cdcpal.h"
#include "dwyco_rand.h"
#include "dwscoped.h"
#include "ta.h"
#include "cdcver.h"
#include "dwcls_timer.h"
#include "qmsgsql.h"
#include "vcwsock.h"
#include "backsql.h"
#include "grpmsg.h"
#include "upnp.h"

using namespace dwyco;


#undef index

extern vc Pals;
extern vc Session_ignore;
extern vc Mutual_ignore;
extern vc Server_list;
extern int Send_auth;
extern vc Current_authenticator;
extern vc Current_session_key;
extern DwVec<ValidPtr> CompositionDeleteQ;
extern int Crashed_last_time;
static void setup_callbacks();
static int UI_ids = 1000000;
static int Inited;
HWND Main_window;
extern int Reauthorize;
extern int Create_new_account;
extern int Database_id;

int uid_online(vc);
int uid_online_display(vc);
unsigned long uid_to_ip(vc, int&, int&prim, int&sec, int&pal);
void exit_conf_mode();
void enter_conf_mode();
void TryDeletes();
void async_handler(SOCKET, DWORD);
void async_lookup_handler(HANDLE, DWORD);
vc Current_room("lobby");
static void  bounce_destroy(MMChannel *mc, vc their_arg, void *their_func, ValidPtr);
DWYCO_LIST dwyco_list_from_vc(vc vec);
TAutoUpdate *TheAutoUpdate;
extern vc Pal_auth_state;
extern int Disable_SAC;
static int Disable_UPNP = 0;
extern int Media_select;
extern int Inhibit_database_thread;
int Inhibit_auto_connect;
extern int Inhibit_pal;
vc Current_chat_server_id;
extern int Pal_logged_in;
int is_invisible();
void set_invisible(int);

static int ReadOnlyMode;
extern int QSend_inprogress;
extern int QSend_special_inprogress;
extern int All_mute;
extern vc My_rating;
extern vc Transmit_stats;
extern vc StackDump;
extern vc My_connection;
extern vc KKG;
extern int Chat_online;
extern CallQ *TheCallQ;

int dllify(vc v, const char*& str_out, int& len_out);
vc Client_version;
DH_alternate *dwyco::Current_alternate;

#undef CPPLEAK
#ifdef CPPLEAK
extern int beginning_of_world;
#define START_LEAK beginning_of_world = 0;
#define END_LEAK beginning_of_world = 1;
#else
#define START_LEAK
#define END_LEAK
#endif

#ifndef WIN32
#undef DWYCO_CRYPTO_PIPELINE
#else
#undef DWYCO_CRYPTO_PIPELINE
#endif

// this class is just a hanging place for holding the
// context of a server message fetch.
struct BodyView {
    BodyView ();
    ~BodyView ();
    static DwQueryByMember<BodyView> Bvqbm;
    ValidPtr vp;
    vc body;
#ifdef DWYCO_CRYPTO_PIPELINE
    vc dmsg; // decrypted message
#endif
    vc msg_id;
    MMChannel *xfer_channel;
    void cancel();
    DwycoMessageDownloadCallback msg_download_callback;
    void *mdc_arg1;
    DwycoStatusCallback status_callback;
    void *scb_arg1;

    // this is a signal that is emitted as a progress indicator during
    // file transfers. it is intended for display purposes only.
    ssns::signal4<DwString, vc, DwString, int> progress_signal;
};

DwQueryByMember<BodyView> BodyView::Bvqbm;

BodyView::BodyView() :
    vp(this)
{
    status_callback = 0;
    msg_download_callback = 0;
    xfer_channel = 0;
    scb_arg1 = 0;
    mdc_arg1 = 0;
    Bvqbm.add(this);
}

BodyView::~BodyView()
{
    vp.invalidate();
    Bvqbm.del(this);
}

static void get_done(vc m, void *, vc msg_id, ValidPtr vp);
void
BodyView::cancel()
{
    if(xfer_channel)
    {
        xfer_channel->schedule_destroy(MMChannel::HARD);
        xfer_channel = 0;
    }

    dirth_cancel_callbacks(get_done, this, ReqType());
}

static void
set_status(MMChannel *mc, vc msg, void *, ValidPtr vp)
{
    //ValidPtr& vp = *(ValidPtr *)arg;
    if(!vp.is_valid())
        return;
    BodyView *q = (BodyView *)(void *)vp;
    if(!q)
        return;
    int e = mc->expected_size;
    if(e == 0)
        e = 1;
    int p = (int)(((double)mc->total_got * 100) / e);
    if(q->status_callback)
    {
        (*q->status_callback)((int)q->vp, msg, p, q->scb_arg1);
    }
    q->progress_signal.emit(DwString(q->msg_id), My_UID, DwString(msg), p);
}

#ifdef DWYCO_CRYPTO_PIPELINE
#include "dwpipe.h"
struct emsg_input
{
    emsg_input(ValidPtr vp, const DwString& s,
               const DwString& d, const DwString& k) :
        bv(vp), src(s), dst(d), key(k) {}
    DwString src;
    DwString dst;
    DwString key;
    ValidPtr bv;
};

struct omsg_output
{
    omsg_output(ValidPtr vp, int ok) : bv(vp), res(ok) {}
    ValidPtr bv;
    int res;
};

class MsgDecryptPipelineOp : public DwPipelineOp<emsg_input, omsg_output>
{
    virtual int execute(emsg_input *inp, omsg_output *& out) {
        int ok = decrypt_attachment2(inp->src, inp->key, inp->dst);
        out = new omsg_output(inp->bv, ok);
        delete inp;
        return 1;
    }

};

static DwPipeline<emsg_input, omsg_output> *Decrypt_pipeline;
static void add_server_response_to_direct_list(BodyView *q, vc msg);
void
new_pipeline()
{
    Decrypt_pipeline = new DwPipeline<emsg_input, omsg_output>(0, 2);
    Decrypt_pipeline->add_operation(new MsgDecryptPipelineOp);
    Decrypt_pipeline->init();
}

static void
add_to_pipeline(BodyView *q, const DwString& src, const DwString& dst, const DwString& key)
{

    emsg_input *em = new emsg_input(q->vp, src, dst, key);
    Decrypt_pipeline->put(em);
}

static void
pipeline_result(ValidPtr vp, int ok)
{
    if(!vp.is_valid())
        return;
    BodyView *q = (BodyView *)(void *)vp;

    if(!ok)
    {
        // if we can't decrypt it, there is really something
        // wrong with the message, but it could be a lot of things
        // that we can't figure out easily (like the attachment
        // might be corrupt or truncated, our local private
        // key might have changed, etc.) chances are though, we
        // will never be able to decrypt it, so we might as well
        // delete it. if our key has gotten mucked up locally,
        // we may also *never* be able to decrypt tons of things
        // until the key is reset in the server.
        if(q->msg_download_callback)
            (*q->msg_download_callback)(q->vp, DWYCO_MSG_DOWNLOAD_DECRYPT_FAILED, q->msg_id, q->mdc_arg1);
        vc from = q->dmsg[QQM_BODY_FROM];
        se_emit_msg(SE_MSG_DOWNLOAD_FAILED_PERMANENT_DELETED_DECRYPT_FAILED, q->msg_id, from);
        dirth_send_ack_get(My_UID, q->msg_id, QckDone(0, 0));
        TRACK_ADD(MR_msg_decrypt_failed, 1);
        return;
    }
    else
    {
        TRACK_ADD(MR_msg_decrypt_ok, 1);
    }
    add_server_response_to_direct_list(q, q->dmsg);
    delete q;
}

static void
poll_pipeline()
{
    omsg_output *res = 0;
    if(Decrypt_pipeline->get(res))
    {
        pipeline_result(res->bv, res->res);
        delete res;
    }
}

#else
void new_pipeline() {}
#endif

//static DwycoVideoDisplayInitCallback video_display_init_callback;
static DwycoVideoDisplayCallback video_display_callback;
static DwycoPublicChatInitCallback public_chat_init_callback;
static DwycoPrivateChatInitCallback private_chat_init_callback;
static DwycoPrivateChatDisplayCallback private_chat_display_callback;
static DwycoPublicChatDisplayCallback public_chat_display_callback;
static DwycoCallAppearanceCallback call_appearance_callback;
static DwycoCallAppearanceDeathCallback call_appearance_death_callback;
static DwycoCallAppearanceCallback call_accepted_callback;
static DwycoZapAppearanceCallback zap_appearance_callback;
static DwycoAutoUpdateStatusCallback autoupdate_status_callback;
DwycoStatusCallback dbg_msg_callback;
static DwycoServerLoginCallback login_callback;
//DwycoPalAuthCallback pal_auth_callback;
DwycoEmergencyCallback dwyco_emergency_callback;
DwycoChatCtxCallback dwyco_pg_callback;
DwycoChatCtxCallback2 dwyco_pg_callback2;
DwycoSystemEventCallback dwyco_system_event_callback;
//static DwycoStatusCallback dwyco_chat_server_status_callback;
static DwycoUserControlCallback dwyco_user_control_callback;
static DwycoCallScreeningCallback dwyco_call_screening_callback;
static DwycoCommandCallback dwyco_alert_callback;
static DwycoStatusCallback dwyco_call_bandwidth_callback;
static DwycoActivityCallback dwyco_activity_callback;

void init_tracer();

DWYCOEXPORT
void
dwyco_trace_init()
{
#ifdef DWYCO_TRACE
    if(!RTLog)
    {
        DwRTLog *tmp = new DwRTLog(newfn("rtlog.out").c_str());
        RTLog = tmp;
        init_rtlog();
    }
    init_tracer();

#endif
}

DWYCOEXPORT
void
dwyco_field_debug(const char *var, int num)
{
#ifdef DWYCO_FIELD_DEBUG
    DwString a("client:");
    a += var;
    TRACK_ADD_str(a.c_str(), num);
#endif
}

DWYCOEXPORT
void
dwyco_app_debug1(const char *fn, int line, const char *fmt, int a1, int a2)
{
#ifdef DW_RTLOG
    {if(RTLog) RTLOGSTART RTLog->vlog((fmt), fn, line, (a1), (a2)); RTLOGEND }
#endif
}

DWYCOEXPORT
void
dwyco_app_debug2(const char *fn, int line, const char *fmt, int a1, int a2, int a3, int a4, int a5)
{
#ifdef DW_RTLOG
    {if(RTLog) RTLOGSTART RTLog->vlog((fmt), fn, line, (a1), (a2), a3, a4, a5); RTLOGEND }
#endif
}

static
void
dbgdump(int id, const char *msg, int percent_done, void *user_arg)
{
    GRTLOG("dbg %s", msg, 0);
}

extern vc Online;
extern vc Cur_uids;

DWYCOEXPORT
void
dwyco_debug_dump()
{

    if(!dbg_msg_callback)
    {
        dbg_msg_callback = dbgdump;
    }

    (*dbg_msg_callback)(0, "Online", 0, 0);
    vc v = vc::map_to_vector(Online);
    for(int i = 0; i < v.num_elems(); ++i)
    {
        vc h = to_hex(v[i][0]);
        DwString a((const char *)h);
        a += " ";
        a += (const char *)v[i][1];
        (*dbg_msg_callback)(0, a.c_str(), 0, 0);
    }

    scoped_ptr<ChanList> chans(MMChannel::get_serviced_channels());
    ChanListIter i(chans.get());
    for(; !i.eol(); i.forward())
    {
        DwString a;
        MMChannel *mc = i.getp();
        char ind[200];
        ind[0] = '\0';
        if(mc->get_string_id().length() == 0)
            continue;
        if(mc->msg_chan)
        {
            ind[0] = 'm';
            ind[1] = 0;
        }
        else if(mc->server_channel)
        {
            ind[0] = 's';
            ind[1] = 0;
        }
        else if(mc->user_control_chan)
        {
            ind[0] = 'u';
            ind[1] = 0;
        }
        else
        {
            if(mc->is_coder())
                strcat(ind, "<Coder>");
            // note: this looks backwards, but what
            // we're showing is what the remote end of
            // the link is doing, not what we're doing...
#if 0
            if(mc->is_sender())
                strcat(ind, "vR");
            if(mc->is_receiver())
                strcat(ind, "vX");
            if(mc->is_audio_sender())
                strcat(ind, "aR");
            if(mc->is_audio_receiver())
                strcat(ind, "aX");
            if(mc->is_chatter())
                strcat(ind, "C");
            if(mc->is_private_chatter())
                strcat(ind, "c");

#endif
        }
        a = mc->get_string_id();
        a += " [";
        a += ind;
        a += "]";
        (*dbg_msg_callback)(0, a.c_str(), 0, 0);
    }
}

DWYCOEXPORT
int
dwyco_channel_attrs(int chan_id, int *is_sending_video, int *is_receiving_video, int *is_sending_audio, int *is_receiving_audio, int *is_private_chat, int *is_public_chat, int *is_msg_channel, int *is_server_channel)
{
    return 0;
}

// you must call dwyco_free_array on the returned pointer
DWYCOEXPORT
void
dwyco_random_string2(char **str_out, int len)
{
    DwString str;
    str = "";
    while(len > 0)
    {
        vc v = get_entropy();
        str += DwString((const char *)v, 0, v.len());
        len -= v.len();
    }
    *str_out = new char[str.length()];
    memcpy(*str_out, str.c_str(), str.length());
}

#define EZEKEY "\x5e\x17\x12\x8e\x41\xe3\xef\x2f\xe1\x0c"
// must call dwyco_free_array on returned pointer
DWYCOEXPORT
void
dwyco_eze2(const char *str, int len_str, char **str_out, int *len_out)
{
    vc key(VC_BSTRING, EZEKEY, 10);
    lh_bf_init_key_cbc(key, dwyco_rand());
    vc v(VC_BSTRING, str, len_str);
    vc eout;
    eout = lh_bf_xfer_enc(v);
    // slap the iv on the front
    DwString a;
    a = DwString((const char *)eout[0], 0, eout[0].len());
    a += DwString((const char *)eout[1], 0, eout[1].len());
    *str_out = new char[a.length()];
    *len_out = a.length();
    memcpy(*str_out, a.c_str(), a.length());

}

// must call dwyco_free_array on returned pointer
DWYCOEXPORT
void
dwyco_ezd2(const char *str, int len_str, char **str_out, int *len_out)
{
    vc key(VC_BSTRING, EZEKEY, 10);
    // hokey, we know the first 8 bytes are iv
    vc iv(VC_BSTRING, str, 8);
    vc es(VC_BSTRING, str + 8, len_str - 8);
    lh_bf_init_key_cbc(key, iv);
    vc e(VC_VECTOR);
    e[0] = iv;
    e[1] = es;
    vc eout;
    if(bf_xfer_dec(e, eout).is_nil())
    {
        *str_out = 0;
        return;
    }
    *str_out = new char[eout.len()];
    *len_out = eout.len();
    memcpy(*str_out, (const char *)eout, eout.len());
}

DWYCOEXPORT
void
dwyco_set_fn_prefixes( const char *sys_pfx, const char *user_pfx, const char *tmp_pfx)
{
    set_fn_prefixes(sys_pfx, user_pfx, tmp_pfx);
    //init_qmsg();
}

DWYCOEXPORT
void
dwyco_get_fn_prefixes(char *sys_pfx, int *sys_len_in_out, char *user_pfx, int *user_len_in_out, char *tmp_pfx, int *tmp_len_in_out)
{
    DwString sys;
    DwString user;
    DwString tmp;

    get_fn_prefixes(sys, user, tmp);

    if(*sys_len_in_out > sys.length())
    {
        memcpy(sys_pfx, sys.c_str(), sys.length());
        (sys_pfx)[sys.length()] = 0;
        *sys_len_in_out = sys.length() + 1;
    }

    if(*user_len_in_out > user.length())
    {
        memcpy(user_pfx, user.c_str(), user.length());
        (user_pfx)[user.length()] = 0;
        *user_len_in_out = user.length() + 1;
    }

    if(*tmp_len_in_out > tmp.length())
    {
        memcpy(tmp_pfx, tmp.c_str(), tmp.length());
        (tmp_pfx)[tmp.length()] = 0;
        *tmp_len_in_out = tmp.length() + 1;
    }

}

static
void
handle_crash_setup()
{
#ifndef DWYCO_NO_AUTOBUG
#ifndef _Windows
#define O_BINARY 0
#endif
    DwString crname(newfn("crashed"));
    int fd;
    fd = open(crname.c_str(), O_RDONLY|O_BINARY);
    if(fd != -1)
    {
        char ct;
        if(read(fd, &ct, sizeof(ct)) == sizeof(ct))
        {
            if(ct == 2)
            {
                // soft crash, just load up lhcore
                Crashed_last_time = 2;
                load_lhcore();
            }
            else
            {
                // hard crash, not sure what to do, except it is
                // system dependent where we might find logs, cores, etc.
                Crashed_last_time = 1;
            }
        }
        close(fd);
    }
    fd = open(crname.c_str(), O_WRONLY|O_BINARY|O_CREAT, 0777);
    if(fd != -1)
    {
        char ct = 1;
        if(write(fd, &ct, sizeof(ct)) != sizeof(ct))
        {
            close(fd);
            unlink(crname.c_str());
        }
        else
            close(fd);
    }
    unlink(newfn("lhcore").c_str());

#endif
}

static
void
handle_crash_done()
{
#ifndef DWYCO_NO_AUTOBUG
    unlink(newfn("crashed").c_str());
#endif
}

// synchronously stop all activities... mainly close all network
// related sockets in a way that will cause all the callbacks to be
// called. in progress operations are set up so that their
// operation returns "fail", as if the network failed.
// inhibit automatic retries for operations that might want to start
// in the background (like server reconnects, and whatnot.)
// you should cease calling any dwyco_service_channels at this point
// but other operations like message access, and other simple local operations
// should still work fine. this is a prelude to going to sleep, primarily
// useful on mobile devices...
static int Dwyco_suspended;
static int Suspend_listen_state;
static int Suspend_listen_mode;

DWYCOEXPORT
void
dwyco_suspend()
{
    if(Dwyco_suspended)
        return;
    // note: this inhibits all processing in "service_channels"
    // at this point
    Dwyco_suspended = 1;
    // note: this pal stuff won't be necessary once we switch to regular
    // server-based interest list.
    exit_pal();
    MMChannel::exit_mmchan();
    // empty out all the system messages
    while(se_process() || dirth_poll_response())
        ;
    save_qmsg_state();
    suspend_qmsg();
    exit_prf_cache();
    exit_pk_cache();
    save_entropy();
    int current_listen = is_listening();
    Suspend_listen_mode = current_listen;
    Suspend_listen_state = (int)get_settings_value("net/listen");
    set_listen_state(0);
    Inhibit_database_thread = 1;
    Inhibit_auto_connect = 1;
    Inhibit_pal = 1;
    // mobile platforms like to kill suspended processes, but that isn't
    // really a "crash"
    handle_crash_done();

}

// after a suspend, this is called to re-enable the auto-connection stuff
// and get reconnected to servers, etc.
DWYCOEXPORT
void
dwyco_resume()
{
    if(!Dwyco_suspended)
        return;
    handle_crash_setup();
    init_entropy();
    Inhibit_database_thread = 0;
    Inhibit_pal = 0;
    Inhibit_auto_connect = 0;
    QSend_inprogress = 0;
    QSend_special_inprogress = 0;
    turn_accept_on();
    set_listen_state(Suspend_listen_state);
    init_pal();
    resume_qmsg();
    init_prf_cache();
    init_pk_cache();
    start_database_thread();
    Dwyco_suspended = 0;
}

DWYCOEXPORT
void
dwyco_set_chat_ctx_callback(DwycoChatCtxCallback cb)
{
    dwyco_pg_callback = cb;
}

DWYCOEXPORT
void
dwyco_set_chat_ctx_callback2(DwycoChatCtxCallback2 cb)
{
    dwyco_pg_callback2 = cb;
}

DWYCOEXPORT
void
dwyco_set_system_event_callback(DwycoSystemEventCallback cb)
{
    dwyco_system_event_callback = cb;
}


DWYCOEXPORT
void
dwyco_set_debug_message_callback(DwycoStatusCallback cb)
{
    dbg_msg_callback = cb;
}

//DWYCOEXPORT
//void
//dwyco_set_chat_server_status_callback(DwycoStatusCallback cb)
//{
//    dwyco_chat_server_status_callback = cb;
//}

#if 0
// called each time the core needs someplace to put
// video. this can be used to generate a window or setup
// some association between whatever id is returned
// and some UI elements.

DWYCOEXPORT
void
dwyco_set_video_display_init_callback(DwycoVideoDisplayInitCallback cb)
{
    video_display_init_callback = cb;
}
#endif

DWYCOEXPORT
void
dwyco_set_video_display_callback(DwycoVideoDisplayCallback cb)
{
    video_display_callback = cb;
}

DWYCOEXPORT
void
dwyco_set_call_acceptance_callback(DwycoCallAppearanceCallback cb)
{
    call_accepted_callback = cb;
}

#if 0
DWYCOEXPORT
void
dwyco_set_pal_auth_callback(DwycoPalAuthCallback cb)
{
    pal_auth_callback = cb;
}
#endif

DWYCOEXPORT
void
dwyco_set_emergency_callback(DwycoEmergencyCallback cb)
{
    dwyco_emergency_callback = cb;
}

DWYCOEXPORT
void
dwyco_set_user_control_callback(DwycoUserControlCallback cb)
{
    dwyco_user_control_callback = cb;
}

DWYCOEXPORT
void
dwyco_set_alert_callback(DwycoCommandCallback cb)
{
    dwyco_alert_callback = cb;
}

DWYCOEXPORT
void
dwyco_set_call_screening_callback(DwycoCallScreeningCallback cb)
{
    dwyco_call_screening_callback = cb;
}

DWYCOEXPORT
void
dwyco_set_call_bandwidth_callback(DwycoStatusCallback cb)
{
    dwyco_call_bandwidth_callback = cb;
}

int
gen_new_grayview(int chan_id)
{
#if 0
    int id = ++UI_ids;
    GRTLOG("vid_display_init chan %d ui_id %d", chan_id, id);
    if(video_display_init_callback)
        (*video_display_init_callback)(chan_id, id);
    return id;
#endif
    return chan_id;
    return 0xfefefefe;
}

void
ppm_to_colorview(pixel **p, int cols, int rows, int chan_id)
{
    GRTLOG("video disp cb %p chan_id %d", video_display_callback, chan_id);
    if(video_display_callback)
        (*video_display_callback)(chan_id, (char **)p, cols, rows, 3);
}

void
pgm_to_grayview(gray **g, int cols, int rows, int chan_id)
{
    if(video_display_callback)
        (*video_display_callback)(chan_id, (char **)g, cols, rows, 1);
}


DWYCOEXPORT
void
dwyco_finish_startup()
{
    if(Create_new_account)
    {
        // note: this is not ideal, since we are calling this at
        // system startup time, before enough entropy has really
        // been gathered. unfortunately, we need the uid before we
        // can figure out which home server to contact, so we are
        // kinda stuck here for now.

        vc uid;
        vc dum;

        My_UID = gen_id();
        My_server_key = gen_id();
        Create_new_account = 0;
        Send_auth = 1;
#ifdef DWYCO_GEN_DSA
        vclh_dsa_init(vcnil);
        vclh_dsa_save("dsa.prv", "dsa.pub");
#endif
        // just to save the salts, basically, and create an
        // auth file to indicate we don't need to create a new
        // account. otherwise, the auth file is not updated or
        // used.
        save_auth_info(My_UID, My_server_key, "auth");
    }
    dh_load_account("dh.dif");

    const char *grpname;
    grpname = getenv("DWYCO_GROUP");
    if(!grpname)
        grpname = "foo@bar.com";

    DH_alternate *dha = new DH_alternate;
    dha->init(My_UID, grpname);
    dha->load_account(grpname);
    Current_alternate = dha;

    init_home_server();
    Inhibit_database_thread = 0;
    start_database_thread();
}

DWYCOEXPORT
void
dwyco_set_local_auth(int a)
{
    if(a)
    {
        Send_auth = 1;
    }
}

DWYCOEXPORT
void
dwyco_gen_pass(const char *pw, int len_pw, char **salt_in_out, int *len_salt_in_out, char **hash_out, int *len_hash_out)
{
    vc salt;
    if(*len_salt_in_out != 0)
        salt = vc(VC_BSTRING, *salt_in_out, *len_salt_in_out);

    vc vpw(VC_BSTRING, pw, len_pw);
    vc hash = gen_pass(vpw, salt);

    *hash_out = new char[20];
    *len_hash_out = 20;
    memcpy(*hash_out, (const char *)hash, 20);
    if(!salt.is_nil())
    {
        *len_salt_in_out = salt.len();
        *salt_in_out = new char[salt.len()];
        memcpy(*salt_in_out, (const char *)salt, salt.len());
    }
}

DWYCOEXPORT
int
dwyco_get_create_new_account()
{
    return Create_new_account;
}

DWYCOEXPORT
void
dwyco_free(char *p)
{
    delete p;
}

DWYCOEXPORT
void
dwyco_free_array(char *p)
{
    delete [] p;
}

DWYCOEXPORT
void
dwyco_free_image(char *p, int rows)
{
    ppm_freearray(p, rows);
}

// activity reporting
// basic idea is that the dll sets a timer and starts it
// running. if the timer expires, the dll goes into "inactive"
// state. you could imagine all kind of stuff regarding
// this state, like giving up the camera, turning off audio, etc.
// but for now, we just tell the servers our state so it can
// be reflected to others.

static DwTimer Activity_timer("activity");
static vc Activity_state;

DWYCOEXPORT
void
dwyco_enable_activity_checking(int on, int timeout, DwycoActivityCallback cb)
{
    Activity_timer.set_interval(timeout * 1000);
    //Activity_timer.set_autoreload(0);
    Activity_timer.set_oneshot(1);
    Activity_timer.reset();
    Activity_timer.load(timeout * 1000);
    if(on)
        Activity_timer.start();
    else
        Activity_timer.stop();
    dwyco_activity_callback = cb;
}

DWYCOEXPORT
void
dwyco_set_inactivity_time(int secs)
{
    Inactivity_time = secs;
    dwyco_enable_activity_checking(Activity_timer.is_running(), secs, dwyco_activity_callback);
}

DWYCOEXPORT
int
dwyco_chat_set_activity_state(int active, const char *state, int len_state)
{
    if(active >= 1)
    {
        return chatq_send_activity_state(vcnil);
    }
    else if(active == 0)
    {
        return chatq_send_activity_state("idle");
    }
    else if(active < 0)
    {
        return chatq_send_activity_state(vc(VC_BSTRING, state, len_state));
    }
    return 0;
}


static
void
crank_activity_timer()
{
    // note: activity timer fires once
    // to restart it, you have to call "enable" again
    if(Activity_timer.is_expired())
    {
        Activity_timer.stop();
        if(dwyco_activity_callback)
            (*dwyco_activity_callback)(Activity_timer.get_interval());
    }
}

static
DWYCOCALLCONV
void
internal_activity(int timeout)
{
    if(Activity_state.is_nil())
    {
        Activity_state = "idle";
        chatq_send_activity_state(Activity_state);
        GRTLOG("activity idle", 0, 0);
    }
}

static
void
update_activity()
{
    if(dwyco_activity_callback != internal_activity)
    {
        // user disabled, or installed their own
        return;
    }
    if(!Activity_state.is_nil())
    {
        Activity_state = vcnil;
        chatq_send_activity_state(vcnil);
        GRTLOG("activity detected", 0, 0);
    }
    dwyco_enable_activity_checking(1, Inactivity_time, internal_activity);
}

DWYCOEXPORT
void
dwyco_set_client_version(const char *str, int len_str)
{
    Client_version = vc(VC_BSTRING, str, len_str);
}


//
// call this once at startup, preferably before doing
// anything else (do it before starting the main
// event handling loop)
// this starts up the networking stuff too
static HANDLE DLL_mutex;
extern int ExternalVideoAcquisition;
extern int ExternalAudioAcquisition;
extern int ExternalAudioOutput;
DWYCOEXPORT
int
dwyco_init()
{
    if(Inited)
        return 1;

#ifdef __WIN32__
    // note: race condition here, but it isn't too likely
    // to be a problem and i can't be bothered to fix it at
    // the moment.
    if(OpenMutex(MUTEX_ALL_ACCESS, FALSE, DWYCO_AUTOUPDATE_MUTEX_NAME) == NULL)
    {
        DLL_mutex = CreateMutex(NULL, FALSE, DWYCO_AUTOUPDATE_MUTEX_NAME);
    }
    else
    {
        GRTLOG("cant get autoupdate mutex", 0, 0);
        return 0;
    }
#endif
    init_pval();
#ifdef LINUX

    signal(SIGPIPE, SIG_IGN);
#endif


    handle_crash_setup();
    load_info(Transmit_stats, "stats");
    unlink(newfn("stats").c_str());

    setup_callbacks();

    All_mute = 1;

#ifdef LINUX
    // note: these must be 1 if you have external audio in linux, since
    // init_codec probes the devices to see if they are there and can
    // be used for full-duplex stuff. what a hack. really need to fix
    // this
    ExternalAudioAcquisition = 1;
    ExternalAudioOutput = 1;
#endif
    init_codec();

    set_listen_state(DwNetConfigData.get_listen());
    if(DwNetConfigData.get_listen())
    {
        if(!Disable_UPNP)
        {
        int rport = (dwyco_rand() % (65500 - 10000)) + 10000;
        dwyco_set_net_data(rport, rport + 1, rport + 2,
                           rport, rport + 1, rport + 2,
                           1, 0, CSMS_TCP_ONLY, 1);
#ifndef DWYCO_NO_UPNP
        bg_upnp(rport, rport + 1, rport, rport + 1);
#endif
        }
    }


    // hmmm, maybe get rid of "finish-startup"
    Inhibit_database_thread = 1;

    start_database_thread();
    MMChannel::Moron_dork_mode = 1;
    init_pal();
    Cur_ignore = get_local_ignore();
#if !defined(DWYCO_POWERBROWSE) && !defined(ANDROID)
    //power_clean_safe();
#endif
    TheAutoUpdate = new TAutoUpdate;
    // note: this must be zero before the set_external call
    // otherwise you will call into an uninitialized vgcap dll
    ExternalVideoAcquisition = 0;

    // in windows, we do this here mainly to avoid having to
    // export this low level stuff into the client, which may not
    // be C/C++
#ifdef __WIN32__
    dwyco_set_external_video(0);
#ifndef DWYCO_POWERBROWSE
#ifndef DWYCO_NO_VIDEO_CAPTURE
#ifdef VIDGRAB_HACKS
    dwyco_set_external_video_capture_callbacks(
        vgnew,
        vgdel,
        vginit,
        vghas_data,
        vgneed,
        vgpass,
        vgstop,
        vgget_data,
        vgfree_data,
        vgget_video_devices,
        vgfree_video_devices,
        vgset_video_device,
        vgstop_video_device,
        vgshow_source_dialog,
        vgpreview_on,
        vgpreview_off,
        vg_set_appdata
    );
#endif
#endif
#endif
#endif

    ExternalAudioAcquisition = 0;
    ExternalAudioOutput = 0;
    char *gm;
    if((gm = getenv("kk27g")) != 0)
        KKG = gm;
    // note: for linux and macos, force external
#if defined(LINUX) || defined(MACOSX) || defined(ANDROID) || defined(DWYCO_IOS)
    ExternalVideoAcquisition = 1;
    ExternalAudioAcquisition = 1;
    ExternalAudioOutput = 1;
#endif

    // use the dll's idea of activity check by default.
    // the user can override by calling this itself.
    dwyco_enable_activity_checking(1, Inactivity_time, internal_activity);
    init_gj();
    Inited = 1;
    return 1;
}

//
// call this at the end of the program, after the main
// event loop ends (but don't call this on a program
// crash, use dwyco_emergency_exit for that.)
//
DWYCOEXPORT
int
dwyco_exit()
{
    if(!Inited)
        return 1;
    // just to flush stats
    TRACK_ADD(DLLI_exit, 1);
    dwyco_enable_activity_checking(0, 0, 0);
    pal_logout();
    exitaq();
    exit_audio_mixer();
    exit_audio_input();
    exit_audio_output();
    exit_codec();

#if defined(_Windows) && defined(USE_VFW)
    delete TheVFWMgr;
#endif
    // don't delete, since there may be post-dwyco_exit calls come
    // in from global dtors and stuff, just log them
    //delete RTLog;
    GRTLOG("end of exit", 0, 0);
#ifdef __WIN32__
    // i think this might be wrong too, since
    // we didn't get "ownership" of it... but what
    // the hell
    ReleaseMutex(DLL_mutex);
#endif
    handle_crash_done();
    Inited = 0;
    return 1;
}

DWYCOEXPORT
int
dwyco_bg_init()
{
    if(Inited)
        return 1;
    init_pval();
#ifdef LINUX
    signal(SIGPIPE, SIG_IGN);
#endif

    handle_crash_setup();
    load_info(Transmit_stats, "stats");
    setup_callbacks();
    init_bg_msg_send("bg.log");
    init_pal();
    set_listen_state(0);
    // hmmm, maybe get rid of "finish-startup"
    Inhibit_database_thread = 1;

    Cur_ignore = get_local_ignore();

    char *gm;
    if((gm = getenv("kk27g")) != 0)
        KKG = gm;

    Inited = 1;
    return 1;
}

DWYCOEXPORT
int
dwyco_bg_exit()
{
    if(!Inited)
        return 1;

    exit_bg_msg_send();

    GRTLOG("end of exit", 0, 0);
    handle_crash_done();
    Inited = 0;
    return 1;
}

DWYCOEXPORT
void
dwyco_power_clean_safe()
{
    power_clean_safe();
}

namespace dwyco
{
extern int Index_progress;
extern int Index_total;
}
DWYCOEXPORT
void
dwyco_power_clean_progress_hack(int *done_out, int *total_out)
{
    if(*total_out < 0)
    {
        dwyco::Index_total = -1;
        return;
    }
    *done_out = dwyco::Index_progress;
    *total_out = dwyco::Index_total;
}


static void
add_to_mutual_ignore(vc v)
{
    Mutual_ignore.add(v);
}
static void
load_ignoring_you(vc iy)
{
    if(iy.is_nil())
        return;
    iy.foreach(vcnil, add_to_mutual_ignore);
}


// SERVER related interface functions
static void
login_auth_results(vc m, void *, vc, ValidPtr)
{
    // XXX THIS WHOLE THING NEEDS TO BE REDONE XXX

    static vc invalid("invalid");
    static vc created("created");

    if(m[2] == invalid)
    {
        // this means that the account doesn't exist
        // *and* the account could never exist in this
        // server (ie, something is wrong with the id->server
        // mapping you are using)

        Auth_remote = 0;
        Send_auth = 0;
        Current_authenticator = vcnil;
        Current_session_key = vcnil;
        if(login_callback)
            (*login_callback)("BAD! Server mapping files are out of whack.", 0);
        end_database_thread();
        TRACK_ADD(MDB_login_invalid, 1);
        goto out;

    }
    if(m[1].is_nil())
    {
        Auth_remote = 0;
        if(login_callback)
            (*login_callback)("Server password incorrect or can't be verified.", 0);
        Current_authenticator = vcnil;
        Current_session_key = vcnil;
        TRACK_ADD(MDB_login_failed, 1);
    }
    else
    {
        Auth_remote = 1;
        // new auth protocol gives us some extra stuff

        if(!m[3].is_nil())
        {
            Current_authenticator = m[3][2];
            Pal_auth_state = m[3][3];
#ifdef DWYCO_ASSHAT
            set_asshole_param(m[3][4]);
#endif

            load_ignoring_you(m[3][5]);
            // note: need to have most things set up before loading
            // the inbox, that is why it is here (we have to do
            // fetch-infos, ignore checking, etc.
            dwyco::Avoid_pk = !m[3][6].is_nil();
            //dwyco::Avoid_pk = 1;
            Track_stats = !m[3][7].is_nil();
            TRACK_ADD_VC(dwyco_get_version_string(), 1);
            dwyco::Force_pk = !m[3][8].is_nil();
            dwyco::Enable_backups = !m[3][9].is_nil();
            if(m[3][10].type() == VC_INT)
                dwyco::Backup_freq = (int)m[3][10];
            pal_login();
        }
        if(m[2] == created)
        {
            if(login_callback)
                (*login_callback)("New account created (it didn't exist before.)", 2);
        }
        else
        {
            if(login_callback)
                (*login_callback)("Server login ok.", 1);
            TRACK_ADD(MDB_login_ok, 1);
        }
    }
    // reset this so we don't keep sending it in over and over
    Crashed_last_time = 0;

out:
    ;
}

static void
token_res(vc m, void *, vc, ValidPtr)
{
    if(m[1].is_nil())
        return;
    DeleteFile(newfn("token.dif").c_str());
}

// NOTE: before this is called, all the static public keys and
// other account info must be generated, as it gets sent to the
// server at this point.
void background_check_for_update_done(vc m, void *, vc, ValidPtr p);
static void
send_new()
{
    dirth_send_new4(My_UID, UserConfigData.get_username(),
                    UserConfigData.get_email(),
                    vcnil,
                    My_server_key,
                    Pal_auth_state,
                    QckDone(login_auth_results, 0));

    // send whatever debug stuff might be available
    if(Crashed_last_time != 0 || !Transmit_stats.is_nil() ||
            !StackDump.is_nil())
    {
        dirth_send_debug(My_UID, Crashed_last_time, StackDump, Transmit_stats, QckDone());
        Crashed_last_time = 0;
        StackDump = vcnil;
        Transmit_stats = vcnil;
    }
    vc token;
    if(load_info_e(token, "token.dif"))
    {
        dirth_send_set_token(My_UID, token, QckDone(token_res, 0));
    }

    dirth_send_check_for_update(My_UID, QckDone(background_check_for_update_done, 0));

}

static void
db_reconnect()
{
    if(Inhibit_auto_connect)
        return;
    static DwTimer db_timer("db_timer");
    static int been_here;
    if(Database_id == -1)
    {
        if(!been_here)
        {
            db_timer.set_oneshot(1);
            db_timer.load(1);
            db_timer.start();
            been_here = 1;
        }
        if(!db_timer.is_running())
        {
            db_timer.load((10 + (dwyco_rand() % 45)) * 1000);
            db_timer.start();
        }
        if(db_timer.is_expired())
        {
            db_timer.ack_expire();
            start_database_thread();
        }

    }
}

// must copy it out and call dwyco_free_array
DWYCOEXPORT
int
dwyco_get_authenticator(const char **a_out, int *len_a_out)
{
    if(Current_authenticator.is_nil())
    {
        // this is to keep the debugging stuff from crashing
        *a_out = new char[0];
        *len_a_out = 0;
        return 0;
    }
    char *o = new char[Current_authenticator.len()];
    *len_a_out = Current_authenticator.len();
    memcpy(o, (const char *)Current_authenticator, *len_a_out);
    *a_out = o;
    return 1;
}

#if 0
//DWYCOEXPORT
//void
//dwyco_set_login_password(const char *pw, int len_pw)
{
    Server_password = vc(VC_BSTRING, pw, len_pw);
}
#endif

DWYCOEXPORT
void
dwyco_set_login_result_callback(DwycoServerLoginCallback cb)
{
    login_callback = cb;
}

DWYCOEXPORT
void
dwyco_database_login()
{
    end_database_thread();
    start_database_thread();
}

DWYCOEXPORT
int
dwyco_database_online()
{
    return Database_online;
}

DWYCOEXPORT
int
dwyco_chat_online()
{
    return Chat_online;
}

DWYCOEXPORT
int
dwyco_database_auth_remote()
{
    return Auth_remote;
}

DWYCOEXPORT
void
dwyco_inhibit_database(int i)
{
    Inhibit_database_thread = i;
}

DWYCOEXPORT
void
dwyco_inhibit_pal(int i)
{
    Inhibit_pal = i;
}

DWYCOEXPORT
void
dwyco_inhibit_sac(int i)
{
    Disable_SAC = i;
}

DWYCOEXPORT
void
dwyco_inhibit_lanmap(int i)
{
    LANmap_inhibit = i;
}

DWYCOEXPORT
void
dwyco_fetch_info(const char *uid, int len_uid)
{
    vc vuid(VC_BSTRING, uid, len_uid);
    fetch_info(vuid);
}


static void
handle_deferred_msg_send()
{
    static int been_here;
    static DwTimer send_qd_msg_timer("send_qd");
    if(!been_here)
    {
        been_here = 1;
        send_qd_msg_timer.set_autoreload(1);
        send_qd_msg_timer.set_interval(10 * 1000);
        send_qd_msg_timer.start();
        qd_send_one();
    }
    if(!send_qd_msg_timer.is_running())
    {
        if(!msg_outq_empty())
        {
            send_qd_msg_timer.start();
        }
    }
    if(send_qd_msg_timer.is_expired())
    {
        send_qd_msg_timer.ack_expire();
        if(!qd_send_one())
        {
            send_qd_msg_timer.stop();
        }
    }
}
//
// the main grinder, call this at least
// every 100ms, and preferable on any windows
// message received. while service_channels
// is running, you will get callbacks.
// don't call this in a thread unless you
// want misery incarnate. call it from the
// idle handler
// and the return value
// is the number of milliseconds until the core
// expects its next timer to expire.
// you can use this to sleep until the next timer
// (or some other event, like a network event) would
// wake you up. you can also safely ignore this and
// just call at fixed intervals to simplify things.
//
// if spin_out is non-zero, it means the core wants to
// be called continuously.
// sometimes the core needs
// spinning to make things work properly (like
// timing up video playbacks and stuff.)
//

DWYCOEXPORT
int
dwyco_service_channels(int *spin_out)
{
    if(!Inited)
    {
        GRTLOG("dwyco_init must be called before service_channels", 0, 0);
        return 0;
    }
    if(Dwyco_suspended)
    {
        GRTLOG("service channels ignored (suspended)", 0, 0);
        return 0;
    }
    // there are weird cases where deleting some multimedia
    // qt objects can result in timer events being fired that causes
    // re-entry here, which is really bad. please, no exceptions, no
    // multi-threaded calls to this functions, etc.etc.
    static int entered = 0;
    if(entered)
        return 0;
    entered = 1;
#ifdef DWYCO_CDC_LIBUV
    vc_uvsocket::run_loop_once();
#endif
    dirth_poll_response();
    dirth_poll_timeouts();
    pal_tick();
    int ret = MMChannel::service_channels(spin_out);
    db_reconnect();
    if(Send_auth && Database_online)
    {
        Send_auth = 0;
        send_new();
    }

    int n = CompositionDeleteQ.num_elems();
    for(int i = 0; i < n; ++i)
    {
        ValidPtr v = CompositionDeleteQ[i];
        if(v.is_valid())
            delete (TMsgCompose *)(void *)v;
    }
    CompositionDeleteQ.set_size(0);
    TryDeletes();
    // client should really be sending in some
    // other source of entropy, but this is just
    // to make sure it doesn't stall completely.
    DWORD crap = GetTickCount();
    add_entropy_timer((char *)&crap, sizeof(crap));

#undef EMERGENCY_TEST
#ifdef EMERGENCY_TEST
    {
        if(access("panic", 0) == 0)
            oopanic("test panic");
        if(access("dbchange", 0) == 0)
        {
            extern DwycoEmergencyCallback dwyco_emergency_callback;

            if(dwyco_emergency_callback)
            {
                (*dwyco_emergency_callback)(DWYCO_EMERGENCY_DB_CHANGE, 1, "db servers changed location, must quit now.");
            }
            else
            {
                ::MessageBox(0, "db servers changed location, must quit now.", "quit", MB_OK);
                dwyco_exit();
                exit(0);
            }
        }

    }
#endif
#ifdef DWYCO_CRYPTO_PIPELINE
    poll_pipeline();
#endif
    handle_deferred_msg_send();
    se_process();
    crank_activity_timer();
    {
    DwString str;
    dwtime_t nex = DwTimer::next_expire_time(str) - DwTimer::time_now();
    GRTLOG("next timer %ld", nex, 0);
    GRTLOG("(%s)", str.c_str(), 0);
    entered = 0;
    return nex;
    }
}



DWYCOEXPORT
void
dwyco_add_entropy_timer(const char *crap, int len_crap)
{
    add_entropy_timer(crap, len_crap);
}

DWYCOEXPORT
void
dwyco_get_my_uid(const char **uid_out, int *len_out)
{
    *uid_out = (const char *)My_UID;
    *len_out = My_UID.len();
}

extern int Soft_preview_on;

DWYCOEXPORT
int
dwyco_enable_video_capture_preview(int on)
{
    MMChannel *mx = MMChannel::find_xmitter(0);
    if(mx)
    {
        if(on)
        {
            mx->coder->gv_id = MMCHAN_PREVIEW_CHAN_ID;
            Soft_preview_on = 1;
        }
        else
        {
            mx->coder->gv_id = -1;
            Soft_preview_on = 0;
        }
        return 1;
    }
    else
    {
        if(!on)
        {
            Soft_preview_on = 0;
            return 1;
        }
        RateTweakerXferValid save_rt;
        save_rt = RTUserDefaults;
        RTUserDefaults.set_max_frame_rate(12);

        MMChannel *mc = MMChannel::gen_chan();
        mc->tube = new DummyTube;
        mc->init_config(1);
        mc->recv_matches(mc->config);
        mc->start_service();
        if(!mc->build_outgoing(1, 1))
        {
            RTUserDefaults = save_rt;
            delete mc;
            GRTLOG("cant build video preview channel", 0, 0);
            return 0;
        }
        MMChannel *mcx = MMChannel::find_xmitter();
        if(mcx)
        {
            mcx->coder->gv_id = MMCHAN_PREVIEW_CHAN_ID;
        }
        RTUserDefaults = save_rt;
        mc->schedule_destroy(MMChannel::HARD);
        Soft_preview_on = 1;
        return 1;
    }
}

DWYCOEXPORT
void
dwyco_destroy_channel(int chan_id)
{
    MMChannel *m = MMChannel::channel_by_id(chan_id);
    if(!m)
        return;
    m->schedule_destroy();
    // see if this channel is being used by a call, and cancel
    // the call if it is in call setup mode
    MMCall *mmc = MMCall::channel_to_call(chan_id);
    if(!mmc)
        return;
    mmc->cancel_call();
}

DWYCOEXPORT
void
dwyco_hangup_all_calls()
{
    scoped_ptr<ChanList> cl(MMChannel::get_serviced_channels_net());
    ChanListIter cli(cl.get());
    for(; !cli.eol(); cli.forward())
    {
        MMChannel *mc = cli.getp();
        if(!mc->msg_chan && !mc->user_control_chan && !mc->server_channel && !mc->secondary_server_channel)
        {
            mc->schedule_destroy(MMChannel::HARD);
        }
    }
    TheCallQ->cancel_all();
}

DWYCOEXPORT
void
dwyco_cancel_call(int call_id)
{
    ValidPtr vp = cookie_to_ptr(call_id);
    if(!vp.is_valid())
        return;
    MMCall *mmc = (MMCall *)(void *)vp;
    mmc->cancel_call();
}

DWYCOEXPORT
void
dwyco_pause_all_channels(int p)
{
    MMChannel::pause_all_channels(p);
}

DWYCOEXPORT
int
dwyco_pause_channel_media_set(int chan_id, int pause_video, int pause_audio)
{
    MMChannel *m;
    if((m = MMChannel::channel_by_id(chan_id)) == 0)
        return 0;
    if(pause_video != -1)
    {
        m->pause_video = pause_video;
    }
    if(pause_audio != -1)
    {
        m->pause_audio = pause_audio;
    }
    return 1;
}

DWYCOEXPORT
int
dwyco_pause_channel_media_get(int chan_id, int *pause_video_out, int *pause_audio_out)
{
    MMChannel *m;
    if((m = MMChannel::channel_by_id(chan_id)) == 0)
        return 0;
    if(pause_video_out)
    {
        *pause_video_out = (int)m->pause_video;
    }
    if(pause_audio_out)
    {
        *pause_audio_out = (int)m->pause_audio;
    }
    return 1;
}

DWYCOEXPORT
int
dwyco_remote_pause_channel_media_get(int chan_id, int *pause_video_out, int *pause_audio_out)
{
    MMChannel *m;
    if((m = MMChannel::channel_by_id(chan_id)) == 0)
        return 0;
    if(pause_video_out)
    {
        *pause_video_out = (int)m->rem_pause_video;
    }
    if(pause_audio_out)
    {
        *pause_audio_out = (int)m->rem_pause_audio;
    }
    return 1;
}

DWYCOEXPORT
void
dwyco_set_channel_destroy_callback(int chan_id, DwycoChannelDestroyCallback cb, void *user_arg)
{
    MMChannel *m;
    if((m = MMChannel::channel_by_id(chan_id)) == 0)
        return;

    m->destroy_callback = bounce_destroy;
    m->dcb_arg1 = vc((long)user_arg);
    m->dcb_arg2 = (void *)cb;
}


// audio related things

extern int All_mute;
extern int Talk_override;
extern int Auto_squelch;
extern int Audio_full_duplex;
extern int Audio_hw_full_duplex;
extern int Has_audio_output;
extern int Has_audio_input;
extern CRITICAL_SECTION Audio_lock;
static int Squelched = 1;
int Inhibit_audio_control_changes;
namespace dwyco {
double Audio_delay = 2.0;
int Audio_agc;
int Audio_denoise;
}


DWYCOEXPORT
int
dwyco_get_audio_hw(int *has_audio_input_out, int *has_audio_output_out, int *audio_hw_full_duplex_out)
{
    if(has_audio_input_out)
        *has_audio_input_out = Has_audio_input;
    if(has_audio_output_out)
        *has_audio_output_out = Has_audio_output;
    if(audio_hw_full_duplex_out)
        *audio_hw_full_duplex_out = Audio_hw_full_duplex;
    return 1;
}

DWYCOEXPORT
int
dwyco_set_all_mute(int a)
{
    if(Inhibit_audio_control_changes)
    {
        GRTLOG("set_all_mute: audio control changes inhibited, req ignored", 0, 0);
        return 0;
    }
    EnterCriticalSection(&Audio_lock);
    All_mute = a;
    LeaveCriticalSection(&Audio_lock);
    return 1;
}

DWYCOEXPORT
int
dwyco_get_all_mute()
{
    int tmp;
    EnterCriticalSection(&Audio_lock);
    tmp = All_mute;
    LeaveCriticalSection(&Audio_lock);
    return tmp;
}

DWYCOEXPORT
int
dwyco_set_exclusive_audio(int a, int recv_chan_id)
{
#if 0
    if(Inhibit_audio_control_changes)
    {
        GRTLOG("set_exclusive_audio: audio control changes inhibited, req ignored", 0, 0);
        return 0;
    }
#endif
    MMChannel::Exclusive_audio = a;
    MMChannel::Exclusive_audio_id = recv_chan_id;
    return 1;
}

DWYCOEXPORT
int
dwyco_get_exclusive_audio(int *state_out, int *chan_id_out)
{
    if(state_out)
        *state_out = MMChannel::Exclusive_audio;
    if(chan_id_out)
        *chan_id_out = MMChannel::Exclusive_audio_id;
    return 1;
}


DWYCOEXPORT
int
dwyco_set_auto_squelch(int a)
{
    if(Inhibit_audio_control_changes)
    {
        GRTLOG("set_all_mute: audio control changes inhibited, req ignored", 0, 0);
        return 0;
    }
    Auto_squelch = a;
    return 1;
}

DWYCOEXPORT
int
dwyco_get_auto_squelch()
{
    return Auto_squelch;
}

DWYCOEXPORT
int
dwyco_get_squelched()
{
    return Squelched;
}

DWYCOEXPORT
void
dwyco_set_full_duplex(int a)
{
    EnterCriticalSection(&Audio_lock);
    Audio_full_duplex = a;
    LeaveCriticalSection(&Audio_lock);
}

DWYCOEXPORT
int
dwyco_get_full_duplex()
{
    int tmp;
    EnterCriticalSection(&Audio_lock);
    tmp = Audio_full_duplex;
    LeaveCriticalSection(&Audio_lock);
    return tmp;
}

DWYCOEXPORT
int
dwyco_get_audio_output_in_progress()
{
    extern CRITICAL_SECTION Audio_lock;
    EnterCriticalSection(&Audio_lock);
    int spk = TheAudioOutput && TheAudioOutput->device_bufs_playing();
    LeaveCriticalSection(&Audio_lock);
    return spk;

}

DWYCOEXPORT
int
dwyco_chat_addq(int q)
{
    START_LEAK
    return chatq_send_addq(q, My_UID);
}

DWYCOEXPORT
int
dwyco_chat_delq(int q, const char *uid, int len_uid)
{
    vc u = My_UID;
    if(uid)
    {
        u = vc(VC_BSTRING, uid, len_uid);
    }
    END_LEAK
    return chatq_send_delq(q, u);
}

DWYCOEXPORT
int
dwyco_chat_talk(int q)
{
    return chatq_send_talk(q, My_UID);
}

DWYCOEXPORT
int
dwyco_chat_mute(int q, int on)
{
    return chatq_send_mute(q, My_UID, on ? vctrue : vcnil);
}

DWYCOEXPORT
int
dwyco_chat_set_filter(int q, int gods_only,  int demigods_only, const char *uid, int len_uid)
{
    vc v;
    if(uid)
        v = vc(VC_BSTRING, uid, len_uid);
    return chatq_send_set_chat_filter(q, gods_only ? vctrue : vcnil,
                                      demigods_only ? vctrue : vcnil, v);
}

DWYCOEXPORT
int
dwyco_chat_set_demigod(const char *uid, int len_uid, int on)
{
    vc v(VC_BSTRING, uid, len_uid);
    return chatq_send_set_demigod(v, on ? vctrue : vcnil);
}

DWYCOEXPORT
int
dwyco_chat_clear_all_demigods()
{
    return chatq_send_clear_all_demigods();
}

DWYCOEXPORT
int
dwyco_chat_set_unblock_time2(int q, const char *uid, int len_uid, int tm, const char *reason)
{
    vc v(VC_BSTRING, uid, len_uid);
    vc res("unknown");
    if(reason != 0)
        res = reason;
    return chatq_send_set_unblock_time(q, v, tm, res);
}

DWYCOEXPORT
int
dwyco_chat_set_unblock_time(int q, const char *uid, int len_uid, int tm)
{
    return dwyco_chat_set_unblock_time2(q, uid, len_uid, tm, 0);
}

DWYCOEXPORT
int
dwyco_chat_get_admin_info()
{
    return chatq_send_get_admin_info();
}

DWYCOEXPORT
int
dwyco_chat_send_popup(const char *text, int len_text, int global)
{
    return chatq_send_popup(vc(VC_BSTRING, text, len_text), global);
}

DWYCOEXPORT
int
dwyco_chat_set_sys_attr(const char *name, int name_len, int dwyco_type, const char *val, int val_len, int int_val)
{
    vc v;
    switch(dwyco_type)
    {
    case DWYCO_TYPE_NIL:
        break;
    case DWYCO_TYPE_INT:
        v = int_val;
        break;
    case DWYCO_TYPE_STRING:
        v = vc(VC_BSTRING, val, val_len);
        break;
    default:
        oopanic("bad dwyco type");
    }
    return chatq_send_set_sys_attr(vc(VC_BSTRING, name, name_len), v);
}


static void
bounce_create_user_lobby(vc m, void *user_arg, vc cbi, ValidPtr )
{
    DwycoCommandCallback cb = (DwycoCommandCallback)(void *)cbi[0];
    vc dispname = cbi[1];
    if(m[1].is_nil())
    {
        if(cb)
            (*cb)("create_user_lobby", user_arg, 0, (const char *)m[2]);
        return;
    }
    if(cb)
        (*cb)("create_user_lobby", user_arg, 1, 0);
}

DWYCOEXPORT
void
dwyco_chat_create_user_lobby(const char *dispname,  const char *category, const char *sub_god_uid, int len_sub_god_uid, const char *pw, int user_limit, DwycoCommandCallback cb, void *user_arg)
{
    update_activity();
    vc v(VC_VECTOR);
    v.append((long)cb);
    v.append(dispname);
    dirth_send_create_user_lobby(My_UID, dispname, category, vc(VC_BSTRING, sub_god_uid, len_sub_god_uid), pw, user_limit, QckDone(bounce_create_user_lobby, user_arg, v));
}

static void
bounce_remove_user_lobby(vc m, void *user_arg, vc cbi, ValidPtr )
{
    DwycoCommandCallback cb = (DwycoCommandCallback)(void *)cbi[0];
    vc lobby_id = cbi[1];
    if(m[1].is_nil())
    {
        if(cb)
            (*cb)("remove_user_lobby", user_arg, 0, (const char *)m[2]);
        return;
    }
    if(cb)
        (*cb)("remove_user_lobby", user_arg, 1, 0);
}

DWYCOEXPORT
void
dwyco_chat_remove_user_lobby(const char *lobby_id, DwycoCommandCallback cb, void *user_arg)
{
    update_activity();
    vc v(VC_VECTOR);
    v.append((long)cb);
    v.append(lobby_id);
    dirth_send_remove_user_lobby(My_UID, lobby_id, QckDone(bounce_remove_user_lobby, user_arg, v));
}

DWYCOEXPORT
void
dwyco_chat_send_data(const char *txt, int txt_len, int pic_type, const char *pic_data, int pic_data_len)
{
    update_activity();
    vc chat = vc(VC_BSTRING, txt, txt_len);
    vc vpic_data = vc(VC_BSTRING, pic_data, pic_data_len);

    // just say snapchat is channel 2 for now
    chatq_send_chat(2, chat, pic_type, vpic_data);
}

DWYCOEXPORT
void
dwyco_chat_update_call_accept()
{
    chatq_send_update_call_accept();
}

#if 0
//DWYCOEXPORT
//int
//dwyco_get_ah(const char *uid, int len_uid, char *ah_out)
{
    vc u(VC_BSTRING, uid, len_uid);
    DwString a(display_asshole(u));
    ah_out[0] = a.at(0);
    ah_out[1] = a.at(1);
    ah_out[2] = 0;
    return 1;
}

//DWYCOEXPORT
//int
//dwyco_get_ah2(const char *uid, int len_uid)
{
    vc u(VC_BSTRING, uid, len_uid);

    vc ah1;
    double ah;
    ah1 = get_decayed_asshole(u);
    if(ah1.is_nil())
        return -1;
    ah = ah1;
    if(ah >= 10.0)
        ah = 9.999;
    ah = 9.999 - ah;
    ah *= 10.0;
    return (int)ah;
}
#endif

DWYCOEXPORT
void
dwyco_set_moron_dork_mode(int m)
{
    MMChannel::Moron_dork_mode = m;
}

DWYCOEXPORT
int
dwyco_get_moron_dork_mode()
{
    return MMChannel::Moron_dork_mode;
}


// chat related things
//
// this is called when a public chatbox is
// needed. This is called once when a public
// chat channel is generated, and none existed
// before (ie, if you destroy all the chat channels
// and then create a new one, this will get called
// again.) It should generate or associate whatever
// UI elements are needed to ACQUIRE keyboard input
// that will be sent to all users in a conference.
// The id that is returned is also used when chat
// from the network is received, and is to be displayed.
//

DWYCOEXPORT
void
dwyco_set_public_chat_init_callback(DwycoPublicChatInitCallback cb)
{
    public_chat_init_callback = cb;
}

// This is called on every time a private chat channel
// is needed. The id generated is also used for
// display of chat associated with the channel

DWYCOEXPORT
void
dwyco_set_private_chat_init_callback(DwycoPrivateChatInitCallback cb)
{
    private_chat_init_callback = cb;
}

//
// This is called for each command that is received
//
DWYCOEXPORT
void
dwyco_set_private_chat_display_callback(DwycoPrivateChatDisplayCallback cb)
{
    private_chat_display_callback = cb;
}

DWYCOEXPORT
void
dwyco_set_public_chat_display_callback(DwycoPublicChatDisplayCallback cb)
{
    public_chat_display_callback = cb;
}

extern KeyboardAcquire *TheMsgAq;
extern int Chatbox_id;

class DLLKeyAcquire : public KeyboardAcquire
{
public:
    vc q;
    DLLKeyAcquire() : q(VC_VECTOR) {}
    int has_data() {
        return q.num_elems() > 0;
    }
    char *get_data(int &len) {
        vc v = q[0];
        len = v.len();
        char *retval = new char[len + 1];
        memcpy(retval, (const char *)v, len);
        retval[len] = 0;
        q.remove(0);
        return retval;
    }
    vc get_structured_data() {
        vc v = q;
        q = vc(VC_VECTOR);
        GRTLOG("unloading keyboard", 0, 0);
        GRTLOGVC(v);
        return v;
    }
    void add_input(const char *line, int len) {
        vc v(VC_BSTRING, line, len);
        q.append(v);
    }
    void add_input(vc log_entry) {
        GRTLOG("keyboard command", 0, 0);
        GRTLOGVC(log_entry);
        q.append(log_entry);
    }
};

int
init_msgaq(int mbox, DwString& fail_reason)
{
    fail_reason = "unknown";
    if(TheMsgAq)
        return 1;
    DLLKeyAcquire *a = new DLLKeyAcquire;
    a->set_fail_reason("unknown");
    //a->msg_box = mbox;
    int id = ++UI_ids;
    if(public_chat_init_callback)
        Chatbox_id = (*public_chat_init_callback)(id);
    if(Chatbox_id == -1)
    {
        delete a;
        GRTLOG("cant initialize public chatbox acquisition object (do you have a public_chat_init_callback registered?)", 0, 0);
        return 0;
    }
    TheMsgAq = a;
    Chatbox_id = id;
    return 1;
}

KeyboardAcquire *
init_msgaq_private(int mbox, int& chatbox_id, const char *caption, int chan_id, DwString& fail_reason)
{
    fail_reason = "unknown";
    DLLKeyAcquire *a = new DLLKeyAcquire;
    a->set_fail_reason("unknown");
    //a->msg_box = mbox;
    int id = chan_id;
    if(private_chat_init_callback)
    {
        chatbox_id = (*private_chat_init_callback)(chan_id, caption);
        if(chatbox_id == -1)
        {
            fail_reason = "user defined private chat init callback returned -1";
            delete a;
            GRTLOG("user defined private_chat_init_callback returned -1", 0, 0);
            return 0;
        }
    }
    else
    {
        chatbox_id = -1;
        fail_reason = "no user defined private chat init callback";
        delete a;
        GRTLOG("no user defined private_chat_init_callback", 0, 0);
        return 0;
    }
    chatbox_id = id;
    return a;
}


//
// special char input stuff. since every
// framework has a different way of handling
// keyboard input, it is the callers responsibility
// to map the framework stuff into the following
// command set that the core can send over the network
// and reconstruct on the other side.
// NOTE: you have to test RECONSTRUCTION ON ALL DIFFERENT CLIENTS, not
// just a client that you wrote.
//
//  commands:
//	k char - insert char at current cursor location
//		note: \r, \n, \b may have to be handled specially on the receiver
//		since these a lot of times do whacky things. this also means
//		that deleting one of these chars may need special handling.
//	m loc - move the cursor to the given integer location (char position)
//	d - delete the character at the current location or the selection
//	s pos1 pos2 - select the chars starting at pos1 and going to and including pos2
//  c - clear the entire buffer and reposition to the beginning
//	p string - paste the string into the buffer at the current loc, replacing selected text
//	b - ring bell on other side
//	u arg1 arg1 str - user-defined
DWYCOEXPORT
void
dwyco_command_from_keyboard(int chan_id, int com, int arg1, int arg2, const char *str, int len)
{
    update_activity();
    // find chat q object that is associated with the id
    GRTLOG("keyboard command %d %c", chan_id, com);
    vc log(VC_VECTOR);
    //ChanList *cl = MMChannel::channels_by_gvid(ui_id);
    //if(cl->num_elems() != 1)
    //return;
    GRTLOG("keyboard command %d %c", chan_id, com);
    //MMChannel *m = (*cl)[0];
    MMChannel *m = MMChannel::channel_by_id(chan_id);
    if(!m)
    {
        //delete cl;
        return;
    }
    switch(com)
    {
    case 'k':
        log.append("k");
        log.append(arg1);
        break;
    case 'm':
        log.append("m");
        log.append(arg1);
        break;
    case 'd':
        log.append("d");
        break;
    case 's':
        log.append("s");
        log.append(arg1);
        log.append(arg2);
        break;
    case 'c':
        log.append("c");
        break;
    case 'p':
        log.append("p");
        log.append(vc(VC_BSTRING, str, len));
        break;
    case 'b':
        log.append("b");
        break;
    case 'u':
        log.append("u");
        log.append(arg1);
        log.append(arg2);
        log.append(vc(VC_BSTRING, str, len));
        break;
    default:
        return;
    }
    if(m->private_kaq)
        ((DLLKeyAcquire *)m->private_kaq)->add_input(log);
}
//
// line based chat is a lot simpler...
// just return the line when the user
// hits the enter key or whatever.
//
// note: id isn't used in this case since
// we only have one public chat box
DWYCOEXPORT
void
dwyco_line_from_keyboard(int id, const char *line, int len)
{
    update_activity();
    DLLKeyAcquire *a = dynamic_cast<DLLKeyAcquire *>(TheMsgAq);
    if(a)
        a->add_input(line, len);

}

class ChatDisplayBounce : public ChatDisplay
{
public:
    int output(vc log, int id);
    int output(const char *who, int len_who, const char *msg, int len_msg, vc from_uid, int = -1);
};

int
ChatDisplayBounce::output(vc log, int id)
{
    if(!private_chat_display_callback)
    {
        GRTLOG("no user defined private_chat_display_callback, cant display private chat", 0, 0);
        return 0;
    }

    for(int i = 0; i < log.num_elems(); ++i)
    {
        if(log[i][0].type() != VC_STRING)
            continue;
        const char *s = log[i][0];
        if(strcmp(s, "k") == 0)
        {
            (*private_chat_display_callback)(id, s, (int)log[i][1], 0, 0, 0);
        }
        else if(strcmp(s, "m") == 0)
        {
            (*private_chat_display_callback)(id, s, (int)log[i][1], 0 ,0, 0);
        }
        else if(strcmp(s, "s") == 0)
        {
            (*private_chat_display_callback)(id, s, (int)log[i][1], (int)log[i][2], 0, 0);
        }
        else if(strcmp(s, "c") == 0)
        {
            (*private_chat_display_callback)(id, s, 0, 0, 0, 0);
        }
        else if(strcmp(s, "p") == 0)
        {
            (*private_chat_display_callback)(id, s, 0, 0, (const char *)log[i][1], log[i][1].len());
        }
        else if(strcmp(s, "d") == 0)
        {
            (*private_chat_display_callback)(id, s, 0, 0, 0, 0);
        }
        else if(strcmp(s, "b") == 0)
        {
            (*private_chat_display_callback)(id, s, 0, 0, 0, 0);
        }
        else if(strcmp(s, "u") == 0)
        {
            (*private_chat_display_callback)(id, s, (int)log[i][1], (int)log[i][2], (const char *)log[i][3], log[i][3].len());
        }
    }
    return 1;
}

int
ChatDisplayBounce::output(const char *who, int len_who, const char *msg, int len_msg, vc from_uid, int)
{
    if(!public_chat_display_callback)
    {
        GRTLOG("no user defined public_chat_display_callback, cant display received public chat", 0, 0);
        return 0;
    }
    (*public_chat_display_callback)(who, len_who, msg, len_msg, (const char *)from_uid, from_uid.len());
    return 1;
}

ChatDisplay *
gen_bounce_chatbox_display(MMChannel *)
{
    return new ChatDisplayBounce;
}
ChatDisplay *
gen_bounce_private_chat_display(MMChannel *)
{
    return new ChatDisplayBounce;
}


DWYCOEXPORT
int
dwyco_selective_chat_recipient_enable(const char *uid, int len_uid, int enable)
{
    vc vuid(VC_BSTRING, uid, len_uid);
    return MMChannel::selective_chat_recipient_enable(vuid, enable);
}

//---------------------------------------------------------------------------

DWYCOEXPORT
int
dwyco_selective_chat_enable(int e)
{
    return MMChannel::selective_chat_enable(e);
}

DWYCOEXPORT
void
dwyco_reset_selective_chat_recipients()
{
    MMChannel::reset_selective_chat_recipients();
}

DWYCOEXPORT
int
dwyco_is_selective_chat_recipient(const char *uid, int len_uid)
{
    vc id(VC_BSTRING, uid, len_uid);
    return MMChannel::is_selective_chat_recipient(id);
}

//---------------------------------------------------------------------------


static void
bounce_destroy(MMChannel *mc, vc their_arg, void *their_func, ValidPtr)
{
    if(!their_func)
        return;
    (*(DwycoChannelDestroyCallback)their_func)(mc->myid, (void *)their_arg);
}


static void
bounce_mmcall_callback2(MMCall *ammc, int status, void *user_arg, ValidPtr)
{
    MMCallDLL *mmc = (MMCallDLL *)ammc;
    int dwyco_status = -1;
    static vc pwi("incorrect password");
    switch(status)
    {
    case MMCALL_STARTED:
        dwyco_status = DWYCO_CALLDISP_STARTED;
        break;
    case MMCALL_ESTABLISHED:
        dwyco_status = DWYCO_CALLDISP_ESTABLISHED;
        break;
    case MMCALL_FAILED:
        dwyco_status = DWYCO_CALLDISP_FAILED;
        break;
    case MMCALL_CANCELED:
        dwyco_status = DWYCO_CALLDISP_CANCELED;
        break;
    case MMCALL_TERMINATED:
        dwyco_status = DWYCO_CALLDISP_TERMINATED;
        break;
    case MMCALL_REJECTED:
        if(!ammc->reject_reason.is_nil())
        {
            if(ammc->reject_reason == pwi)
                dwyco_status = DWYCO_CALLDISP_REJECTED_PASSWORD_INCORRECT;
            else if(DwString((const char *)ammc->reject_reason, 0, ammc->reject_reason.len()).contains("busy"))
                dwyco_status = DWYCO_CALLDISP_REJECTED_BUSY;
            else
                dwyco_status = DWYCO_CALLDISP_REJECTED;
        }
        else
            dwyco_status = DWYCO_CALLDISP_REJECTED;
        break;
    default:
        oopanic("bad mmcall status");
    }
    GRTLOGA("bounce to app call disp call_id %d chan_id %d dwyco-status %d uid %s type %s",
            mmc->vp.cookie, mmc->chan_id, dwyco_status, (const char *)to_hex(mmc->uid), (const char *)mmc->call_type);
    if(mmc->cdc)
        (*mmc->cdc)(mmc->vp.cookie, mmc->chan_id, dwyco_status,
                    mmc->cdc_arg1, mmc->uid, mmc->uid.len(), mmc->call_type, mmc->call_type.len());
}

DWYCOEXPORT
int
dwyco_set_max_established_originated_calls(int n)
{
    int tmp = TheCallQ->max_established;
    TheCallQ->set_max_established(n);
    return tmp;
}

DWYCOEXPORT
int
dwyco_channel_create(const char *uid, int len_uid, DwycoCallDispositionCallback cdc, void *cdc_arg1, DwycoStatusCallback scb, void *scb_arg1, const char *pw, const char *call_type, int len_call_type, int q_call)
{

    // this is a hack... the call acceptance data was originally
    // designed to limit *incoming* calls. what we really want is
    // some other limit for the number of outgoing calls we can
    // originate, or something, i'm not sure. this will have to do for now.
    //TheCallQ->set_max_established(Max_simultaneous_originated_calls);

    vc host;
    vc duid;
    vc port;
    duid = vc(VC_BSTRING, uid, len_uid);

    int prim, sec, pal;
    int can_do_direct;
    unsigned long ip = uid_to_ip(duid, can_do_direct, prim, sec, pal);
    if(ip == 0)
    {
        //if we can't get the ip, bogus something up so that
        // it will go via server assist.
        host = "127.0.0.1";
        port = 1023;
    }
    else
    {
        port = prim;
        struct in_addr in;
        in.s_addr = ip;
        host = inet_ntoa(in);
    }
    MMCallDLL *mmc = new MMCallDLL(duid, host, port, vcnil, 0, 0,
                                   cdc, cdc_arg1,
                                   scb, scb_arg1,
                                   bounce_mmcall_callback2, 0, ValidPtr());
    if(call_type)
        mmc->call_type = vc(VC_BSTRING, call_type, len_call_type);
    if(pw)
        mmc->password = pw;
    if(!q_call)
    {
        if(!mmc->start_call(Media_select))
        {
            delete mmc;
            return 0;
        }
    }
    else
    {
        if(TheCallQ->add_call(mmc) == 0)
        {
            delete mmc;
            return 0;
        }
    }
    return 1;
}

DWYCOEXPORT
int
dwyco_channel_send_video(int chan_id, int vid_dev)
{
    MMChannel *mc = MMChannel::channel_by_id(chan_id);
    if(!mc)
        return 0;
    // check to see if we have a video device/source of some kind
    // enabled. also check to see if the remote user isn't blocking
    // video for some reason.
    // note: build_outgoing calls callbacks for video display init which
    // we probably need to modify in some way.
    return mc->build_outgoing(1, 1);
}

DWYCOEXPORT
int
dwyco_channel_stop_send_video(int chan_id)
{
    MMChannel *mc = MMChannel::channel_by_id(chan_id);
    if(!mc)
        return 0;
    mc->grab_coded_id = -1;
    // maybe check for no other senders and shutdown acq as well
    return 1;
}

DWYCOEXPORT
int
dwyco_channel_send_audio(int chan_id, int aud_dev)
{
    MMChannel *mc = MMChannel::channel_by_id(chan_id);
    if(!mc)
        return 0;
    // check to see if we have a video device/source of some kind
    // enabled. also check to see if the remote user isn't blocking
    // video for some reason.
    // note: build_outgoing calls callbacks for video display init which
    // we probably need to modify in some way.
    return mc->build_outgoing_audio(1);
}

DWYCOEXPORT
int
dwyco_channel_stop_send_audio(int chan_id)
{
    MMChannel *mc = MMChannel::channel_by_id(chan_id);
    if(!mc)
        return 0;
    mc->grab_audio_id = -1;
    // maybe check for no other senders and shutdown acq as well
    return 1;
}



DWYCOEXPORT
int
dwyco_connect_uid(const char *uid, int len_uid, DwycoCallDispositionCallback cdc, void *cdc_arg1, DwycoStatusCallback scb, void *scb_arg1, int send_video, int recv_video, int send_audio, int recv_audio, int private_chat, int public_chat, const char *pw, const char *call_type, int len_call_type, int q_call)
{

    update_activity();
    // this is a hack... the call acceptance data was originally
    // designed to limit *incoming* calls. what we really want is
    // some other limit for the number of outgoing calls we can
    // originate, or something, i'm not sure. this will have to do for now.
    //TheCallQ->set_max_established(Max_simultaneous_originated_calls);

    vc host;
    vc duid;
    vc port;
    duid = vc(VC_BSTRING, uid, len_uid);
    // this is probably not the best method, might be
    // better to q up a call that will just fail immediately with the
    // same messages as an actual call, less info leakage.
    //if(is_ignored_id(uid))
    //continue;

    int prim, sec, pal;
    int can_do_direct;
    unsigned long ip = uid_to_ip(duid, can_do_direct, prim, sec, pal);
    if(ip == 0)
    {
        //if we can't get the ip, bogus something up so that
        // it will go via server assist.
        host = "127.0.0.1";
        port = 1023;
    }
    else
    {
        port = prim;
        struct in_addr in;
        in.s_addr = ip;
        host = inet_ntoa(in);
    }
    MMCallDLL *mmc = new MMCallDLL(duid, host, port, vcnil, 0, 0,
                                   cdc, cdc_arg1,
                                   scb, scb_arg1,
                                   bounce_mmcall_callback2, 0, ValidPtr());
    if(call_type)
        mmc->call_type = vc(VC_BSTRING, call_type, len_call_type);
    mmc->send_video = send_video;
    mmc->recv_video = recv_video;
    mmc->send_audio = send_audio;
    mmc->recv_audio = recv_audio;
    mmc->priv_chat = private_chat;
    mmc->pub_chat = public_chat;
    if(pw)
        mmc->password = pw;
    if(!q_call)
    {
        if(!mmc->start_call(Media_select))
        {
            delete mmc;
            return 0;
        }
    }
    else
    {
        if(TheCallQ->add_call(mmc) == 0)
        {
            delete mmc;
            return 0;
        }
    }
    return 1;
}

DWYCOEXPORT
void
dwyco_connect_all4(const char **uid_list, int *uid_len_list, int num, DwycoCallDispositionCallback cdc, void *cdc_arg1, DwycoStatusCallback scb, void *scb_arg1, int send_video, int recv_video, int send_audio, int recv_audio, int private_chat, int public_chat, const char *pw, const char *call_type, int len_call_type, int q_calls)
{

    update_activity();
    // this is a hack... the call acceptance data was originally
    // designed to limit *incoming* calls. what we really want is
    // some other limit for the number of outgoing calls we can
    // originate, or something, i'm not sure. this will have to do for now.
    //TheCallQ->set_max_established(Max_simultaneous_originated_calls);

    for(int i = 0; i < num; ++i)
    {
        vc host;
        vc uid;
        vc port;
        if(uid_list[i] != 0)
        {
            uid = vc(VC_BSTRING, uid_list[i], uid_len_list[i]);
            // this is probably not the best method, might be
            // better to q up a call that will just fail immediately with the
            // same messages as an actual call, less info leakage.
            //if(is_ignored_id(uid))
            //continue;

            int prim, sec, pal;
            int can_do_direct;
            unsigned long ip = uid_to_ip(uid, can_do_direct, prim, sec, pal);
            if(ip == 0)
            {
                //if we can't get the ip, bogus something up so that
                // it will go via server assist.
                host = "127.0.0.1";
                port = 1023;
            }
            else
            {
                port = prim;
                struct in_addr in;
                in.s_addr = ip;
                host = inet_ntoa(in);
            }
        }
        else
        {
            oopanic("nil uid, bad idea");
        }
        MMCallDLL *mmc = new MMCallDLL(uid, host, port, vcnil, 0, 0,
                                       cdc, cdc_arg1,
                                       scb, scb_arg1,
                                       bounce_mmcall_callback2, 0, ValidPtr());
        if(call_type)
            mmc->call_type = vc(VC_BSTRING, call_type, len_call_type);
        mmc->send_video = send_video;
        mmc->recv_video = recv_video;
        mmc->send_audio = send_audio;
        mmc->recv_audio = recv_audio;
        mmc->priv_chat = private_chat;
        mmc->pub_chat = public_chat;
        if(pw)
            mmc->password = pw;
        if(!q_calls)
        {
            mmc->start_call(Media_select);
        }
        else
        {
            if(TheCallQ->add_call(mmc) == 0)
                delete mmc;
        }
    }

}

DWYCOEXPORT
int
dwyco_chan_to_call(int chan_id)
{
    MMCall *mmc = MMCall::channel_to_call(chan_id);
    if(!mmc)
        return -1;
    return mmc->vp.cookie;
}

DWYCOEXPORT
int
dwyco_channel_streams(int chan_id, int *send_video_out, int *recv_video_out, int *send_audio_out, int *recv_audio_out, int *pubchat_out, int *privchat_out)
{
    MMChannel *mc = MMChannel::channel_by_id(chan_id);
    if(!mc)
    {
        GRTLOG("channel_streams: cant find chan_id %d", chan_id, 0);
        return 0;
    }
    if(send_video_out)
        *send_video_out = (mc->grab_coded_id != -1);
    if(recv_video_out)
        *recv_video_out = 0;
    if(send_audio_out)
        *send_audio_out = 0;
    if(recv_audio_out)
        *recv_audio_out = 0;
    if(pubchat_out)
        *pubchat_out = 0;
    if(privchat_out)
        *privchat_out = 0;
    return 1;
}

DWYCOEXPORT
int
dwyco_connect_msg_chan(const char *uid, int len_uid, DwycoCallDispositionCallback cdc, void *cdc_arg1, DwycoStatusCallback scb, void *scb_arg1)
{
    vc host;
    vc duid;
    vc port;
    duid = vc(VC_BSTRING, uid, len_uid);
    if(MMChannel::already_connected(duid, 0, 1))
        return 1;
    int prim, sec, pal;
    int can_do_direct;
    unsigned long ip = uid_to_ip(duid, can_do_direct, prim, sec, pal);
    if(ip == 0)
    {
        //if we can't get the ip, bogus something up so that
        // it will go via server assist.
        host = "127.0.0.1";
        port = 1023;
    }
    else
    {
        port = prim;
        struct in_addr in;
        in.s_addr = ip;
        host = inet_ntoa(in);
    }
    MMCallDLL *mmc = new MMCallDLL(duid, host, port, vcnil, 0, 1,
                                   cdc, cdc_arg1,
                                   scb, scb_arg1,
                                   bounce_mmcall_callback2, 0, ValidPtr());
    if(!mmc->start_call(Media_select))
        return 0;
    return 1;
}

DWYCOEXPORT
int
dwyco_send_user_control(const char *uid, int len_uid, const char *data, int len_data)
{
    vc vuid(VC_BSTRING, uid, len_uid);
    MMChannel *mc = MMChannel::already_connected(vuid, 0, 1);
    if(!mc)
    {
        GRTLOG("send_user_control: cant map uid to connected channel. msg not sent", 0, 0);
        return 0;
    }
    vc msg(VC_VECTOR);
    msg[0] = "uc";
    msg[1] = vc(VC_BSTRING, data, len_data);
    mc->send_ctrl(msg);
    return 1;
}

static int
bounce_uc_callback(MMChannel *mc, vc v, void *)
{
    if(!dwyco_user_control_callback)
    {
        GRTLOG("received user control msg, but there is no user defined user_control_callback", 0, 0);
        return 0;
    }
    vc uid = mc->remote_uid();
    (*dwyco_user_control_callback)(mc->myid,
                                   (const char *)uid, uid.len(), (const char *)v, v.len());
    return 1;
}


DWYCOEXPORT
void
dwyco_set_call_appearance_callback(DwycoCallAppearanceCallback cb)
{
    call_appearance_callback = cb;
}

DWYCOEXPORT
void
dwyco_set_call_appearance_death_callback(DwycoCallAppearanceDeathCallback cb)
{
    call_appearance_death_callback = cb;
}

static void
kill_ac_bounce(MMChannel *mc, vc, void *p, ValidPtr)
{
    GRTLOG("ca death chan_id %d", mc->myid, 0);
    mc->call_appearance_death_callback = 0;
    if(call_appearance_death_callback)
        (*call_appearance_death_callback)(mc->myid);
}

void
call_appeared_bounce(MMChannel *mc, DwString note, int id)
{
    vc name;
    vc loc;
    vc uid;
    if(!mc->remote_cfg.is_nil())
    {
        if(!mc->remote_cfg.find("username", name))
            name = "?";
        if(!mc->remote_cfg.find("location", loc))
            loc = "limbo";
        uid = mc->remote_uid();
    }
    else
    {
        name = "?";
        loc = "limbo";
    }

    mc->call_appearance_death_callback = kill_ac_bounce;
    mc->cad_arg2 = 0;

    vc ct = mc->remote_call_type();
    if(ct.is_nil())
        ct = "";
    GRTLOGA("call appeared chan_id %d name %s, uid %s type %s", mc->myid, (const char *)name, (const char *)to_hex(uid), (const char *)ct, 0);
    if(call_appearance_callback)
        (*call_appearance_callback)(mc->myid,
                                    (const char *)name,
                                    (const char *)loc,
                                    (const char *)uid,
                                    uid.len(),
                                    (const char *)ct,
                                    ct.len());
}


static void
call_accepted_bounce(MMChannel *mc, vc a1, void *a2, ValidPtr)
{
    vc name;
    vc loc;
    vc uid;
    // note, a1 is the call_type
    if(!mc->remote_cfg.is_nil())
    {
        if(!mc->remote_cfg.find("username", name))
            name = "?";
        if(!mc->remote_cfg.find("location", loc))
            loc = "limbo";
        uid = mc->remote_uid();

    }
    else
    {
        name = "?";
        loc = "limbo";
    }
    if(call_accepted_callback)
    {
        GRTLOG("call_accepted_callback: id %d uid %s", mc->myid, (const char *)to_hex(uid));
        (*call_accepted_callback)(mc->myid,
                                  (const char *)name, (const char *)loc,
                                  uid, uid.len(), a1, a1.len());
    }
    else
    {
        GRTLOG("no call accept callback defined by user", 0, 0);
    }
}

DWYCOEXPORT
int
dwyco_call_accept(int id)
{
    update_activity();
    MMChannel *m = MMChannel::channel_by_id(id);
    if(!m)
    {
        GRTLOG("call_accept: cant find given id (%d). call not accepted.", id, 0);
        return 0;
    }
    m->user_accept = MMChannel::ACCEPT;
    m->accept_box = 0;
    m->call_appearance_death_callback = 0;
    return 1;
}

DWYCOEXPORT
int
dwyco_call_reject(int id, int session_ignore)
{
    update_activity();
    MMChannel *m = MMChannel::channel_by_id(id);
    if(!m)
    {
        GRTLOG("call_reject: cant find given id (%d). operation ignored.", id, 0);
        return 0;
    }
    m->user_accept = MMChannel::REJECT;
    m->accept_box = 0;
    m->call_appearance_death_callback = 0;
    if(session_ignore)
    {
        vc u;
        extern vc Session_ignore;
        if(!m->remote_cfg.is_nil() && m->remote_cfg.find("my uid", u))
        {
            Session_ignore.add(u);
        }
    }
    return 1;
}

// incoming zap message calls
DWYCOEXPORT
void
dwyco_set_zap_appearance_callback(DwycoZapAppearanceCallback cb)
{
    zap_appearance_callback = cb;
}

static void
kill_za_bounce(MMChannel *mc, vc, void *p, ValidPtr)
{
    mc->call_appearance_death_callback = 0;
    if(call_appearance_death_callback)
        (*call_appearance_death_callback)(mc->myid);
}

static int
zap_appeared_bounce(MMChannel *mc, vc name, vc filename, vc size)
{
    mc->call_appearance_death_callback = kill_za_bounce;
    mc->cad_arg2 = 0;

    DwString msg = (const char *)name;
    msg += " wants to send you a direct Audio/Video Message (size ";
    char sz[255];
    sprintf(sz, "%d", (int)size);
    msg += sz;
    msg += ")";
    vc uid = mc->remote_uid();
    if(zap_appearance_callback)
    {
        (*zap_appearance_callback)(mc->myid,
                                   (const char *)name, (int)size,
                                   (const char *)uid, uid.len());
    }
    else
    {
        GRTLOG("received direct zap_appearance, but there is no user defined zap_appearance_callback. either define a zap_appearance callback, or hardwire always_accept_zap to 1.", 0, 0);
    }
    return 0;
}

DWYCOEXPORT
int
dwyco_zap_accept(int id, int always_accept)
{
    MMChannel *m = MMChannel::channel_by_id(id);
    if(m)
    {
        m->user_accept = always_accept ? MMChannel::ZACCEPT_ALWAYS : MMChannel::ZACCEPT;
        m->accept_box = 0;
        m->call_appearance_death_callback = 0;
        return 1;
    }
    GRTLOG("zap_accept: cant find channel associated with chan_id (%d), zap not accepted.", id, 0);
    return 0;
}

DWYCOEXPORT
int
dwyco_zap_reject(int id, int session_ignore)
{
    MMChannel *m = MMChannel::channel_by_id(id);
    if(m)
    {
        m->user_accept = session_ignore ? MMChannel::ZREJECT_IGNORE : MMChannel::ZREJECT;
        m->accept_box = 0;
        m->call_appearance_death_callback = 0;
        return 1;
    }
    GRTLOG("zap_reject: cant find channel associated with chan_id (%d), zap not rejected.", id, 0);
    return 0;
}

static
int
bounce_call_screening(MMChannel *mc,
                      int recv_vid, int send_vid,
                      int recv_aud, int send_aud,
                      int pubchat, int privchat,
                      const char *call_type, int len_call_type,
                      const char *uid, int len_uid,
                      int *accept_call_style,
                      char **error_msg)
{
    if(!dwyco_call_screening_callback)
    {
        GRTLOG("no user defined call screening callback", 0, 0);
        return 1;
    }
    int ret;
    ret = (*dwyco_call_screening_callback)(mc->myid,
                                           recv_vid,  send_vid,
                                           recv_aud,  send_aud,
                                           pubchat,  privchat,
                                           call_type, len_call_type,
                                           uid, len_uid,
                                           accept_call_style,
                                           error_msg);
    GRTLOG("user defined call screening returns %d, accept_call = %d", ret, *accept_call_style);
    return ret;
}



//
// use the normal DWYCO_LIST stuff to access these
//

DWYCOEXPORT
int
dwyco_get_server_list(DWYCO_SERVER_LIST *list_out, int *numlines_out)
{
    vc& ret = *new vc(VC_VECTOR);
    for(int i = 0; i < Server_list.num_elems(); ++i)
    {
        ret[i] = Server_list[i];
    }
    *numlines_out = ret.num_elems();
    *list_out = (DWYCO_SERVER_LIST)&ret;
    return 1;
}


DWYCOEXPORT
int
dwyco_get_lobby_name_by_id2(const char *id, DWYCO_LIST *list_out)
{
    vc ulobby;
    if(Current_user_lobbies.is_nil() || !Current_user_lobbies.find(id, ulobby))
    {
        GRTLOG("get_lobby_name_by_id, cant find id \"%s\"", id, 0);
        return 0;
    }
    vc ret(VC_VECTOR);
    ret[0] = ulobby[SL_ULOBBY_DISPLAY_NAME];
    *list_out = dwyco_list_from_vc(ret);
    return 1;
}


DWYCOEXPORT
int
dwyco_switch_to_chat_server(int i)
{
    update_activity();
    if(!dirth_switch_to_chat_server(i, ""))
    {
        GRTLOG("switch to chat server %d failed", i, 0);
        return 0;
    }
    char a[500];
    sprintf(a, "%d", i);
    // see comment in switch_to_chat_server2
    Current_chat_server_id = a;
    hide_chat_grid();
    return 1;
}

static
int
check_server_pw(const char *pw, vc spw)
{
    vc salt = spw[0];
    vc hash = spw[1];
    if(salt.type() != VC_STRING || hash.type() != VC_STRING)
        return 0;

    CryptoPP::SHA1 shs;
    SecByteBlock b(shs.DigestSize());
    shs.Update((const byte *)pw, strlen(pw));
    shs.Update((const byte *)(const char *)salt, salt.len());
    shs.Final(b);
    vc v(VC_BSTRING, (const char *)b.data(), shs.DigestSize());
    if(v == hash)
        return 1;
    return 0;
}

DWYCOEXPORT
int
dwyco_check_chat_server_pw(const char *cid, const char *pw)
{
    vc ulobby;
    if(!Current_user_lobbies.find(cid, ulobby))
    {
        GRTLOG("check pw: cant find chat server \"%s\"", cid, 0);
        return 0;
    }
    vc spw = ulobby[SL_ULOBBY_PW];
    if(spw.is_nil())
        return 1;
    // subgods don't have to give a p/w to get into their own lobbies
    if(My_UID == ulobby[SL_ULOBBY_SUBGOD_UID])
        return 1;

    // anyone that claims god powers doesn't need a password, let
    // the servers be the final check on that.
    if(!KKG.is_nil())
        return 1;

    if(spw.type() == VC_VECTOR)
    {
        if(!check_server_pw(pw, spw))
            return -1;
        return 2;
    }
    GRTLOG("check pw: bogus password info format", 0, 0);
    return 0;
}

DWYCOEXPORT
int
dwyco_chat_server_has_pw(const char *cid)
{
    vc ulobby;
    if(!Current_user_lobbies.find(cid, ulobby))
    {
        GRTLOG("has pw: cant find chat server \"%s\"", cid, 0);
        return -1;
    }
    vc spw = ulobby[SL_ULOBBY_PW];
    if(spw.is_nil())
        return 0;
    return 1;
}

DWYCOEXPORT
int
dwyco_switch_to_chat_server2(const char *cid, const char *pw)
{
    update_activity();
    vc ulobby;
    if(!Current_user_lobbies.find(cid, ulobby))
    {
        GRTLOG("switch_to_chat_server2: cant find chat server \"%s\"", cid, 0);
        return 0;
    }
    if(dwyco_check_chat_server_pw(cid, pw) == -1)
        return -1;
    stop_chat_thread();

    vc ip = ulobby[SL_ULOBBY_IP];
    vc port = (int)ulobby[SL_ULOBBY_PORT];

    if(!start_chat_thread(ip, port, pw, cid))
    {
        GRTLOG("switch_to_chat_server2: cant start chat thread", 0, 0);
        return 0;
    }
    // even tho we haven't connected, we provisionally set the current
    // server to the requested server, mainly so ignore list
    // god checking is handled consistently
    Current_chat_server_id = cid;
    hide_chat_grid();
    return 1;
}

DWYCOEXPORT
int
dwyco_disconnect_chat_server()
{
    update_activity();
    stop_chat_thread();
    hide_chat_grid();
    return 1;
}
DWYCOEXPORT
void
dwyco_set_initial_invis(int invis)
{
    set_invisible(!!invis);
}

DWYCOEXPORT
void
dwyco_set_invisible_state(int invis)
{
    dwyco_disconnect_chat_server();
    set_invisible(invis);
    pal_reset();
    dirth_send_set_state(My_UID, dwyco_get_invisible_state() ? vctrue : vcnil, QckDone(0, 0));
}

DWYCOEXPORT
int
dwyco_get_invisible_state()
{
    //return ShowDirectoryData.get_invisible();
    return is_invisible();
    return 0;
}

#if 0
static void
enter_done(vc m, void *user_arg, vc cbi, ValidPtr )
{
    DwycoCommandCallback cb = (DwycoCommandCallback)(void *)cbi[0];
    vc room = cbi[1];
    if(m[1].is_nil())
    {
        if(cb)
            (*cb)("enter_room", user_arg, 0, (const char *)m[2]);
        return;
    }
    if(strcasecmp(room, "lobby") == 0)
    {
        exit_conf_mode();
        Current_room = "lobby";
    }
    else
    {
        if(Current_room != vc("lobby"))
            exit_conf_mode();
        enter_conf_mode();
        Current_room = room;
    }
    if(cb)
        (*cb)("enter_room", user_arg, 1, 0);
    dwyco_refresh_directory();
}

DWYCOEXPORT
void
dwyco_room_enter(const char *room, const char *pw, DwycoCommandCallback cb, void *user_arg)
{
    vc v(VC_VECTOR);
    v.append((long)cb);
    v.append(room);
    dirth_send_room_enter(My_UID, room, pw, QckDone(enter_done, user_arg, v));
}

static void
create_done(vc m, void *user_arg, vc cbi, ValidPtr )
{
    DwycoCommandCallback cb = (DwycoCommandCallback)(void *)cbi;
    if(m[1].is_nil())
    {
        if(cb)
            (*cb)("create_room", user_arg, 0, (const char *)m[2]);
        return;
    }
    if(cb)
        (*cb)("create_room", user_arg, 1, 0);
    dwyco_refresh_directory();
}


DWYCOEXPORT
void
dwyco_room_create(const char *name, const char *pw, DwycoCommandCallback cb, void *user_arg)
{
    vc vv((long)cb);
    dirth_send_room_create(My_UID, name,
                           (strlen(pw) == 0 ? vcnil : vc(pw)),  vcnil,
                           QckDone(create_done, user_arg, vv));
}

static void
delete_done(vc m, void *user_arg, vc cbi, ValidPtr )
{
    DwycoCommandCallback cb = (DwycoCommandCallback)(void *)cbi;
    if(m[1].is_nil())
    {
        if(cb)
            (*cb)("delete_room", user_arg, 0, (const char *)m[2]);
        return;
    }
    if(cb)
        (*cb)("delete_room", user_arg, 1, 0);
    dwyco_refresh_directory();
}

DWYCOEXPORT
void
dwyco_room_delete(const char *name, DwycoCommandCallback cb, void *user_arg)
{
    dirth_send_room_delete(My_UID, name, QckDone(delete_done, user_arg, vc((long)cb)));
}

#endif

#if 0
static void
pal_set_auth_state_done(vc m, void *user_arg, vc cbi, ValidPtr )
{
    DwycoCommandCallback cb = (DwycoCommandCallback)(void *)cbi[0];
    if(m[1].is_nil())
    {
        if(cb)
            (*cb)("set_pal_auth_state", user_arg, 0, (const char *)m[2]);
        return;
    }
    if(cb)
        (*cb)("set_pal_auth_state", user_arg, 1, 0);
    Pal_auth_state = cbi[1];
    pal_relogin();
}

DWYCOEXPORT
void
dwyco_set_pal_auth_state(int state, DwycoCommandCallback cb, void *user_arg)
{
    vc v(VC_VECTOR);
    v[0] = (long)cb;
    v[1] = state ? vc("auth") : vcnil;
    dirth_send_set_pal_auth_state(My_UID, state ? vc("auth") : vcnil, QckDone(pal_set_auth_state_done, user_arg, v));
}

static void
pal_get_auth_state_done(vc m, void *user_arg, vc cbi, ValidPtr )
{
    DwycoCommandCallback cb = (DwycoCommandCallback)(void *)cbi;
    if(m[1].is_nil())
    {
        if(cb)
            (*cb)("get_pal_auth_state", user_arg, 0, (const char *)m[2]);
        return;
    }
    if(cb)
        (*cb)("get_pal_auth_state", user_arg, m[3].is_nil() ? -1 : 1, 0);
}

DWYCOEXPORT
void
dwyco_get_pal_auth_state(const char *uid, int len_uid, DwycoCommandCallback cb, void *user_arg)
{
    dirth_send_get_pal_auth_state(My_UID, vc(VC_BSTRING, uid, len_uid), QckDone(pal_get_auth_state_done, user_arg, vc((long)cb)));
}

DWYCOEXPORT
int
dwyco_get_my_pal_auth_state()
{
    if(Pal_auth_state == vc("auth"))
        return 1;
    return 0;
}
#endif


DWYCOEXPORT
int
dwyco_delete_user(const char *uid, int len_uid)
{
    vc u(VC_BSTRING, uid, len_uid);

    Rescan_msgs = 1;
    vc dir = uid_to_dir(u);
    int ret = remove_user(dir, "");
    ack_all(u);
    pal_del(u, 1);
    prf_invalidate(u);
    Session_infos.del(u);
    return ret;
}

DWYCOEXPORT
int
dwyco_clear_user(const char *uid, int len_uid)
{
    vc u(VC_BSTRING, uid, len_uid);

    Rescan_msgs = 1;
    vc dir = uid_to_dir(u);
    int ret = clear_user(dir, "");
    ack_all(u);
    return ret;
}

DWYCOEXPORT
int
dwyco_clear_user_unfav(const char *uid, int len_uid)
{
    vc u(VC_BSTRING, uid, len_uid);

    if(!sql_fav_has_fav(u))
        return dwyco_clear_user(uid, len_uid);

    try {

    sql_start_transaction();
    vc delmid = get_unfav_msgids(u);

    int n = delmid.num_elems();
    for(int i = 0; i < n; ++i)
    {
        delete_body3(u, delmid[i], 0);
    }
    // bulk update the indexes
    remove_msg_idx_uid(u);
    // even if there are some files left in the filesystem
    // that is ok, since they will get reindexed next time the
    // index is loaded.
    sql_commit_transaction();
    }
    catch(...)
    {
        sql_rollback_transaction();
        Rescan_msgs = 1;
        return 0;
    }

    Rescan_msgs = 1;

    ack_all(u);
    return 1;
}

DWYCOEXPORT
void
dwyco_pal_relogin()
{
    pal_relogin();
}

DWYCOEXPORT
int
dwyco_get_pal_logged_in()
{
    return Pal_logged_in;
}

#if 0
DWYCOEXPORT
void
dwyco_always_visible(const char *uid, int len_uid, int val)
{
    vc u(VC_BSTRING, uid, len_uid);
    if(val)
        always_vis_add(u);
    else
        always_vis_del(u);
}

DWYCOEXPORT
void
dwyco_never_visible(const char *uid, int len_uid, int val)
{
    vc u(VC_BSTRING, uid, len_uid);
    if(val)
        never_vis_add(u);
    else
        never_vis_del(u);
}

DWYCOEXPORT
int
dwyco_is_always_visible(const char *uid, int len_uid)
{
    vc u(VC_BSTRING, uid, len_uid);
    return is_always_vis(u);
}

DWYCOEXPORT
int
dwyco_is_never_visible(const char *uid, int len_uid)
{
    vc u(VC_BSTRING, uid, len_uid);
    return is_never_vis(u);
}
#endif



DWYCOEXPORT
int
dwyco_empty_trash()
{
    return empty_trash();
}

DWYCOEXPORT
int
dwyco_count_trashed_users()
{
    return count_trashed_users();
}

DWYCOEXPORT
void
dwyco_untrash_users()
{
    untrash_users();
}

#ifdef __WIN32__
DWYCOEXPORT
int
dwyco_is_capturing_video()
{
#if defined(USE_VFW)
    if(!TheVFWMgr)
        return 0;
    return TheVFWMgr->is_hardware_capturing();
#endif
// NOTE: FIXME FOR VGCAP
    return 0;

}
#endif

static void
extra_info_done(vc m, void *t, vc vcb, ValidPtr)
{
    DwycoProfileCallback cb = (DwycoProfileCallback)(void *)vcb[0];
    if(!cb)
        return;
    // update our local compat in-core state

    if(m[1].is_nil())
    {
        (*cb)(0, m[2], 0, 0, 0, 0, 0, 0, 0, vcb[1], vcb[1].len(), 0, 0, t);
        return;
    }

    // hmm, this will fail every time since the chksum and other things
    // are added by the server. what really happens is the server will
    // follow up with an "invalidate" message for this profile which will
    // cause us to refetch.
#if 0
    vc prf = vcb[2];
    save_profile(vcb[1], prf);
#endif

    (*cb)(1, 0, 0, 0, 0, 0, 0, 0, 0, vcb[1], vcb[1].len(), 0, 0, t);
}


DWYCOEXPORT
int
dwyco_set_profile_from_composer(int compid, const char *txt, int txt_len, DwycoProfileCallback cb, void *arg)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("set_profile_from_composer: bad composer id (%d)", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    vc v(VC_VECTOR);
    v[0] = vc(VC_BSTRING, txt, txt_len);
    DwString tot;
    if(m->actual_filename.length() > 0)
    {
        FILE *f = fopen(m->actual_filename.c_str(), "rb");
        if(!f)
        {
            GRTLOG("set_profile_from_composer: cant open file \"%s\"", m->actual_filename.c_str(), 0);
            return 0;
        }
        while(!feof(f))
        {
            char buf[2048];
            int n;
            n = fread(buf, 1, sizeof(buf), f);
            if(n < sizeof(buf) && !feof(f))
            {
                GRTLOG("set_profile_from_composer: read error on file \"%s\"", m->actual_filename.c_str(), 0);
                fclose(f);
                return 0;
            }
            DwString a(buf, 0, n);
            tot += a;
        }
        if(tot.length() + v[0].len() > 65000)
        {
            GRTLOG("set_profile_from_composer: file \"%s\" too big (>65000)", m->actual_filename.c_str(), 0);
            fclose(f);
            return 0;
        }
        v[1] = vc(VC_BSTRING, tot.c_str(), tot.length());
        fclose(f);
    }
    // gen_profile_authenticator ignores all but the
    // text and the filehash passed in (hopefully the filehash
    // was computed in some way so as to avoid situations where
    // users could stop the program, sswitch in a new file, then
    // continue causing the program to generate an authenticator
    // for the bogus file.
    //v[2] = gen_profile_authenticator(v, m->filehash);
    vc vv(VC_VECTOR);
    vv[0] = vc((long)cb);
    vv[1] = My_UID;
    vv[2] = v;
    // compat hack, if this is a file zap, move it to another slot in the
    // profile command so old software doesn't get confused.
    if(dwyco_is_file_zap(compid))
    {
        v[2] = v[1];
        v[1] = vcnil;
    }
    dirth_send_set_info(My_UID, v, QckDone(extra_info_done, arg, vv));
    return 1;
}

static
void
extra_get_done_viewer(vc m, void *t, vc vcb, ValidPtr )
{
    DwycoProfileCallback cb = (DwycoProfileCallback)(void *)vcb[0];
    if(!cb)
    {
        GRTLOG("profile get callback: no user defined callback in place, profile processing will not happen properly. be sure to pass a proper callback to get_profile_view", 0, 0);
        return;
    }
    int dontsave = 0;
#if 0
    if(m[1].is_nil())
    {
        // if there is an error here, could be we don't have
        // access to the server. if we have a reasonable cached copy of any age,
        // we should go ahead and return that here, since we might
        // be doing this in a program that doesn't have access to the
        // servers.
        (*cb)(0, m[2], 0, 0, 0, 0, 0, 0, 0, vcb[1], vcb[1].len(), 0, 0, t);
        return;
    }
#endif
    if(m[1].is_nil() || (m[1].type() == VC_STRING && m[1] == vc("ok")))
    {
        // server says we have the latest copy of the
        // profile locally

        vc prf;
        if(!load_profile(vcb[1], prf))
        {
            if(m[1].is_nil())
                (*cb)(0, m[2], 0, 0, 0, 0, 0, 0, 0, vcb[1], vcb[1].len(), 0, 0, t);
            else
                (*cb)(0, "corrupted cache", 0, 0, 0, 0, 0, 0, 0, vcb[1], vcb[1].len(), 0, 0, t);
            return;
        }
        if(!m[1].is_nil())
            prf_set_cached(vcb[1]);
        dontsave = 1;
        m[1] = prf;

    }
    else if(m[1].type() != VC_VECTOR)
    {
        (*cb)(0, "corrupted msg", 0, 0, 0, 0, 0, 0, 0, vcb[1], vcb[1].len(), 0, 0, t);
        return;
    }

    vc ret = m[1];
    vc pack;
    vc s1 = "";
    vc s2 = "";
    vc s3 = "";

    if(deserialize(ret[PRF_PACK], pack))
    {
        s1 = pack[vc("handle")];
        s2 = pack[vc("desc")];
        s3 = pack[vc("loc")];
    }
    vc vid = ret[PRF_MEDIA];
    int regular = (int)ret[PRF_REGULAR];
    int reviewed = (int)ret[PRF_REVIEWED];
    vc img = ret[PRF_IMAGE];

#if 0
    int val;
    if((val = check_profile_authenticator(m[1], vcb[1])) == AUTH_PROFILE_FAILED)
    {
        (*cb)(0, "profile checksum failed", 0, 0, 0, 0, 0, 0, 0, vcb[1], vcb[1].len(), t);
        return;
    }
    if(val == AUTH_PROFILE_NO_INFO)
        dontsave = 1;
#endif
    int vid_empty = (vid.is_nil() || vid.len() == 0);
    int img_empty = (img.is_nil() || img.len() == 0);

    if(vid_empty && img_empty)
    {
        if(!dontsave)
            save_profile(vcb[1], m[1]);
        (*cb)(-1, 0, s1, s1.len(), s2, s2.len(), s3, s3.len(), 0, vcb[1], vcb[1].len(), reviewed, regular, t);
        prf_set_cached(vcb[1]);
        return;
    }

    vc str_to_dump = vid_empty ? img : vid;

    // use random filename instead of uid (in the past.)
    // don't think anything relied on uid, and it fails
    // in cases where multiple viewers are needed on the same
    // uid.
    DwString fn = gen_random_filename();
    fn += vid_empty ? ".fle" : ".dyc";
    FILE *f = fopen(newfn(fn).c_str(), "wb");
    if(!f)
    {
        (*cb)(-1, 0, s1, s1.len(), s2, s2.len(), s3, s3.len(), 0, vcb[1], vcb[1].len(), reviewed, regular, t);
        return;
    }
    if(fwrite((const char *)str_to_dump, 1, str_to_dump.len(), f) != str_to_dump.len())
    {
        fclose(f);
        (*cb)(-1, 0, s1, s1.len(), s2, s2.len(), s3, s3.len(), 0, vcb[1], vcb[1].len(), reviewed, regular, t);
        return;
    }
    fclose(f);
    if(!dontsave)
        save_profile(vcb[1], m[1]);
    prf_set_cached(vcb[1]);
    if(SlippyTube::is_dwyco_media(newfn(fn)))
    {
        // create a zap viewer and send that to the callback for them to play
        int viewid = dwyco_make_zap_view_file(fn.c_str());
        (*cb)(viewid, 0, s1, s1.len(), s2, s2.len(), s3, s3.len(), newfn(fn).c_str(), vcb[1], vcb[1].len(), reviewed, regular, t);

    }
    else
    {
        // profile might be some kind of other media like a pic
        // rename to .fle and let callback know
        (*cb)(-2, 0, s1, s1.len(), s2, s2.len(), s3, s3.len(), newfn(fn).c_str(), vcb[1], vcb[1].len(), reviewed, regular, t);
    }
}

// the interface for this call is a bit odd.
// the callback will eventually be called with the "succ"
// parameter either 0 (for failed), -1 (for success, but there is no
// attachment available), or -2 (for success, but attachment is a file
// that is not dwyco media, like a pic).
// otherwise (some number not 0 or -1, or -2) the number will be
// a viewer id, that can be used with the "zap_view" functions to play back
// the attachment for the profile. note that this will only work if you
// used the "set_profile_from_composer" function to create the profile (or it was
// created by cdc32)
DWYCOEXPORT
int
dwyco_get_profile_to_viewer(const char *uid, int len_uid, DwycoProfileCallback cb, void *arg)
{
    vc u(VC_BSTRING, uid, len_uid);
    vc vv(VC_VECTOR);
    vv[0] = vc((long)cb);
    vv[1] = u;
#if 1
    if(prf_already_cached(u))
    {
        vc resp(VC_VECTOR);
        vc v;
        v = "ok";
        resp[0] = v;
        dirth_q_local_action(resp, QckDone(extra_get_done_viewer, arg, vv));
    }
    else
    {
#endif
        vc prf;
        vc cache_check;
        if(load_profile(u, prf))
            cache_check = prf[PRF_CHKSUM]; // dwyco/cdcx profile
        dirth_send_get_info(My_UID, u, cache_check, QckDone(extra_get_done_viewer, arg, vv));
#if 1
    }
#endif
    return 1;
}

static
int
get_profile_media(vc uid, DwString& fn_out)
{
    vc prf;
    if(!load_profile(uid, prf))
    {
        return 0;
    }

    vc ret = prf;
#if 0
    vc pack;
    vc s1 = "";
    vc s2 = "";
    vc s3 = "";

    if(deserialize(ret[PRF_PACK], pack))
    {
        s1 = pack[vc("handle")];
        s2 = pack[vc("desc")];
        s3 = pack[vc("loc")];
    }
#endif
    vc vid = ret[PRF_MEDIA];
    //int regular = (int)ret[PRF_REGULAR];
    //int reviewed = (int)ret[PRF_REVIEWED];
    vc img = ret[PRF_IMAGE];

    int vid_empty = (vid.is_nil() || vid.len() == 0);
    int img_empty = (img.is_nil() || img.len() == 0);

    if(vid_empty && img_empty)
    {
        return -1;
    }

    vc str_to_dump = vid_empty ? img : vid;

    // use random filename instead of uid (in the past.)
    // don't think anything relied on uid, and it fails
    // in cases where multiple viewers are needed on the same
    // uid.
    DwString fn = gen_random_filename();
    fn += vid_empty ? ".fle" : ".dyc";
    FILE *f = fopen(newfn(fn).c_str(), "wb");
    if(!f)
    {
        return 0;
    }
    if(fwrite((const char *)str_to_dump, 1, str_to_dump.len(), f) != str_to_dump.len())
    {
        fclose(f);
        return 0;
    }
    fclose(f);

    if(SlippyTube::is_dwyco_media(newfn(fn)))
    {
        // create a zap viewer and send that to the callback for them to play
        int viewid = dwyco_make_zap_view_file(fn.c_str());
        return viewid;
    }
    else
    {
        // profile might be some kind of other media like a pic
        // rename to .fle and let callback know
        fn_out = newfn(fn);
        return -2;
    }

    return 0;
}

// NOTE: if this returns -2, you must call dwyco_free_array on the fn_out you get

DWYCOEXPORT
int
dwyco_get_profile_to_viewer_sync(const char *uid, int len_uid, char **fn_out, int *len_fn_out)
{
    vc u(VC_BSTRING, uid, len_uid);

    int viewid;
    DwString fn;
    if(fn_out)
        *fn_out = 0;

    viewid = get_profile_media(u, fn);
    // either it failed (we don't have it now) or it just doesn't have
    // any media, in either case, we can't provide a preview
    if(viewid == 0 || viewid == -1)
        return viewid;
    // if it is a pic, just return the filename, they will have to preview
    // in some client-specific way.
    //
    if(viewid == -2)
    {
        if(fn_out)
        {
            *fn_out = new char[fn.length() + 1];
            (*fn_out)[fn.length()] = 0;
            memcpy(*fn_out, fn.c_str(), fn.length());
            if(len_fn_out)
                *len_fn_out = fn.length() + 1;
        }
        return viewid;
    }
    return viewid;
}

int
internal_boot_file(const char *handle, int len_handle, const char *desc, int len_desc, const char *loc, int len_loc, const char *email, int len_email)
{
    vc prf(VC_VECTOR);
    vc pack(VC_TREE);

    pack.add_kv("handle", vc(VC_BSTRING, handle, len_handle));
    pack.add_kv("desc", vc(VC_BSTRING, desc, len_desc));
    pack.add_kv("loc", vc(VC_BSTRING, loc, len_loc));
    pack.add_kv("email", vc(VC_BSTRING, email, len_email));
    vc ser = serialize(pack);
    prf[PRF_PACK] = ser;
    prf[PRF_MEDIA] = vcnil;
    //prf[2] = gen_profile_authenticator(prf, vcnil);
    prf[PRF_REVIEWED] = 0;
    prf[PRF_REGULAR] = 0;
    int ret = 1;
    if(!save_info(prf, newfn("boot.dif").c_str()))
        ret = 0;
    return ret;
}

DWYCOEXPORT
int
dwyco_create_bootstrap_profile(const char *handle, int len_handle, const char *desc, int len_desc, const char *loc, int len_loc, const char *email, int len_email)
{
    int ret = 0;
    ret = internal_boot_file(handle, len_handle, desc, len_desc, loc, len_loc, email, len_email);
    UserConfigData.load();
    return ret;
}

DWYCOEXPORT
int
dwyco_make_profile_pack(const char *handle, int len_handle, const char *desc, int len_desc, const char *loc, int len_loc, const char *email, int len_email, const char **str_out, int *len_str_out)
{
    vc pack(VC_TREE);

    pack.add_kv("handle", vc(VC_BSTRING, handle, len_handle));
    pack.add_kv("desc", vc(VC_BSTRING, desc, len_desc));
    pack.add_kv("loc", vc(VC_BSTRING, loc, len_loc));
    pack.add_kv("email", vc(VC_BSTRING, email, len_email));
    //pack.add_kv("pubkey", dh_static_public());
    static vc ser;
    ser = serialize(pack);
    *str_out = (const char *)ser;
    *len_str_out = ser.len();
    return 1;
}


//
// Setup and config stuff
//

DWYCOEXPORT
int
dwyco_set_setting(const char *name, const char *value)
{
    DwString a(name);
    int i = a.find("/");
    if(i == DwString::npos)
    {
        GRTLOG("set_setting: setting name must contain a '/'. ignoring request", 0, 0);
        return 0;
    }
    DwString b(a.c_str(), 0, i);
    if(b.eq("user"))
    {
        GRTLOG("set_setting: user settings cant be set this way anymore, ignoring", 0, 0);
        return 0;
    }
    int ret = set_settings_value(name, value);
#if 0
    if(ret && b.eq("user"))
    {
        UserConfigData.set_sync(1);
        update_server_info();
    }
#endif
    GRTLOGA("set_setting: %s %s returns %d", name, value, ret, 0, 0);
    return ret;
}

DWYCOEXPORT
int
dwyco_get_setting(const char *name, const char **value_out, int *len_out, int *dwyco_type_out)
{
    vc v = get_settings_value(name);
    if(v.is_nil())
        return 0;
    *dwyco_type_out = dllify(v, *value_out, *len_out);
    GRTLOGA("get_setting: %s ret %s (%d) type %d", name, *value_out, *len_out, *dwyco_type_out, 0);
    return 1;
}

#undef DWUIDECLARG_END
#define DWUIDECLARG_END int dummy
#define DWUISET_BEGIN(oldstruct, data) oldstruct& a = data;
#define DWUISET_MEMBER(type, name) a.set_##name(name);
#define DWUISET_END if(!ReadOnlyMode) {a.save();} return 1;

#define DWUIGET_BEGIN(oldstruct, data) oldstruct& a = data;
#define DWUIGET_MEMBER(type, name) *name = a.get_##name();
#define DWUIGET_END return 1;

DWYCOEXPORT
int
dwyco_set_codec_data(int agc, int denoise, double audio_delay)
{
    Audio_agc = !!agc;
    Audio_denoise = !!denoise;
    Audio_delay = audio_delay;
    return 1;

}

DWYCOEXPORT
int
dwyco_get_codec_data(int *agc, int *denoise, double *audio_delay)
{
    *agc = Audio_agc;
    *denoise = Audio_denoise;
    *audio_delay = Audio_delay;
    return 1;
}

DWYCOEXPORT
int
dwyco_set_vidcap_data(
    DWUIDECLARG_BEGIN
    DWUIDECLARG(const char *, device)
    DWUIDECLARG(const char *, b_and)
    DWUIDECLARG(const char *, b_or)
    DWUIDECLARG(const char *, b_xor)
    DWUIDECLARG(const char *, offset)
    DWUIDECLARG(bool, blue)
    DWUIDECLARG(bool, green)
    DWUIDECLARG(bool, red)
    DWUIDECLARG(bool, rgb16)
    DWUIDECLARG(bool, rgb24)
    DWUIDECLARG(bool, use_one_plane)
    DWUIDECLARG(bool, yuv9)
    DWUIDECLARG(bool, upside_down)
    DWUIDECLARG(bool, palette)
    DWUIDECLARG(bool, automatic)
    DWUIDECLARG(bool, enable_color)
    DWUIDECLARG(bool, yuv12)
    DWUIDECLARG(bool, swap_uv)
    DWUIDECLARG_END
)
{
    DWUISET_BEGIN(VFWInvestigateXfer, VFWInvestigateData)
    DWUISET_MEMBER(const char *, device)
    DWUISET_MEMBER(const char *, b_and)
    DWUISET_MEMBER(const char *, b_or)
    DWUISET_MEMBER(const char *, b_xor)
    DWUISET_MEMBER(const char *, offset)
    DWUISET_MEMBER(bool, blue)
    DWUISET_MEMBER(bool, green)
    DWUISET_MEMBER(bool, red)
    DWUISET_MEMBER(bool, rgb16)
    DWUISET_MEMBER(bool, rgb24)
    DWUISET_MEMBER(bool, use_one_plane)
    DWUISET_MEMBER(bool, yuv9)
    DWUISET_MEMBER(bool, upside_down)
    DWUISET_MEMBER(bool, palette)
    DWUISET_MEMBER(bool, automatic)
    DWUISET_MEMBER(bool, enable_color)
    DWUISET_MEMBER(bool, yuv12)
    DWUISET_MEMBER(bool, swap_uv)
    DWUISET_END
}

DWYCOEXPORT
int
dwyco_get_vidcap_data(
    DWUIDECLARG_BEGIN
    DWUIDECLARG_OUT(const char *, device)
    DWUIDECLARG_OUT(const char *, b_and)
    DWUIDECLARG_OUT(const char *, b_or)
    DWUIDECLARG_OUT(const char *, b_xor)
    DWUIDECLARG_OUT(const char *, offset)
    DWUIDECLARG_OUT(bool, blue)
    DWUIDECLARG_OUT(bool, green)
    DWUIDECLARG_OUT(bool, red)
    DWUIDECLARG_OUT(bool, rgb16)
    DWUIDECLARG_OUT(bool, rgb24)
    DWUIDECLARG_OUT(bool, use_one_plane)
    DWUIDECLARG_OUT(bool, yuv9)
    DWUIDECLARG_OUT(bool, upside_down)
    DWUIDECLARG_OUT(bool, palette)
    DWUIDECLARG_OUT(bool, automatic)
    DWUIDECLARG_OUT(bool, enable_color)
    DWUIDECLARG_OUT(bool, yuv12)
    DWUIDECLARG_OUT(bool, swap_uv)
    DWUIDECLARG_END
)
{
    DWUIGET_BEGIN(VFWInvestigateXfer, VFWInvestigateData)
    DWUIGET_MEMBER(const char *, device)
    DWUIGET_MEMBER(const char *, b_and)
    DWUIGET_MEMBER(const char *, b_or)
    DWUIGET_MEMBER(const char *, b_xor)
    DWUIGET_MEMBER(const char *, offset)
    DWUIGET_MEMBER(bool, blue)
    DWUIGET_MEMBER(bool, green)
    DWUIGET_MEMBER(bool, red)
    DWUIGET_MEMBER(bool, rgb16)
    DWUIGET_MEMBER(bool, rgb24)
    DWUIGET_MEMBER(bool, use_one_plane)
    DWUIGET_MEMBER(bool, yuv9)
    DWUIGET_MEMBER(bool, upside_down)
    DWUIGET_MEMBER(bool, palette)
    DWUIGET_MEMBER(bool, automatic)
    DWUIGET_MEMBER(bool, enable_color)
    DWUIGET_MEMBER(bool, yuv12)
    DWUIGET_MEMBER(bool, swap_uv)
    DWUIGET_END
}


DWYCOEXPORT
int
dwyco_set_codec_tweaks(
)
{
    GRTLOG("set_codec_tweaks: not impl, ignored", 0, 0);
    return 0;
}

DWYCOEXPORT
int
dwyco_get_codec_tweaks(
)
{
    GRTLOG("get_codec_tweaks: not impl, ignored", 0, 0);
    return 0;
}

// useful for testing without a camera, otherwise
// not advisable to expose this functionality
DWYCOEXPORT
int
dwyco_set_raw_files(
    DWUIDECLARG_BEGIN
    DWUIDECLARG(const char *, raw_files_list)
    DWUIDECLARG(const char *, raw_files_pattern)
    DWUIDECLARG(bool, use_list_of_files)
    DWUIDECLARG(bool, use_pattern)
    DWUIDECLARG(bool, preload)
    DWUIDECLARG_END
)
{
    DWUISET_BEGIN(RawFilesXfer, RawFilesData)
    DWUISET_MEMBER(const char *, raw_files_list)
    DWUISET_MEMBER(const char *, raw_files_pattern)
    DWUISET_MEMBER(bool, use_list_of_files)
    DWUISET_MEMBER(bool, use_pattern)
    DWUISET_MEMBER(bool, preload)
    DWUISET_END
}

DWYCOEXPORT
int
dwyco_get_raw_files(
    DWUIDECLARG_BEGIN
    DWUIDECLARG_OUT(const char *, raw_files_list)
    DWUIDECLARG_OUT(const char *, raw_files_pattern)
    DWUIDECLARG_OUT(bool, use_list_of_files)
    DWUIDECLARG_OUT(bool, use_pattern)
    DWUIDECLARG_OUT(bool, preload)
    DWUIDECLARG_END
)
{
    DWUIGET_BEGIN(RawFilesXfer, RawFilesData)
    DWUIGET_MEMBER(const char *, raw_files_list)
    DWUIGET_MEMBER(const char *, raw_files_pattern)
    DWUIGET_MEMBER(bool, use_list_of_files)
    DWUIGET_MEMBER(bool, use_pattern)
    DWUIGET_MEMBER(bool, preload)
    DWUIGET_END
}

// end useful for testing

DWYCOEXPORT
int
dwyco_set_rate_tweaks(
    DWUIDECLARG_BEGIN
    DWUIDECLARG(double, max_frame_rate)
    DWUIDECLARG(long, max_udp_bytes)
    DWUIDECLARG(long, link_speed)
    DWUIDECLARG(long, link_speed_recv)
    DWUIDECLARG_END
)
{
    DWUISET_BEGIN(RateTweakerXferValid, RTUserDefaults)
    DWUISET_MEMBER(double, max_frame_rate)
    DWUISET_MEMBER(long, max_udp_bytes)
    DWUISET_MEMBER(long, link_speed)
    DWUISET_MEMBER(long, link_speed_recv)
    DWUISET_END
}

DWYCOEXPORT
int
dwyco_get_rate_tweaks(
    DWUIDECLARG_BEGIN
    DWUIDECLARG_OUT(double, max_frame_rate)
    DWUIDECLARG_OUT(long, max_udp_bytes)
    DWUIDECLARG_OUT(long, link_speed)
    DWUIDECLARG_OUT(long, link_speed_recv)
    DWUIDECLARG_END
)
{
    DWUIGET_BEGIN(RateTweakerXferValid, RTUserDefaults)
    DWUIGET_MEMBER(double, max_frame_rate)
    DWUIGET_MEMBER(long, max_udp_bytes)
    DWUIGET_MEMBER(long, link_speed)
    DWUIGET_MEMBER(long, link_speed_recv)
    DWUIGET_END
}

DWYCOEXPORT
int
dwyco_set_video_input(
    DWUIDECLARG_BEGIN
    DWUIDECLARG(const char *, device_name)
    DWUIDECLARG(bool, coded)
    DWUIDECLARG(bool, raw)
    DWUIDECLARG(bool, vfw)
    DWUIDECLARG(bool, no_video)
    DWUIDECLARG(int, device_index)
    DWUIDECLARG_END
)
{
    DWUISET_BEGIN(VidInputXfer, VidInputData)
    DWUISET_MEMBER(const char *, device_name)
    DWUISET_MEMBER(bool, coded)
    DWUISET_MEMBER(bool, raw)
    DWUISET_MEMBER(bool, vfw)
    DWUISET_MEMBER(bool, no_video)
    DWUISET_MEMBER(int, device_index)

    // because no-video affects the call accept vector
    // stupid, but that's a compat thing
    chatq_send_update_call_accept();
    DWUISET_END
}

DWYCOEXPORT
int
dwyco_get_video_input(
    DWUIDECLARG_BEGIN
    DWUIDECLARG_OUT(const char *, device_name)
    DWUIDECLARG_OUT(bool, coded)
    DWUIDECLARG_OUT(bool, raw)
    DWUIDECLARG_OUT(bool, vfw)
    DWUIDECLARG_OUT(bool, no_video)
    DWUIDECLARG_OUT(int, device_index)
    DWUIDECLARG_END
)
{
    DWUIGET_BEGIN(VidInputXfer, VidInputData)
    DWUIGET_MEMBER(const char *, device_name)
    DWUIGET_MEMBER(bool, coded)
    DWUIGET_MEMBER(bool, raw)
    DWUIGET_MEMBER(bool, vfw)
    DWUIGET_MEMBER(bool, no_video)
    DWUIGET_MEMBER(int, device_index)
    DWUIGET_END
}

DWYCOEXPORT
int
dwyco_set_call_accept(
    DWUIDECLARG_BEGIN
    DWUIDECLARG(int , max_audio)
    DWUIDECLARG(int , max_chat)
    DWUIDECLARG(int , max_video)
    DWUIDECLARG(int , max_audio_recv)
    DWUIDECLARG(int , max_video_recv)
    DWUIDECLARG(int , max_pchat)
    DWUIDECLARG(const char * , pw)
    DWUIDECLARG(bool, auto_accept)
    DWUIDECLARG(bool, require_pw)
    DWUIDECLARG_END
)
{
    DWUISET_BEGIN(CallAcceptanceXfer, CallAcceptanceData)
    DWUISET_MEMBER(int , max_audio)
    DWUISET_MEMBER(int , max_chat)
    DWUISET_MEMBER(int , max_video)
    DWUISET_MEMBER(int , max_audio_recv)
    DWUISET_MEMBER(int , max_video_recv)
    DWUISET_MEMBER(int , max_pchat)
    DWUISET_MEMBER(const char * , pw)
    DWUISET_MEMBER(bool, auto_accept)
    DWUISET_MEMBER(bool, require_pw)
    chatq_send_update_call_accept();
    DWUISET_END
}

DWYCOEXPORT
int
dwyco_get_call_accept(
    DWUIDECLARG_BEGIN
    DWUIDECLARG_OUT(int , max_audio)
    DWUIDECLARG_OUT(int , max_chat)
    DWUIDECLARG_OUT(int , max_video)
    DWUIDECLARG_OUT(int , max_audio_recv)
    DWUIDECLARG_OUT(int , max_video_recv)
    DWUIDECLARG_OUT(int , max_pchat)
    DWUIDECLARG_OUT(const char * , pw)
    DWUIDECLARG_OUT(bool, auto_accept)
    DWUIDECLARG_OUT(bool, require_pw)
    DWUIDECLARG_END
)
{
    DWUIGET_BEGIN(CallAcceptanceXfer, CallAcceptanceData)
    DWUIGET_MEMBER(int , max_audio)
    DWUIGET_MEMBER(int , max_chat)
    DWUIGET_MEMBER(int , max_video)
    DWUIGET_MEMBER(int , max_audio_recv)
    DWUIGET_MEMBER(int , max_video_recv)
    DWUIGET_MEMBER(int , max_pchat)
    DWUIGET_MEMBER(const char * , pw)
    DWUIGET_MEMBER(bool, auto_accept)
    DWUIGET_MEMBER(bool, require_pw)
    DWUIGET_END
}

DWYCOEXPORT
int
dwyco_set_zap_data(
    DWUIDECLARG_BEGIN
    DWUIDECLARG(bool, always_server)
    DWUIDECLARG(bool, always_accept)
    DWUIDECLARG(bool, use_old_timing)
    DWUIDECLARG(bool, save_sent)
    DWUIDECLARG(bool, no_forward_default)
    DWUIDECLARG_END
)
{
    DWUISET_BEGIN(ZapAdvXfer, ZapAdvData)
    DWUISET_MEMBER(bool, always_server)
    DWUISET_MEMBER(bool, always_accept)
    DWUISET_MEMBER(bool, save_sent)
    DWUISET_MEMBER(bool, use_old_timing)
    DWUISET_MEMBER(bool, no_forward_default)
    DWUISET_END
}

DWYCOEXPORT
int
dwyco_get_zap_data(
    DWUIDECLARG_BEGIN
    DWUIDECLARG_OUT(bool, always_server)
    DWUIDECLARG_OUT(bool, always_accept)
    DWUIDECLARG_OUT(bool, ignore)
    DWUIDECLARG_OUT(bool, use_old_timing)
    DWUIDECLARG_OUT(bool, save_sent)
    DWUIDECLARG_OUT(bool, no_forward_default)
    DWUIDECLARG_END
)
{
    DWUIGET_BEGIN(ZapAdvXfer, ZapAdvData)
    DWUIGET_MEMBER(bool, always_server)
    DWUIGET_MEMBER(bool, always_accept)
    DWUIGET_MEMBER(bool, ignore)
    DWUIGET_MEMBER(bool, use_old_timing)
    DWUIGET_MEMBER(bool, save_sent)
    DWUIGET_MEMBER(bool, no_forward_default)
    DWUIGET_END
}


DWYCOEXPORT
int
dwyco_set_net_data(
    DWUIDECLARG_BEGIN
    DWUIDECLARG(int, primary_port) 				// primary listener, icuii: 2000
    DWUIDECLARG(int, secondary_port) 			// secondary listenter icuii: 9745
    DWUIDECLARG(int, pal_port)		 			// pal listener icuii: 6782
    DWUIDECLARG(int, nat_primary_port)			// icuii: 0
    DWUIDECLARG(int, nat_secondary_port)		// icuii: 0
    DWUIDECLARG(int, nat_pal_port)				// icuii: 0
    DWUIDECLARG(bool, advertise_nat_ports)		// icuii: 0
    DWUIDECLARG(int, disable_upnp)		// icuii: 0
    DWUIDECLARG(int, call_setup_media_select)
    DWUIDECLARG(int, listen)
    DWUIDECLARG_END
)
{
    DWUISET_BEGIN(DwNetConfig, DwNetConfigData)
    DWUISET_MEMBER(int, primary_port)
    DWUISET_MEMBER(int, secondary_port)
    DWUISET_MEMBER(int, pal_port)		 			// pal listener icuii: 6782
    DWUISET_MEMBER(int, nat_primary_port)			// icuii: 0
    DWUISET_MEMBER(int, nat_secondary_port)		// icuii: 0
    DWUISET_MEMBER(int, nat_pal_port)				// icuii: 0
    DWUISET_MEMBER(bool, advertise_nat_ports)		// icuii: 0
    DWUISET_MEMBER(int, disable_upnp)		// icuii: 0
    DWUISET_MEMBER(int, call_setup_media_select)		// icuii: tcp
    DWUISET_MEMBER(int, listen)
    if(is_listening())
    {
        set_listen_state(0);
    }
    set_listen_state(listen);
    pal_reset();

    extern int Media_select;
//note: we depend on the values being sent in here being the same
// as the ones in aconn.h
    switch(call_setup_media_select)
    {
    default:
    case CSMS_VIA_HANDSHAKE:
        Media_select = MEDIA_VIA_HANDSHAKE;
        break;
    case CSMS_TCP_ONLY:
        Media_select = MEDIA_TCP_VIA_PROXY;
        break;
    case CSMS_UDP_ONLY:
        Media_select = MEDIA_UDP_VIA_STUN;
        break;

    }
    DWUISET_END
}

DWYCOEXPORT
int
dwyco_get_net_data(
    DWUIDECLARG_BEGIN
    DWUIDECLARG_OUT(int, primary_port)
    DWUIDECLARG_OUT(int, secondary_port)
    DWUIDECLARG_OUT(int, pal_port)
    DWUIDECLARG_OUT(int, nat_primary_port)
    DWUIDECLARG_OUT(int, nat_secondary_port)
    DWUIDECLARG_OUT(int, nat_pal_port)
    DWUIDECLARG_OUT(bool, advertise_nat_ports)
    DWUIDECLARG_OUT(int, disable_upnp)
    DWUIDECLARG_OUT(int, call_setup_media_select)
    DWUIDECLARG_OUT(int, listen)
    DWUIDECLARG_END
)
{
    DWUIGET_BEGIN(DwNetConfig, DwNetConfigData)
    DWUIGET_MEMBER(int, primary_port)
    DWUIGET_MEMBER(int, secondary_port)
    DWUIGET_MEMBER(int, pal_port)
    DWUIGET_MEMBER(int, nat_primary_port)
    DWUIGET_MEMBER(int, nat_secondary_port)
    DWUIGET_MEMBER(int, nat_pal_port)
    DWUIGET_MEMBER(bool, advertise_nat_ports)
    DWUIGET_MEMBER(int, disable_upnp)
    DWUIGET_MEMBER(int, call_setup_media_select)
    DWUIGET_MEMBER(int, listen)
    DWUIGET_END
}


// Message composition
//

static int
import_file(DwString& name, DwString& out_fn, const char *suf = ".fle")
{
    vc fn = to_hex(gen_id());
    DwString s((const char *)fn);
    s += suf;
    vc p(VC_VECTOR);
    if(!CopyFile(name.c_str(), newfn(s).c_str(), 0))
    {
        GRTLOG("import file failed: %s to %s", name.c_str(), newfn(s).c_str());

        return 0;
    }
    out_fn = s;
    return 1;
}

DWYCOEXPORT
int
dwyco_make_zap_composition( char *dum)
{
    TMsgCompose *m = new TMsgCompose;

    m->composer = 1;
    m->FormShow();
    GRTLOG("make_zap_composition: ret %d", (int)m->vp, 0);
    return m->vp;
}

DWYCOEXPORT
int
dwyco_make_zap_composition_raw(const char *filename, const char *possible_extension)
{
    // XXX REMEMBER may need to import the file so keep the
    // file name/attachment uniqueness stuff intact
    DwString a(filename);

    if(access(a.c_str(), 04) == -1)
    {
        GRTLOG("make_zap_raw: cant access %s", a.c_str(), 0);
        return 0;
    }

    // hack, assume we are using dyc/fle things
    const char *suf;
    int si = a.rfind(".dyc");
    if(si == -1)
    {
        si = a.rfind(".fle");
        if(si == -1 || si != a.length() - 4)
            return 0;
        suf = ".fle";
    }
    else if(si != a.length() - 4)
        return 0;
    else
        suf = ".dyc";


    DwString out_fn;
    if(!import_file(a, out_fn, suf))
    {
        GRTLOG("make_zap_raw: cant import %s", a.c_str(), 0);
        return 0;
    }

    TMsgCompose *m = new TMsgCompose;

    m->FormShow();
    m->composer = 1;
    m->play_button_enabled = 1;
    m->stop_button_enabled = 0;
    m->actual_filename = newfn(out_fn);
    m->file_basename = out_fn.c_str();
    m->filehash = gen_hash(m->actual_filename);
    m->inhibit_hashing = 1;
    if(m->file_basename.rfind(".fle") == m->file_basename.length() - 4)
    {
        DwString base = (const char *)to_hex(gen_id());
        if(possible_extension)
        {
            base += possible_extension;
        }
        m->user_filename = base.c_str();
    }
    return m->vp;
}

// this is used when doing multi-sends, you need to
// duplicate the composition's attachments and stuff for
// each send operation. what you can do and when is very
// strict:
// this is only used before send time on a fresh composition.
// you must not call record/play, etc. on the new composition, just "send".
// part of the reason for all this is that the checksum
// gets computed at send time.
// you can't dup a forward or file composition, mainly because you
// don't really need to (forwarding you are already "dup-ing" a known
// message), and with files, you just give the filename to the make_file_comp
// function and it creates a new one, so you don't really need to dup those.
DWYCOEXPORT
int
dwyco_dup_zap_composition(int compid)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("dup_zap_composition: bad compid %d", compid, 0);
        return 0;
    }
    TMsgCompose *old_m = (TMsgCompose *)(void *)p;
    if(old_m->forward || !old_m->user_filename.is_nil())
    {
        GRTLOG("dup_zap_composition: panic: cant dup forward or file comps (%d)", compid, 0);
        oopanic("can't dup forward or file compositions");
        return 0;
    }

    TMsgCompose *m = new TMsgCompose(*old_m);
    // now patch up the new thing a little bit
    //m->vp = ValidPtr(m);
    if(m->actual_filename.length() > 0)
    {
        // create a new attachment name, and copy the file
        DwString new_aname((const char *)to_hex(gen_id()));
        new_aname += ".dyc";
        DwString actual_new_aname = newfn(new_aname);
        if(!CopyFile(old_m->actual_filename.c_str(), actual_new_aname.c_str(), 0))
        {
            delete m;
            GRTLOG("dup_zap_composition: cant copy %s to %s", old_m->actual_filename.c_str(), actual_new_aname.c_str());
            return 0;
        }
        m->actual_filename = actual_new_aname;
        m->file_basename = new_aname;
    }


    GRTLOG("dup_zap_composition: ret %d", (int)m->vp, 0);
    return m->vp;

}

// if uid == 0, we try to infer the uid from the mid.
// otherwise, the msg_id is assumed to be filed in the
// uid.usr folder.
DWYCOEXPORT
int
dwyco_make_forward_zap_composition( const char *uid, int len_uid, const char *msg_id, int strip_forward_text)
{
    vc body;
    vc text;
    vc attachment;
    vc from;

    vc u;
    if(uid == 0)
    {
        vc id(VC_BSTRING, msg_id, strlen(msg_id));
        vc summary = find_cur_msg(id);
        if(!summary.is_nil())
        {
            GRTLOG("make_forward_zap: cant forward unfetched server message %s", msg_id, 0);
            return 0;
        }

        body = direct_to_body(id, u);
        if(body.is_nil())
        {
            GRTLOG("make_forward_zap: cant find id %s", msg_id, 0);
            return 0;
        }
    }
    else
    {
        u = vc(VC_BSTRING, uid, len_uid);
        body = load_body_by_id(u, msg_id);
        if(body.is_nil())
        {
            GRTLOG("make_forward_zap: cant load %s (uid: %s)", msg_id, (const char *)to_hex(u));
            return 0;
        }
    }

    from = body[QM_BODY_FROM];
    text = body[QM_BODY_NEW_TEXT];
    attachment = body[QM_BODY_ATTACHMENT];

    if(!body[QM_BODY_FORWARDED_BODY].is_nil())
    {
        DwString s;
        append_forwarded_text(s, body);
        text = s.c_str();
    }

    DwString s2;
    if(body[QM_BODY_SENT].is_nil())
        s2 = (const char *)to_hex(from);
    else
        s2 = (const char *)to_hex(u);

    DwString na((const char *)to_hex(gen_id()));

    s2 += ".usr" DIRSEPSTR;
    DwString att_dir = s2;
    if(!attachment.is_nil())
    {
        // now copy any attachment and set that up.
        if(body[QM_BODY_FILE_ATTACHMENT].is_nil())
            na += ".dyc";
        else
            na += ".fle";
        s2 += (const char *)attachment;
        if(!CopyFile(newfn(s2).c_str(), newfn(na).c_str(), 0))
        {
            GRTLOG("make_zap_forward: cant copy %s to %s", newfn(s2).c_str(), newfn(na).c_str());
            GRTLOG("make_zap_forward: deleting %s", newfn(na).c_str(), 0);
            DeleteFile(newfn(na).c_str());
            return 0;
        }
    }

    // determine if we can play the msg associated with
    // the forwarded msgs. if not, disallow the forward.

    if(any_no_forward(body) && verify_chain(body, 1, vcnil, att_dir.c_str()) != VERF_AUTH_OK)
    {
        GRTLOG("make_forward_zap: failed checksum or no forward flag speced (%s, saved msg)", msg_id, 0);
        return 0;
    }


    TMsgCompose *m = new TMsgCompose;
    //
    // make the body attachment the new one we copied above, so
    // forward checking will work right
    // this is no problem, because when the message is sent, it
    // is reconstructed from a bunch of stuff as if it were
    // being created anew, not from this body.
    if(!attachment.is_nil())
        body[QM_BODY_ATTACHMENT] = na.c_str();
    // note: this allows us to forward messages we created even if we
    // specified no-forward during the creation. this is a bit of a
    // problem if someone gets your UID and can masquerade as you, because
    // they could then forward all your no-forward messages. but that is
    // a stretch, and people want to be able to make messages that
    // they can send but the recipient will not be able to re-send.
    if(!can_forward(body, ".") && from != My_UID)
        m->limited_forward = 1;

    if(strip_forward_text)
    {
        vc nb;
        nb = strip_chain(body);
        DwString s;
        append_forwarded_text(s, nb);
        text = s.c_str();
        body = nb;
    }

    m->forward = 1;
    m->body_to_forward = body;
    if(!attachment.is_nil())
    {
        m->file_basename = na;
        m->actual_filename = newfn(na);
        // note: recomputing the hash here. this will work
        // because even if they switch the file at this point, that
        // will still cause the checksum to fail because
        // it won't match the bogus file.
        m->filehash = gen_hash(na);
        m->user_filename = body[QM_BODY_FILE_ATTACHMENT];
    }
    m->msg_text = (const char *)text;
    m->composer = 1;
    m->FormShow();
    GRTLOG("make_forward_zap: ret %d", (int)m->vp, 0);
    return m->vp;
}

DWYCOEXPORT
int
dwyco_is_forward_composition(int compid)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("is_forward_composition: bad compid %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    return m->forward;
}

DWYCOEXPORT
int
dwyco_flim(int compid)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("flim: bad compid %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    return m->limited_forward;
}

DWYCOEXPORT
int
dwyco_is_file_zap(int compid)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("is_file_zap: bad compid %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    return !m->user_filename.is_nil();
}

DWYCOEXPORT
int
dwyco_make_special_zap_composition( int special_type, const char *user_id, const char *user_block, int len_user_block)
{
    TMsgCompose *m = new TMsgCompose;
    GRTLOG("WARNING: special zaps are mostly deprecated, tho if there is a good reason, they can be resurrected", 0, 0);

    m->composer = 1;
    switch(special_type)
    {
    case DWYCO_PAL_AUTH_ASK:
        m->pal_auth_mode = 1;
        //m->force_server = 1;
        break;
    case DWYCO_PAL_AUTH_REJECT:
        m->pal_auth_rej_mode = 1;
        //m->force_server = 1;
        break;
    case DWYCO_PAL_AUTH_ACCEPT:
        m->pal_auth_ok_mode = 1;
        //m->force_server = 1;
        break;
    case DWYCO_SPECIAL_TYPE_USER:
    case DWYCO_SPECIAL_TYPE_JOIN1:
    case DWYCO_SPECIAL_TYPE_JOIN2:
    case DWYCO_SPECIAL_TYPE_JOIN3:
    case DWYCO_SPECIAL_TYPE_JOIN4:
        m->special_type = special_type;
        if(user_block)
        {
            m->special_payload = vc(VC_BSTRING, user_block, len_user_block);
        }
        break;
    default:
        delete m;
        return -1;
    }
    m->FormShow();
    return m->vp;
}

DWYCOEXPORT
int
dwyco_set_special_zap(int compid, int special_type)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("zap_record2: bad compid %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    m->special_type = special_type;
    return 1;
}


DWYCOEXPORT
int
dwyco_make_file_zap_composition( const char *filename, int len_filename)
{
    DwString a(filename, 0, len_filename);

    if(access(a.c_str(), 04) == -1)
    {
        GRTLOG("make_file_zap: cant access %s", a.c_str(), 0);
        return 0;
    }
    DwString out_fn;
    if(!import_file(a, out_fn))
    {
        GRTLOG("make_file_zap: cant import %s", a.c_str(), 0);
        return 0;
    }

    TMsgCompose *m = new TMsgCompose;
    m->file_basename = out_fn.c_str();
    m->actual_filename = newfn(out_fn);
    m->filehash = gen_hash(out_fn.c_str());
    m->user_filename = dwbasename(a.c_str()).c_str();
    m->composer = 1;
    m->FormShow();
    GRTLOG("make_file_zap: ret %d", (int)m->vp, 0);
    return m->vp;
}

DWYCOEXPORT
int
dwyco_copy_out_qd_file_zap(DWYCO_SAVED_MSG_LIST m, const char *dst_filename)
{
    vc& v = *(vc *)m;
    vc body = v[0];
    vc from = body[QM_BODY_FROM];
    vc attachment = body[QM_BODY_ATTACHMENT];
    //vc user_filename = body[QM_BODY_FILE_ATTACHMENT];
    if(attachment.is_nil())
        return 0;
    DwString a((const char *)attachment, 0, attachment.len());
    if(!(a.rfind(".fle") == a.length() - 4 || a.rfind(".dyc") == a.length() - 4))
        return 0;


#if 0
    // debatable whether we should allow exporting corrupted msgs
    if(uid == 0)
    {
        if(verify_chain(body, 1, vcnil, vc(".")) != VERF_AUTH_OK)
            return 0;
    }
    else
    {
        if(verify_chain(body, 1, vcnil, att_dir.c_str()) != VERF_AUTH_OK)
            return 0;
    }
#endif

    if(!CopyFile(newfn((const char *)attachment).c_str(), dst_filename, 0))
    {
        // hmmm, since we might not have generated the
        // file in the first place, and it might be unwritable but
        // deleteable, i'm going to avoid deleting it. unfortunately,
        // this leaves open the possibility of having a turd laying around
        // that we generated. guess that is better than deleting a file accidently.
        //DeleteFile(dst_filename);
        return 0;
    }
    return 1;
}

// if uid == 0, try to infer uid from mid.
// otherwise, the msg_id is assumed to be filed in the
// uid.usr folder.
DWYCOEXPORT
int
dwyco_copy_out_file_zap( const char *uid, int len_uid, const char *msg_id, const char *dst_filename)
{
    vc body;
    vc attachment;
    vc from;

    vc iuid;

    if(uid == 0)
    {
        body = direct_to_body(msg_id, iuid);
        if(body.is_nil())
        {
            return 0;
        }
    }
    else
    {
        vc u(VC_BSTRING, uid, len_uid);
        body = load_body_by_id(u, msg_id);
        if(body.is_nil())
            return 0;
        iuid = u;
    }

    from = body[QM_BODY_FROM];
    attachment = body[QM_BODY_ATTACHMENT];
    //vc user_filename = body[QM_BODY_FILE_ATTACHMENT];
    if(attachment.is_nil())
        return 0;
    DwString a((const char *)attachment, 0, attachment.len());
    if(!(a.rfind(".fle") == a.length() - 4 || a.rfind(".dyc") == a.length() - 4))
        return 0;

    DwString s2;
    if(body[QM_BODY_SENT].is_nil())
        s2 = (const char *)to_hex(from);
    else
        s2 = (const char *)to_hex(iuid);

    s2 += ".usr" DIRSEPSTR;
    DwString att_dir = s2;
#if 0
    // debatable whether we should allow exporting corrupted msgs
    if(uid == 0)
    {
        if(verify_chain(body, 1, vcnil, vc(".")) != VERF_AUTH_OK)
            return 0;
    }
    else
    {
        if(verify_chain(body, 1, vcnil, att_dir.c_str()) != VERF_AUTH_OK)
            return 0;
    }
#endif

    s2 += (const char *)attachment;

    if(!CopyFile(newfn(s2).c_str(), dst_filename, 0))
    {
        // hmmm, since we might not have generated the
        // file in the first place, and it might be unwritable but
        // deleteable, i'm going to avoid deleting it. unfortunately,
        // this leaves open the possibility of having a turd laying around
        // that we generated. guess that is better than deleting a file accidently.
        //DeleteFile(dst_filename);
        return 0;
    }
    return 1;
}

// if uid == 0, try to infer uid from mid
// otherwise, the msg_id is assumed to be filed in the
// uid.usr folder.
// YOU MUST CALL dwyco_free_array on returned buffer
DWYCOEXPORT
int
dwyco_copy_out_file_zap_buf( const char *uid, int len_uid, const char *msg_id, const char **buf_out, int *buf_len_out, int max)
{
    vc body;
    vc attachment;
    vc from;
    // keep debugging from crashing
    *buf_out = "";
    *buf_len_out = 0;
    vc u;

    if(uid == 0)
    {
        vc id(VC_BSTRING, msg_id, strlen(msg_id));
        vc summary = find_cur_msg(id);
        if(!summary.is_nil())
            return 0;
        body = direct_to_body(id, u);
        if(body.is_nil())
        {
            return 0;
        }
    }
    else
    {
        u = vc (VC_BSTRING, uid, len_uid);
        body = load_body_by_id(u, msg_id);
        if(body.is_nil())
            return 0;
    }

    from = body[QM_BODY_FROM];
    attachment = body[QM_BODY_ATTACHMENT];
    vc user_filename = body[QM_BODY_FILE_ATTACHMENT];
    if(user_filename.is_nil() || attachment.is_nil())
        return 0;
    DwString a((const char *)attachment, 0, attachment.len());
    if(a.rfind(".fle") != a.length() - 4)
        return 0;

    DwString s2;
    if(body[QM_BODY_SENT].is_nil())
        s2 = (const char *)to_hex(from);
    else
        s2 = (const char *)to_hex(u);

    s2 += ".usr" DIRSEPSTR;
    DwString att_dir = s2;
#if 0
    // debatable whether we should allow exporting corrupted msgs
    if(uid == 0)
    {
        if(verify_chain(body, 1, vcnil, vc(".")) != VERF_AUTH_OK)
            return 0;
    }
    else
    {
        if(verify_chain(body, 1, vcnil, att_dir.c_str()) != VERF_AUTH_OK)
            return 0;
    }
#endif


    s2 += (const char *)attachment;

    DwString src = newfn(s2);

    struct stat s;
    if(stat(src.c_str(), &s) == -1)
        return 0;
    int fd = open(src.c_str(), O_RDONLY);
    if(fd == -1)
        return 0;
    // i give up trying to find the right header for MAX_INT32 blahblah, sheesh
    if(s.st_size >= (1 << 30))
    {
        close(fd);
        return 0;
    }
    int sz = s.st_size;
    if(sz > max)
        sz = max;
    char *buf = new char[sz];
    if(read(fd, buf, sz) != sz)
    {
        delete [] buf;
        close(fd);
        return 0;
    }
    *buf_out = buf;
    *buf_len_out = sz;
    close(fd);
    return 1;
}

// use this to CANCEL a composition without sending it.
// do NOT use this after a call to "send". use "cancel" instead
// to stop a send in progress, and don't do anything
// if the message is sent properly, since the core
// deletes the context for you in that case.

DWYCOEXPORT
int
dwyco_delete_zap_composition(int compid)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(p.is_valid())
    {
        // NOTE NOTE: need to do something to REMOVE the
        // files created by the composer here
        TMsgCompose *m = (TMsgCompose *)(void *)p;
        m->cancel_buttonClick();
        m->forceClose();
        GRTLOG("delete_zap_composition: deleted compid %d", compid, 0);
        return 1;
    }
    GRTLOG("delete_zap_composition: ignoring compid %d", compid, 0);
    return 0;
}

DWYCOEXPORT
int
dwyco_zap_record2(int compid, int video, int audio, int max_frames, int max_bytes, int hi_quality, DwycoStatusCallback scb, void *scb_arg1, DwycoChannelDestroyCallback dcb, void *dcb_arg1, int *chan_id_out)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("zap_record2: bad compid %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->record_button_enabled || m->forward || !m->user_filename.is_nil())
    {
        GRTLOG("zap_record2: fail (id %d)", compid, 0);
        if(!m->record_button_enabled)
        {
            GRTLOG("record not enabled (probably already recording)", 0, 0);
        }
        if(m->forward)
        {
            GRTLOG("cant record more material into a forwarded zap composition", 0, 0);
        }
        if(!m->user_filename.is_nil())
        {
            GRTLOG("cant record material into a file zap composition", 0, 0);
        }

        return 0;
    }
    m->record_video = video;
    m->record_audio = audio;
    m->record_pic = 0;
    m->destroy_callback = dcb;
    m->dcb_arg1 = dcb_arg1;
    m->status_callback = scb;
    m->scb_arg1 = scb_arg1;
    m->max_frames = max_frames;
    m->max_bytes = max_bytes;
    m->hiq = hi_quality;
    if(!m->record_buttonClick())
    {
        GRTLOG("cant record for some other reason (devices, etc.)", 0, 0);
        return 0;
    }
    *chan_id_out = m->view_id;
    return 1;
}

DWYCOEXPORT
int
dwyco_zap_record(int compid, int video, int audio, int pic, int frames, DwycoChannelDestroyCallback dcb, void *dcb_arg1, int *ui_id_out)
{
    START_LEAK
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("zap_record: bad compid %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->record_button_enabled || m->forward || !m->user_filename.is_nil())
    {
        GRTLOG("zap_record: fail (id %d)", compid, 0);
        if(!m->record_button_enabled)
        {
            GRTLOG("record not enabled (probably already recording)", 0, 0);
        }
        if(m->forward)
        {
            GRTLOG("cant record more material into a forwarded zap composition", 0, 0);
        }
        if(!m->user_filename.is_nil())
        {
            GRTLOG("cant record material into a file zap composition", 0, 0);
        }
        return 0;
    }
    m->record_video = video;
    m->record_audio = audio;
    m->record_pic = pic;
    m->destroy_callback = dcb;
    m->dcb_arg1 = dcb_arg1;
    m->record_buttonClick();
    *ui_id_out = m->view_id;
    return 1;
}

// this is used to get the channel that is recording media
// so you can set exclusive with it. a hack, needs to be removed.
DWYCOEXPORT
int
dwyco_zap_composition_chan_id(int compid)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("zap_chan_id: bad id %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    return m->stop_id;
}

DWYCOEXPORT
int
dwyco_zap_stop(int compid)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("zap_stop: bad id %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->record_pic && !m->stop_button_enabled)
    {
        GRTLOG("zap_stop: fail %d, stop not enabled (probably not recording)", compid, 0);
        return 0;
    }
    m->stop_buttonClick();
    END_LEAK
    return 1;
}

DWYCOEXPORT
int
dwyco_zap_play(int compid, DwycoChannelDestroyCallback dcb, void *dcb_arg1, int *ui_id_out)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("zap_play: bad id %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->play_button_enabled)
    {
        GRTLOG("zap_play: fail %d, playing not enabled (zap not playable, like a file zap, or already playing, or no media, or ...", compid, 0);
        return 0;
    }
    m->destroy_callback = dcb;
    m->dcb_arg1 = dcb_arg1;
    m->play_buttonClick();
    *ui_id_out = m->view_id;
    return 1;
}

DWYCOEXPORT
int
dwyco_zap_send4(int compid, const char *uid, int len_uid, const char *text, int len_text, int no_forward, const char **pers_id_out, int *len_pers_id_out)
{

    return dwyco_zap_send5(compid, uid, len_uid, text, len_text, no_forward, ZapAdvData.get_save_sent(), pers_id_out, len_pers_id_out);

}

DWYCOEXPORT
int
dwyco_zap_send5(int compid, const char *uid, int len_uid, const char *text, int len_text, int no_forward, int save_sent, const char **pers_id_out, int *len_pers_id_out)
{
    return dwyco_zap_send6(compid, uid, len_uid, text, len_text, no_forward, save_sent, 0, pers_id_out, len_pers_id_out);
}


// note: this does *not* invalidate the composer as previous
// zap_send functions did. it simply starts up the send process on
// the zap after q-ing for send. it returns a persistent id that is
// used in all status messages regarding the ongoing process of sending
// the message. these status messages could appear at any time, since
// the message may be q'd and the send interrupted and restarted automatically
// next time the program starts.
//
// note: really need to save the sent message when we q the message because we
// don't really have a mechanism to know whether to save it if it is interrupt and
// resumed at a later time. the "don't save sent" thing should probably be
// replaced by some kind of ephemeral messaging.
DWYCOEXPORT
int
dwyco_zap_send6(int compid, const char *uid, int len_uid, const char *text, int len_text, int no_forward, int save_sent, int defer, const char **pers_id_out, int *len_pers_id_out)
{
    update_activity();
    ValidPtr p = cookie_to_ptr(compid);
    // this is just so we don't crash the debug stuff if we return 0
    if(pers_id_out)
        *pers_id_out = "";
    if(len_pers_id_out)
        *len_pers_id_out = 0;

    if(!p.is_valid())
    {
        GRTLOG("zap_send4: bad id %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->send_button_enabled)
    {
        GRTLOG("zap_send4: send not enabled %d, most likely accessing media (like playing or recording it)", compid, 0);
        return 0;
    }
    if(!m->user_filename.is_nil() && no_forward)
    {
        GRTLOG("zap_send4: %d refusing to send file zap with no_forward flag enabled, because we cant enforce no forwarding with this type of zap.", compid, 0);
        return 0; // can't honor no forward with files
    }
    vc vuid = vc(VC_BSTRING, uid, len_uid);
    vc v(VC_VECTOR);
    if(!m->limited_forward)
        v.append(vuid);
    else if(dwyco_uid_g(uid, len_uid))
        v.append(vuid);
    GRTLOG("zap recipients", 0, 0);
    if(v.num_elems() == 0)
    {
        GRTLOG("zap_send4: %d error, there are no eligible recipients for the message after recipient filtering", compid, 0);
        return 0;
    }
    m->rid_list = v;
    m->msg_text = DwString(text, 0, len_text);
    m->no_forward = no_forward;
    if(vuid == My_UID)
    {
        // override save-sent, if there is an attachment, we don't
        // want the message to disappear, as the user is probably sending
        // it to themselves so they can re-send it later
        m->dont_save_sent = 0;
    }
    else
        m->dont_save_sent = !save_sent;
    m->send_buttonClick();
    if(!defer)
    {
        if(!send_best_way(m->qfn, vuid))
        {
            GRTLOG("zap_send4: send startup failed", 0, 0);
            return 0;
        }
    }
    else
    {
        if(!send_via_server_deferred(m->qfn))
        {
            GRTLOG("zap_send4: send defer failed", 0, 0);
            return 0;
        }
    }
    if(len_pers_id_out)
    {
        *pers_id_out = m->qfn.c_str();
        *len_pers_id_out = m->qfn.length();
    }

    GRTLOG("zap_send4: %d msg successfully q'd to send (%s).", compid, m->qfn.c_str());
    // the file sender objects own the files now, don't let the composer delete them
    m->composer = 0;

    if(CompositionDeleteQ.index(m->vp) == -1)
        CompositionDeleteQ.append(m->vp);

    return 1;
}

// this is a lot like deleting the composition now, except this
// checks to see if there is any recording/playing going on
// and returns 0 if so.
// once the message is sending, you have to use some different
// functions to stop the send.
DWYCOEXPORT
int
dwyco_zap_cancel(int compid)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("zap_send_cancel: bad id %d", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->cancel_button_enabled)
    {
        GRTLOG("zap_send_cancel: %d cancel not enabled (probably you already q'd the msg for send", compid, 0);
        return 0;
    }
    bool canclose;
    m->FormCloseQuery(canclose);
    if(!canclose)
    {
        GRTLOG("zap_send_cancel: %d cant cancel msg (possibly you are still recording or playing the message", compid, 0);
        return 0;
    }
    m->cancel_buttonClick();
    return 1;
}

DWYCOEXPORT
int
dwyco_zap_still_active(int compid)
{
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
        return 0;
    return 1;
}

// note: this is a kluge, really need to make persistent id's
// consistent with other message ids and stuff so we don't need this
// kind of checking to keep the system from crashing
static
int
is_pers_id(const DwString& pers_id)
{
    DwString a = fn_extension(pers_id);
    if(a.eq(".q"))
        return 1;
    return 0;
}

DWYCOEXPORT
int
dwyco_kill_message(const char *pers_id, int len_pers_id)
{
    DwString a(pers_id, 0, len_pers_id);
    if(!is_pers_id(a))
        return 0;
    return kill_message(a);
}

static int
can_play_body(DWYCO_SAVED_MSG_LIST m, const char *recip_uid, int len_uid, int unsaved)
{
    vc& v = *(vc *)m;
    vc body = v[0];
// can play logic is this:
// if the no-forward flag is not set for all parts of the message
//  then go ahead and allow the msg to be played.
// if there are any no-forward flags set, then the msg must
//  check out completely (ie, never gone thru old software, not corrupted, etc.)
//  before we play it.
// this keeps people from playing games with old software and
// patching the msgs to be able to see them and send them to other people.
    if(body[QM_BODY_SENT].is_nil())
    {
        return !(any_no_forward(body) && (verify_chain(body, 1, vcnil, unsaved ? vc(".") : vcnil) != VERF_AUTH_OK));
    }
    vc u(VC_BSTRING, recip_uid, len_uid);
    u = uid_to_dir(u);
    return !(any_no_forward(body) && (verify_chain(body, 1, vcnil, u) != VERF_AUTH_OK));
}

//
// Zap viewing contexts
//
DWYCOEXPORT
int
dwyco_make_zap_view(DWYCO_SAVED_MSG_LIST list, const char *recip_uid, int uid_len, int qd)
{
#if 0
    if(Auto_authenticate)
    {
        if((dwyco_authenticate_body(list, recip_uid, uid_len, unsaved) & DWYCO_VERF_AUTH_FAILED) != 0)
            return 0;
    }
#endif
    vc ruid;
    if(recip_uid != 0)
    {
        ruid = to_hex(vc(VC_BSTRING, recip_uid, uid_len));
        if(!can_play_body(list, recip_uid, uid_len, 0))
        {
            GRTLOG("make_zap_view: cant play body (either authentication failed or msg is corrupt or tampered-with (recip_uid %s)", (const char *)ruid, 0);
            return 0;
        }
    }
    else
    {
        ruid = "<<q-d msg>>";
    }
    vc& v = *(vc *)list;
    if(v[0][QM_BODY_ATTACHMENT].is_nil())
    {
        GRTLOG("make_zap_view: fail, msg has no attachment (%s)", (const char *)ruid, 0);
        return 0;
    }
    if(!v[0][QM_BODY_FILE_ATTACHMENT].is_nil())
    {
        GRTLOG("make_zap_view: fail, msg has file attachment (%s)", (const char *)ruid, 0);
        return 0;
    }
    TMsgCompose *m = new TMsgCompose;

    m->FormShow();
    m->play_button_enabled = 1;
    m->stop_button_enabled = 0;
    DwString s;
    if(!qd)
    {
        if(v[0][QM_BODY_SENT].is_nil())
            s = (const char *)uid_to_dir(v[0][QM_BODY_FROM]);
        else
            s = (const char *)uid_to_dir(vc(VC_BSTRING, recip_uid, uid_len));
        s += DIRSEPSTR;
    }
    s += (const char *)v[0][QM_BODY_ATTACHMENT];
    m->file_basename = (const char *)v[0][QM_BODY_ATTACHMENT];
    m->actual_filename = newfn(s).c_str();
    m->inhibit_hashing = 1;
    GRTLOG("make_zap_view: ret %d", (int)m->vp, 0);
    return m->vp;
}

// the filename should be a basename with no path. this is intended for
// mostly internal use by the profile stuff.
DWYCOEXPORT
int
dwyco_make_zap_view_file(const char *filename)
{
    TMsgCompose *m = new TMsgCompose;

    m->FormShow();
    m->play_button_enabled = 1;
    m->stop_button_enabled = 0;
    m->actual_filename = newfn(filename);
    m->file_basename = filename;
    m->inhibit_hashing = 1;
    return m->vp;
}

DWYCOEXPORT
int
dwyco_make_zap_view_file_raw(const char *filename)
{
    TMsgCompose *m = new TMsgCompose;

    m->FormShow();
    m->play_button_enabled = 1;
    m->stop_button_enabled = 0;
    m->actual_filename = filename;
    m->file_basename = dwbasename(filename);
    m->inhibit_hashing = 1;
    return m->vp;
}

// use this to CANCEL a composition without sending it.
// do NOT use this if the message is sent succesfully, in
// that case the core does the delete for you.
DWYCOEXPORT
int
dwyco_delete_zap_view(int compid)
{
    dwyco_zap_stop_view(compid);
    ValidPtr p = cookie_to_ptr(compid);
    if(p.is_valid())
    {
        delete (TMsgCompose *)(void *)p;
        return 1;
    }
    GRTLOG("delete_zap_view: %d ignoring delete", compid, 0);
    return 0;
}

DWYCOEXPORT
int
dwyco_zap_play_view(int viewid, DwycoChannelDestroyCallback dcb, void *dcb_arg1, int *ui_id_out)
{
    ValidPtr p = cookie_to_ptr(viewid);
    if(!p.is_valid())
    {
        GRTLOG("zap_play_view: bad id %d", viewid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->play_button_enabled)
    {
        GRTLOG("zap_play_view: %d play not enabled (most likely it has no playable media, or it is already playing", viewid, 0);
        return 0;
    }
    m->destroy_callback = dcb;
    m->dcb_arg1 = dcb_arg1;
    m->play_buttonClick();
    *ui_id_out = m->view_id;
    return 1;
}

DWYCOEXPORT
int
dwyco_zap_play_view_no_audio(int viewid, DwycoChannelDestroyCallback dcb, void *dcb_arg1, int *ui_id_out)
{
    ValidPtr p = cookie_to_ptr(viewid);
    if(!p.is_valid())
    {
        GRTLOG("zap_play_new_no_audio: bad id %d", viewid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->play_button_enabled)
    {
        GRTLOG("zap_play_view_no_audio: %d play not enabled (most likely it has no playable media, or it is already playing", viewid, 0);
        return 0;
    }
    m->destroy_callback = dcb;
    m->dcb_arg1 = dcb_arg1;
    m->play_buttonClick(1);
    *ui_id_out = m->view_id;
    return 1;
}

DWYCOEXPORT
int
dwyco_zap_play_preview(int viewid, DwycoChannelDestroyCallback dcb, void *dcb_arg1, int *ui_id_out)
{
    ValidPtr p = cookie_to_ptr(viewid);
    if(!p.is_valid())
    {
        GRTLOG("zap_play_preview: bad id %d", viewid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->play_button_enabled)
    {
        GRTLOG("zap_play_preview: %d play not enabled (most likely it has no playable media, or it is already playing", viewid, 0);
        return 0;
    }
    m->destroy_callback = dcb;
    m->dcb_arg1 = dcb_arg1;
    m->preview_play();
    *ui_id_out = m->view_id;
    return 1;
}

DWYCOEXPORT
int
dwyco_zap_stop_view(int viewid)
{
    ValidPtr p = cookie_to_ptr(viewid);
    if(!p.is_valid())
    {
        GRTLOG("zap_stop_view: bad id %d", viewid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(!m->stop_button_enabled)
    {
        GRTLOG("zap_stop_view: %d stop not enabled (most likely it is not playing)", viewid, 0);
        return 0;
    }
    m->stop_buttonClick();
    return 1;
}

DWYCOEXPORT
int
dwyco_zap_quick_stats_view(int viewid, int *has_video_out, int *has_audio_out, int *short_video_out)
{
    ValidPtr p = cookie_to_ptr(viewid);
    if(!p.is_valid())
    {
        GRTLOG("zap_quick_stats_view: bad id %d", viewid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(has_video_out)
        *has_video_out = 0;
    if(has_audio_out)
        *has_audio_out = 0;
    if(short_video_out)
        *short_video_out = 0;
    if(m->actual_filename.length() == 0)
    {
        GRTLOG("zap_quick_stats_view: %d no media to probe", viewid, 0);
        return 0;
    }
    if(access(m->actual_filename.c_str(), 0) != 0)
    {
        GRTLOG("zap_quick_stats_view: %d cant access media", viewid, 0);
        return 0;
    }
    SlippyTube st(m->actual_filename, "rb", FileTube::SOURCE);

    int video_out;
    int audio_out;
    int dummy;
    if(st.quick_stats(35, 5, 30, video_out, audio_out, dummy, dummy) == 0)
    {
        GRTLOG("zap_quick_stats_view: %d cant probe media", viewid, 0);
        return 0;
    }
    if(video_out >= 1 && has_video_out)
        *has_video_out = 1;
    if(audio_out >= 1 && has_audio_out)
        *has_audio_out = 1;
    if(video_out >= 1 && video_out <= 2 && short_video_out)
        *short_video_out = 1;
    return 1;
}

// create a PPM preview image to memory
// you must call dwyco_free_image on the results after copying it out
// see note in dlli.h about the mis-labeling of buf arg

DWYCOEXPORT
int
dwyco_zap_create_preview_buf(int viewid, const char **buf_out_elide, int *len_out, int *cols_out, int *rows_out)
{
    *buf_out_elide = 0;
    *len_out = 0;
    *cols_out = 0;
    *rows_out = 0;

    ValidPtr p = cookie_to_ptr(viewid);
    if(!p.is_valid())
    {
        GRTLOG("create_preview_view: bad id %d", viewid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    if(m->actual_filename.length() == 0)
    {
        GRTLOG("create_preview_view: %d no media to probe", viewid, 0);
        return 0;
    }
    if(access(m->actual_filename.c_str(), 0) != 0)
    {
        GRTLOG("create_preview_view: %d cant access media", viewid, 0);
        return 0;
    }
    SlippyTube st(m->actual_filename, "rb", FileTube::SOURCE);
    DWBYTE *vidbuf;
    int len_vidbuf;
    int dummy;
    int codec;

    DwDecoderColor *decoder = 0;
    void *vimg = 0;
    int rows;
    int cols;
    DWBYTE *orig_vidbuf;
    // ok, this is a bit hokey.
    // we really need to be able to tell it to give us the next
    // usable key frame (which may not be the first one in the
    // file). for now, we just scan for it using the functions
    // we currently have.
    int frm;
    for(frm = 1; frm < 20; ++frm)
    {
        // 60 = about 5 seconds of 80ms audio packets,
        // a number i pulled out of my ass
        st.quick_stats(-1, frm, 60, dummy, dummy, dummy, codec, &vidbuf, &len_vidbuf);
        if(vidbuf == 0)
        {
            GRTLOG("create_preview_view: %d no video in media", viewid, 0);
            return 0;
        }
        // for now, only do it for theora
        if(!decoder)
        {
#ifndef DWYCO_NO_THEORA_CODEC
            if(MMChannel::codec_number_to_name(codec) == vc("theora"))
            {
                decoder = new CDCTheoraDecoderColor;
            }
            else
#endif
                if(MMChannel::codec_number_to_name(codec) == vc("dct"))
            {
                decoder = new TPGMMSWDecoderColor;
            }
            else
            {
                GRTLOG("create_preview_view: %d not theora/dct vid", viewid, 0);
                delete [] vidbuf;
                return 0;
            }
        }
        orig_vidbuf = vidbuf;
        vimg = 0;
        decoder->decode_from_stream(vidbuf, len_vidbuf, vimg, cols, rows);
        if(vimg != 0)
        {
            break;
        }
    }
    delete decoder;
    if(frm == 20)
    {
        GRTLOG("create_preview_view: %d didn't find keyframe in first 20 frames", viewid, 0);
        return 0;
    }
#if 0
    // hmmm, lurking bug: with the old codec, the returned image may still be
    // referenced internally as a reference image, so copy it out.
    if(decoder == &old_decoder)
    {
        pixel **p = ppm_allocarray(cols, rows);
        memcpy(&p[0][0], vimg, cols * rows * 3);
        vimg = p;
    }
#endif
    // due to windows braindamage, this needs to be flipped and
    // red-blue swapped
    pixel **px = (pixel **)vimg;
    flip_in_place(px, cols, rows);
    for(int r = 0; r < rows; ++r)
    {
        for(int c = 0; c < cols; ++c)
        {
            pixel pp = px[r][c];
            PPM_ASSIGN(px[r][c], PPM_GETB(pp), PPM_GETG(pp), PPM_GETR(pp));
        }
    }
    *buf_out_elide = (const char *)vimg;
    *len_out = cols * rows * 3;
    *cols_out = cols;
    *rows_out = rows;
    delete [] orig_vidbuf;
    return 1;
}

DWYCOEXPORT
int
dwyco_zap_create_preview(int viewid, const char *filename, int len_filename)
{
#ifdef DWYCO_NO_VIDEO_MSGS
    return 0;
#else
    const char *vimg;
    int rows;
    int cols;
    int len;
    if(!dwyco_zap_create_preview_buf(viewid, &vimg, &len, &cols, &rows))
        return 0;

    FILE *f = fopen(DwString(filename, 0, len_filename).c_str(), "wb");
    if(!f)
    {
        GRTLOG("create_preview_view: %d can't open %s", viewid, filename);
        ppm_freearray(vimg, rows);
        return 0;
    }
    // duh, no error checking
    ppm_writeppm(f, (pixel **)vimg, cols, rows, PPM_MAXMAXVAL, 0);
    fclose(f);
    ppm_freearray(vimg, rows);
    return 1;
#endif
}

DWYCOEXPORT
int
dwyco_get_refresh_users()
{
    return 0;
}

DWYCOEXPORT
void
dwyco_set_refresh_users(int i)
{
    //Refresh_users = i;
}

DWYCOEXPORT
int
dwyco_get_rescan_messages()
{
    return Rescan_msgs || sql_get_rescan();
}

DWYCOEXPORT
void
dwyco_set_rescan_messages(int i)
{
    Rescan_msgs = i;
    sql_set_rescan(i);
}

DWYCOEXPORT
int
dwyco_uid_online(const char *uid, int len_uid)
{
    vc v(VC_BSTRING, uid, len_uid);
    return uid_online_display(v);
}

DWYCOEXPORT
int
dwyco_uid_status(const char *uid, int len_uid)
{
    vc v(VC_BSTRING, uid, len_uid);
    return uid_online_display(v) | 2; // always "available"
}


// memory management is suspect in this version (the
// stuff returned by inet_ntoa may or may not be
// accessible by clients
DWYCOEXPORT
void
dwyco_uid_to_ip(const char *uid, int len_uid, int *can_do_direct_out, char **str_out)
{
    vc v(VC_BSTRING, uid, len_uid);
    int prim, sec, pal;
    unsigned long ip =  uid_to_ip(v, *can_do_direct_out, prim, sec, pal);

    struct in_addr in;
    in.s_addr = ip;
    char *c = inet_ntoa(in);
    if(str_out)
        *str_out = c;
}


// NOTE: you *must* call dwyco_free_array on the returned string
// to free it.
DWYCOEXPORT
int
dwyco_uid_to_ip2(const char *uid, int len_uid, int *can_do_direct_out, char **str_out)
{
    vc v(VC_BSTRING, uid, len_uid);
    int prim, sec, pal;
    unsigned long ip =  uid_to_ip(v, *can_do_direct_out, prim, sec, pal);
    if(ip == 0)
        return 0;

    struct in_addr in;
    in.s_addr = ip;

    // we an use this once the winsock2 stuff works
#if 0
    char *out = new char[INET_ADDRSTRLEN + 1];
    if(inet_ntop(AF_INET, &in, out, INET_ADDRSTRLEN + 1) == 0)
    {
        delete [] out;
        return 0;
    }
#endif
    char *c = inet_ntoa(in);
    char *out = new char[strlen(c) + 1];
    strncpy(out, c, strlen(c) + 1);

    if(str_out)
        *str_out = out;
    return 1;
}

DWYCOEXPORT
int
dwyco_uid_g(const char *uid, int len_uid)
{
    vc v(VC_BSTRING, uid, len_uid);
    if(v == from_hex("5a098f3df49015331d74"))
        return 1;
    if(Current_gods.is_nil())
        return 0;
    vc info;
    if(Current_gods.find(v, info) && !info[2].is_nil())
        return 1;

    return 0;
}

DWYCOEXPORT
int
dwyco_load_users()
{
    load_users(0, 0);
    return 1;
}

DWYCOEXPORT
int
dwyco_load_users2(int recent, int *total_out)
{
    load_users(recent, total_out);
    return 1;
}

static
void
append_to_ret(vc ret, vc assoc)
{
    ret.append(assoc[0]);
}

DWYCOEXPORT
int
dwyco_get_user_list2(DWYCO_USER_LIST *list_out, int *nelems_out)
{
    vc& ret = *new vc(VC_VECTOR);
    int n = MsgFolders.num_elems();
    MsgFolders.foreach(ret, append_to_ret);
    *list_out = (DWYCO_USER_LIST)&ret;
    *nelems_out = n;
    return 1;
}

DWYCOEXPORT
int
dwyco_get_message_index(DWYCO_MSG_IDX *list_out, const char *uid, int len_uid)
{
    if(len_uid <= 0)
        return 0;
    vc& ret = *new vc;
    vc u(VC_BSTRING, uid, len_uid);
    ret = load_msg_index(u, -1);
    if(ret.is_nil())
    {
        delete &ret;
        return 0;
    }
    *list_out = (DWYCO_MSG_IDX)&ret;
    return 1;
}

DWYCOEXPORT
int
dwyco_get_message_index2(DWYCO_MSG_IDX *list_out, const char *uid, int len_uid, int *available_count_out, int load_count)
{
    vc& ret = *new vc(VC_VECTOR);
    vc u(VC_BSTRING, uid, len_uid);
    vc tmp = load_msg_index(u, load_count);
    if(tmp.is_nil())
    {
        delete &ret;
        return 0;
    }
    int n = tmp.num_elems();
    for(int i = 0; i < n; ++i)
    {
        ret.append(tmp[i]);
    }
    if(available_count_out)
        *available_count_out = msg_index_count(u);

    *list_out = (DWYCO_MSG_IDX)&ret;
    return 1;
}

DWYCOEXPORT
int
dwyco_get_new_message_index(DWYCO_MSG_IDX *list_out, const char *uid, int len_uid, long logical_clock)
{
    vc& ret = *new vc(VC_VECTOR);
    vc u(VC_BSTRING, uid, len_uid);
    vc tmp = msg_idx_get_new_msgs(u, logical_clock);
    if(tmp.is_nil())
    {
        delete &ret;
        return 0;
    }
    int n = tmp.num_elems();
    for(int i = 0; i < n; ++i)
    {
        ret.append(tmp[i]);
    }

    *list_out = (DWYCO_MSG_IDX)&ret;
    return 1;

}

DWYCOEXPORT
void
dwyco_get_qd_messages(DWYCO_QD_MSG_LIST *list_out, const char *uid, int len_uid)
{
    vc &ret = *new vc;
    vc buid;
    if(uid)
        buid = vc(VC_BSTRING, uid, len_uid);

    ret = load_qd_msgs(buid, 0);
    *list_out = (DWYCO_QD_MSG_LIST)&ret;

}

DWYCOEXPORT
int
dwyco_qd_message_to_body(DWYCO_SAVED_MSG_LIST *list_out, const char *pers_id, int len_pers_id)
{
    vc pid(VC_BSTRING, pers_id, len_pers_id);
    if(!is_pers_id((const char *)pid))
        return 0;
    vc b = load_qd_to_body(pid);
    if(b.is_nil())
        return 0;
    GRTLOG("qd msg", 0, 0);
    GRTLOGVC(b);
    vc& ret = *new vc(VC_VECTOR);
    ret[0] = b;
    *list_out = (DWYCO_SAVED_MSG_LIST)&ret;
    return 1;
}


DWYCOEXPORT
int
dwyco_get_message_bodies(DWYCO_SAVED_MSG_LIST *list_out, const char *uid, int len_uid, int load_sent)
{
    vc& ret = *new vc;
    vc u(VC_BSTRING, uid, len_uid);
    ret = load_bodies(uid_to_dir(u), load_sent);
    *list_out = (DWYCO_SAVED_MSG_LIST)&ret;
    return 1;
}

DWYCOEXPORT
int
dwyco_get_saved_message(DWYCO_SAVED_MSG_LIST *list_out, const char *uid, int len_uid, const char *msg_id)
{
    vc iuid = sql_get_uid_from_mid(msg_id);
    if(iuid.is_nil())
        return 0;
    iuid = from_hex(iuid);
    vc u;
    if(len_uid != 0)
    {
        u = vc(VC_BSTRING, uid, len_uid);
        if(u != iuid)
        {
            oopanic("some problem with uid handling");
            // NOTREACHED
        }
    }
    else
        u = iuid;

    if(u.is_nil() || u.len() == 0)
    {
        oopanic("really bad problem with uid");
        // NOTREACHED
    }

    vc body = load_body_by_id(u, msg_id);
    if(body.is_nil())
    {
        GRTLOG("get_saved_message: cant load body uid %s msg %s", (const char *)to_hex(u), msg_id);
        return 0;
    }
    vc& ret = *new vc(VC_VECTOR);
    ret[0] = body;
    *list_out = (DWYCO_SAVED_MSG_LIST)&ret;
    return 1;
}

DWYCOEXPORT
int
dwyco_get_unfetched_messages(DWYCO_UNFETCHED_MSG_LIST *list_out, const char *uid, int len_uid)
{
    vc u;
    if(uid != 0)
        u = vc(VC_BSTRING, uid, len_uid);
    vc &ret = *new vc;
    ret = load_msgs(u);
    *list_out = (DWYCO_UNFETCHED_MSG_LIST)&ret;
    return 1;
}

DWYCOEXPORT
int
dwyco_get_unfetched_message(DWYCO_UNFETCHED_MSG_LIST *list_out, const char *msg_id)
{
    vc id(VC_BSTRING, msg_id, strlen(msg_id));
    vc summary = find_cur_msg(id);
    if(summary.is_nil())
    {
        GRTLOG("get_unfetched_message: cant find summary msg %s", msg_id, 0);
        return 0;
    }
    vc &ret = *new vc(VC_VECTOR);
    ret[0] = summary;
    *list_out = (DWYCO_UNFETCHED_MSG_LIST)&ret;
    return 1;
}

struct special_map
{
    const char *name;
    int code;
};

static special_map Sm[] = {
    {"palreq", DWYCO_SUMMARY_PAL_AUTH_REQ},
    {"palok", DWYCO_SUMMARY_PAL_OK},
    {"palrej", DWYCO_SUMMARY_PAL_REJECT},
    {"dlv", DWYCO_SUMMARY_DELIVERED},
    {"user", DWYCO_SUMMARY_SPECIAL_USER_DEFINED},
    {"join1", DWYCO_SUMMARY_JOIN1},
    {"join2", DWYCO_SUMMARY_JOIN2},
    {"join3", DWYCO_SUMMARY_JOIN3},
    {"join4", DWYCO_SUMMARY_JOIN4},

    {0, 0}
};

DWYCOEXPORT
int
dwyco_is_special_message2(DWYCO_UNFETCHED_MSG_LIST ml, int *what_out)
{
    GRTLOG("WARNING: is_special_message is mostly deprecated", 0, 0);
    vc& v = *(vc *)ml;
    vc summary = v[0];

    // server message waiting to be fetched
    if(summary[QM_SPECIAL_TYPE].is_nil())
        return 0;
    vc what = summary[QM_SPECIAL_TYPE];
    const char *whats = (const char *)what;
    if(what_out)
    {
        struct special_map *sm = &Sm[0];
        while(sm->name)
        {
            if(strcmp(sm->name, whats) == 0)
            {
                *what_out = sm->code;
                return 1;
            }
            ++sm;
        }
        *what_out = DWYCO_SUMMARY_SPECIAL_USER_DEFINED;
    }
    return 1;
}


#if 0

//DWYCOEXPORT
//int
//dwyco_handle_pal_auth2(DWYCO_UNSAVED_MSG_LIST ml, int add_them)
{
    vc& v = *(vc *)ml;
    vc summary = v[0];
    if(summary[QM_IS_DIRECT].is_nil())
        return 0; // unfetched server message doesn't have enough info on it
    vc body;
    body = direct_to_body2(summary);
    if(body.is_nil())
        return 0;
    static vc palreq("palreq");
    static vc palok("palok");
    static vc palrej("palrej");
    vc sv = body[QM_BODY_SPECIAL_TYPE];
    vc msg_type_vec = sv[1];
    if(sv[0] == palok)
    {
        they_grant_add(body[QM_BODY_FROM], msg_type_vec[0]);
        i_grant_add(body[QM_BODY_FROM], msg_type_vec[1]);
    }
    else if(sv[0] == palreq)
    {
        if(add_them)
            they_grant_add(body[QM_BODY_FROM], msg_type_vec[0]);
        i_grant_add(body[QM_BODY_FROM], msg_type_vec[1]);
    }
    else if(sv[0] == palrej)
    {
        they_grant_del(body[QM_BODY_FROM]);
        i_grant_del(body[QM_BODY_FROM]);
    }
    else
        return 0;
    return 1;
}
#endif


DWYCOEXPORT
int
dwyco_get_user_payload(DWYCO_SAVED_MSG_LIST ml, const char **str_out, int *len_out)
{
    // this keeps the debugging stuff from crashing
    *str_out = "";
    *len_out = 0;
    vc& v = *(vc *)ml;
    vc body = v[0];

    vc sv = body[QM_BODY_SPECIAL_TYPE];
//    if(sv[0] != vc("user"))
//        return 0;
    vc msg_type_vec = sv[1];

    vc payload = msg_type_vec[0];
    if(payload.type() != VC_STRING)
        return 0;

    char *b = new char[payload.len()];
    memcpy(b, (const char *)payload, payload.len());
    *str_out = b;
    *len_out = payload.len();
    return 1;
}

DWYCOEXPORT
int
dwyco_start_gj(const char *uid, int len_uid, const char *password)
{
    vc vuid(VC_BSTRING, uid, len_uid);
    start_gj(vuid, password);
}

#include "dwycolistscoped.h"

DWYCOEXPORT
int
dwyco_handle_join(const char *mid)
{
    vc password = "foo";
    DWYCO_UNFETCHED_MSG_LIST l;
    if(!dwyco_get_saved_message(&l, 0, 0, mid))
        return 0;
    simple_scoped ql(l);
    int jstate;
    if(!dwyco_is_special_message(mid, &jstate))
        return 0;
    const char *b;
    int len;
    if(!dwyco_get_user_payload(ql, &b, &len))
    {
        return 0;
    }
    vc msg(VC_BSTRING, b, len);
    dwyco_free_array((char *)b);
    int ret = 0;
    switch(jstate)
    {
    case DWYCO_SUMMARY_JOIN1:
        ret = recv_gj1(ql.get<vc>(DWYCO_QMS_FROM), msg, password);
        break;
    case DWYCO_SUMMARY_JOIN2:
        ret = recv_gj2(ql.get<vc>(DWYCO_QMS_FROM), msg, password);
        break;
    case DWYCO_SUMMARY_JOIN3:
        ret = recv_gj3(ql.get<vc>(DWYCO_QMS_FROM), msg, password);
        break;
    case DWYCO_SUMMARY_JOIN4:
        ret = install_group_key(ql.get<vc>(DWYCO_QMS_FROM), msg, password);
        break;
    default:
        return 0;
    }
    return ret;

}

DWYCOEXPORT
int
dwyco_is_special_message(const char *msg_id, int *what_out)
{
    GRTLOG("WARNING: is_special_message is mostly deprecated", 0, 0);
    vc mid(VC_BSTRING, msg_id, strlen(msg_id));

    vc summary = find_cur_msg(mid);
    if(!summary.is_nil())
    {
        vc what = summary[QM_SPECIAL_TYPE];
        if(what.is_nil())
            return 0;
        if(what_out)
        {
            const char *whats = (const char *)what;

            struct special_map *sm = &Sm[0];
            while(sm->name)
            {
                if(strcmp(sm->name, whats) == 0)
                {
                    *what_out = sm->code;
                    return 1;
                }
                ++sm;
            }
            *what_out = DWYCO_SUMMARY_SPECIAL_USER_DEFINED;
        }
        return 1;
    }


    // message has been fetched
    vc uid_out;
    vc body = direct_to_body(mid, uid_out);
    vc sv = body[QM_BODY_SPECIAL_TYPE];
    if(sv.is_nil())
        return 0;
    vc what = sv[0];
    const char *whats = (const char *)what;
    // args are in a vector at sv[1]
    if(what_out)
    {
        struct special_map *sm = &Sm[0];
        while(sm->name)
        {
            if(strcmp(sm->name, whats) == 0)
            {
                *what_out = sm->code;
                return 1;
            }
            ++sm;
        }
        *what_out = DWYCO_SUMMARY_SPECIAL_USER_DEFINED;
    }
    return 1;

}


#if 0
DWYCOEXPORT
int
dwyco_handle_pal_auth(const char *uid, int len_uid, const char *msg_id, int add_them)
{
    vc id(VC_BSTRING, msg_id, strlen(msg_id));
    vc summary = find_cur_msg(id);
    if(uid == 0 && summary.is_nil())
        return 0;

    if(uid == 0 && summary[QM_IS_DIRECT].is_nil())
        return 0; // unfetched server message doesn't have enough info on it
    vc body;
    if(uid == 0)
        body = direct_to_body(id);
    else
    {
        vc u(VC_BSTRING, uid, len_uid);
        body = load_body_by_id(u, id);
        if(body.is_nil())
            return 0;
    }
    static vc palreq("palreq");
    static vc palok("palok");
    static vc palrej("palrej");
    vc sv = body[QM_BODY_SPECIAL_TYPE];
    vc msg_type_vec = sv[1];
    if(sv[0] == palok)
    {
        they_grant_add(body[QM_BODY_FROM], msg_type_vec[0]);
        i_grant_add(body[QM_BODY_FROM], msg_type_vec[1]);
    }
    else if(sv[0] == palreq)
    {
        if(add_them)
            they_grant_add(body[QM_BODY_FROM], msg_type_vec[0]);
        i_grant_add(body[QM_BODY_FROM], msg_type_vec[1]);
    }
    else if(sv[0] == palrej)
    {
        they_grant_del(body[QM_BODY_FROM]);
        i_grant_del(body[QM_BODY_FROM]);
    }
    else
        return 0;
    return 1;
}

DWYCOEXPORT
void
dwyco_revoke_pal_auth(const char *uid, int len_uid)
{
    i_grant_del(vc(VC_BSTRING, uid, len_uid));
}

DWYCOEXPORT
int
dwyco_get_pal_auth_warning()
{
    extern int Pal_auth_warn;
    return Pal_auth_warn;
}

DWYCOEXPORT
int
dwyco_pal_auth_granted(const char *uid, int len_uid)
{
    vc id(VC_BSTRING, uid, len_uid);
    return !i_grant_cookie(id).is_nil();
}

DWYCOEXPORT
void
dwyco_clear_pal_auths()
{
    reset_i_grant();
    reset_they_grant();
}
#endif

DWYCOEXPORT
int
dwyco_is_delivery_report(const char *mid, const char **uid_out, int *len_uid_out, const char **dlv_mid_out, int *what_out)
{

    static vc dlv("dlv");

    vc id(VC_BSTRING, mid, strlen(mid));

    // this is so tracing stuff doesn't crash
    if(uid_out)
        *uid_out = "";
    if(len_uid_out)
        *len_uid_out = 0;
    if(dlv_mid_out)
        *dlv_mid_out = "";

    vc summary = find_cur_msg(id);
    if(summary.is_nil())
    {
        return 0;
    }
    //if(summary[QM_IS_DIRECT].is_nil())
    {
        // server message waiting to be fetched
        if(summary[QM_SPECIAL_TYPE].is_nil())
        {
            return 0;
        }
        vc what = summary[QM_SPECIAL_TYPE];

        if(what == dlv)
        {
            if(what_out)
                *what_out = DWYCO_SUMMARY_DELIVERED;
            if(uid_out && len_uid_out)
            {
                *uid_out = (const char *)summary[QM_SPECIAL_TYPE_ARGS][0];
                *len_uid_out = summary[QM_SPECIAL_TYPE_ARGS][0].len();

            }
            if(dlv_mid_out)
            {
                *dlv_mid_out = (const char *)summary[QM_SPECIAL_TYPE_ARGS][1];
            }
            return 1;
        }
    }
    return 0;
}


// note: this function is pretty defunct, it assumes you are using
// simple 8bit ascii and won't generally work with utf8/unicode type
// situations. use get_body_array instead
DWYCOEXPORT
DWYCO_LIST
dwyco_get_body_text(DWYCO_SAVED_MSG_LIST m)
{
    vc& v = *(vc *)m;
    vc body = v[0];
    DwString s("");

    if(body[QM_BODY_FORWARDED_BODY].is_nil())
    {
        //s += "\r\n";
        s += (const char *)body[QM_BODY_NEW_TEXT];
    }
    else
    {
        // new display for new-style forwarded messages
        s += "(forwarded follows)\r\n";
        s += (const char *)body[QM_BODY_NEW_TEXT];
        s += "\r\n---\r\n";
        // this test keeps us from crashing on really old
        // messages.
        if(body.type() == VC_VECTOR)
            append_forwarded_text(s, body[QM_BODY_FORWARDED_BODY]);
    }

    vc v1(VC_VECTOR);
    v1[0] = vc(VC_BSTRING, s.c_str(), s.length());
    return dwyco_list_from_vc(v1);
}

//
// this version of the call returns a list of lists
// in the same way the directory functions do, except
// in this case, each entry in the list is a message
// component, containing all the FORWARDED components
// of the message. if the message has no forwarded parts,
// then just the top level message will be in the list.
// this allows you to format forwarded message in any
// way you want (instead of just being stuck with the
// formatting provided by dwyco_get_body_text.)
// each message is formatted in exactly the same way
// as a DWYCO_QM_BODY_...
//
DWYCOEXPORT
DWYCO_LIST
dwyco_get_body_array(DWYCO_SAVED_MSG_LIST m)
{
    vc& v = *(vc *)m;
    vc body = v[0];

    vc v1(VC_VECTOR);

    append_forwarded_bodies(v1, body);

    return dwyco_list_from_vc(v1);
}

DWYCOEXPORT
int
dwyco_authenticate_body(DWYCO_SAVED_MSG_LIST m, const char *recip_uid, int len_uid, int unsaved)
{
    vc& v = *(vc *)m;
    vc body = v[0];
    if(body[QM_BODY_SENT].is_nil())
    {
        return verify_chain(body, 1, vcnil, unsaved ? vc(".") : vcnil);
    }
    vc u(VC_BSTRING, recip_uid, len_uid);
    u = uid_to_dir(u);
    return verify_chain(body, 1, vcnil, u);
}

//
// m should be a regular message: vector(vector(recipients) msg-vec local-id)
//
int
save_msg(vc m, vc msg_id)
{
    if(m[QQM_MSG_VEC].is_nil())
    {
        return 0;
    }

    vc msg = m[QQM_MSG_VEC];

    if(msg.is_nil())
    {
        return 0;
    }

    vc body = save_body(msg_id,
                        msg[QQM_BODY_FROM],
                        "", //msg[QQM_BODY_TEXT],
                        msg[QQM_BODY_ATTACHMENT],
                        msg[QQM_BODY_DATE],
                        vcnil, //msg[QQM_BODY_RATING],
                        msg[QQM_BODY_AUTH_VEC],
                        msg[QQM_BODY_FORWARDED_BODY],
                        msg[QQM_BODY_NEW_TEXT],
                        msg[QQM_BODY_NO_FORWARD],
                        msg[QQM_BODY_FILE_ATTACHMENT],
                        msg[QQM_BODY_LOGICAL_CLOCK],
                        msg[QQM_BODY_SPECIAL_TYPE]);
    if(body.is_nil())
    {
        return 0;
    }

    if(msg[QQM_BODY_ATTACHMENT].is_nil())
    {
        update_msg_idx(vcnil, body);
        //ack_direct(msg_id);
        delete_msg2(msg_id);
        return 1;
    }
    // if the msg came directly, assume
    // the attachment was sent direct as well.
    if(!refile_attachment(msg[QQM_BODY_ATTACHMENT], msg[QQM_BODY_FROM]))
        return 0;
    update_msg_idx(vcnil, body);
    //ack_direct(msg_id);
    delete_msg2(msg_id);
    return 1;

}

static void
ack_get_done2(vc m, void *, vc del2_args, ValidPtr )
{
    // note: if the ack is ok, then we can
    // avoid an extra refresh, because the message
    // list was refreshed when the message
    // was originally deleted (set to pending)
    //int orig_refresh = Refresh_users;
    delete_msg2(del2_args[1]);
    //if(m[1].is_nil())
    //	return;
    //Refresh_users = orig_refresh;
}

static void
add_server_response_to_direct_list(BodyView *q, vc msg)
{
    vc dm(VC_VECTOR);
    dm[QQM_RECIP_VEC] = vc(VC_VECTOR);
    dm[QQM_RECIP_VEC][0] = My_UID;
    vc dmsg = msg;
    vc from = msg[QQM_BODY_FROM];
    if(!msg[QQM_BODY_DHSF].is_nil())
    {
        dmsg = decrypt_msg_body(msg);
        if(dmsg.is_nil())
        {
            // if we can't decrypt it, there is really something
            // wrong with the message, but it could be a lot of things
            // that we can't figure out easily (like the attachment
            // might be corrupt or truncated, our local private
            // key might have changed, etc.) chances are though, we
            // will never be able to decrypt it, so we might as well
            // delete it. if our key has gotten mucked up locally,
            // we may also *never* be able to decrypt tons of things
            // until the key is reset in the server.
            if(q->msg_download_callback)
                (*q->msg_download_callback)(q->vp, DWYCO_MSG_DOWNLOAD_DECRYPT_FAILED, q->msg_id, q->mdc_arg1);
            se_emit_msg(SE_MSG_DOWNLOAD_FAILED_PERMANENT_DELETED_DECRYPT_FAILED, q->msg_id, from);
            // note: don't ack it automatically, since we *might* be in a situation where we
            // are waiting for a group key. once the group key is installed we might be
            // able to decrypt it. tag the msg locally in case our key situation changes
            //dirth_send_ack_get2(My_UID, q->msg_id, QckDone(0, 0));
            sql_add_tag(q->msg_id, "_decrypt_failed");

            TRACK_ADD(MR_msg_decrypt_failed, 1);
            return;
        }
        else
        {
            TRACK_ADD(MR_msg_decrypt_ok, 1);
        }
    }
    dm[QQM_MSG_VEC] = dmsg;
    //dm[QQM_MSG_VEC] = msg[QQM_BODY_DHSF].is_nil() ? msg : decrypt_msg_body(msg);
    //note: generate a new id for the message in its
    // local form. there is a lot of code that
    // depends on deleting the old message id
    // after it is fetched from the server. so
    // we just pretend this is a brand new message.

    // note: the above confused people, just try to
    // morph it into a different kind of message without
    // changing the id
    dm[QQM_LOCAL_ID] = q->msg_id;

    // NOTE: need flag to avoid twiddling the
    // No_directs set, since this call isn't via
    // the direct channel.
    if(!q->msg_download_callback)
    {
        GRTLOG("no user defined msg_download_callback ", 0, 0);
    }
    if(store_direct(0, dm, 0) == -1)
    {
        if(q->msg_download_callback)
            (*q->msg_download_callback)(q->vp, DWYCO_MSG_DOWNLOAD_RATHOLED, q->msg_id, q->mdc_arg1);
        se_emit_msg(SE_MSG_DOWNLOAD_FAILED_PERMANENT_DELETED, q->msg_id, from);
        return;
    }

    if(q->msg_download_callback)
        (*q->msg_download_callback)(q->vp, DWYCO_MSG_DOWNLOAD_OK, q->msg_id, q->mdc_arg1);
    se_emit_msg(SE_MSG_DOWNLOAD_OK, q->msg_id, from);
    // note: just send ack_get, with no return, assume it always works.
    // if it doesn't work, it is no big deal, we just get a message
    // twice.
    dirth_send_ack_get2(My_UID, q->msg_id, QckDone(0, 0));
}

static void
eo_xfer(MMChannel *mc, vc m, void *, ValidPtr vp)
{
    // we can resume partial fetches now, so don't delete the attachment

    if(!vp.is_valid())
        return;
    BodyView *q = (BodyView *)(void *)vp;
    if(!q->msg_download_callback)
    {
        GRTLOG("no user defined msg_download_callback ", 0, 0);
    }
    q->xfer_channel = 0;
    if(mc->xfer_failed)
    {
        //q->MessageBox("Get failed, try again later.");
        if(q->msg_download_callback)
            (*q->msg_download_callback)((int)q->vp, DWYCO_MSG_DOWNLOAD_ATTACHMENT_FETCH_FAILED, q->msg_id, q->mdc_arg1);
        se_emit_msg(SE_MSG_DOWNLOAD_ATTACHMENT_FETCH_FAILED, q->msg_id, vcnil);
        q->cancel();
        delete q;
        return;
    }


#ifdef DWYCO_CRYPTO_PIPELINE
    if(!q->body[QQM_BODY_DHSF].is_nil())
    {
        DwString src, dst, key;

        q->dmsg = decrypt_msg_body2(q->body, src, dst, key);
        if(q->dmsg.is_nil())
        {
            add_server_response_to_direct_list(q, q->body);
            delete q;
            return;
        }
        add_to_pipeline(q, src, dst, key);
    }

#else
    add_server_response_to_direct_list(q, q->body);
    delete q;
#endif
}

static void
get_done(vc m, void *, vc msg_id, ValidPtr vp)
{
    if(!vp.is_valid())
        return;
    BodyView *q = (BodyView *)(void *)vp;
    if(!q->msg_download_callback)
    {
        GRTLOG("no user defined msg_download_callback ", 0, 0);
    }

    if(m[1].is_nil())
    {
        if(q->msg_download_callback)
            (*q->msg_download_callback)((int)q->vp, DWYCO_MSG_DOWNLOAD_FAILED, q->msg_id, q->mdc_arg1);
        se_emit_msg(SE_MSG_DOWNLOAD_FAILED, q->msg_id, vcnil);
        q->cancel();
        delete q;
        return;
    }
    // returned item is a vector of 2 items:
    // 0: msg id
    // 1: msg
    //	msg is a vector:
    // 0: sender id
    // 1: the text message
    // 2: id of any attachment
    // 3: date vector
    // 4: rating
    // 5: authvec
    // 6: forwarded body
    // 7: new text
    // 8: attachment loc
    // 9: special type

    vc msg = m[1][1];

    if(msg.is_nil())
    {
        //q->MessageBox("Can't find message on server.");
        if(q->msg_download_callback)
            (*q->msg_download_callback)((int)q->vp, DWYCO_MSG_DOWNLOAD_FAILED, q->msg_id, q->mdc_arg1);
        se_emit_msg(SE_MSG_DOWNLOAD_FAILED, q->msg_id, vcnil);
        q->cancel();
        delete q;
        return;
    }

    q->body = msg;
    vc from = msg[QQM_BODY_FROM];

    if(msg[QQM_BODY_ATTACHMENT].is_nil())
    {

        add_server_response_to_direct_list(q, msg);
        delete q;
        return;
    }

    if(msg[QQM_BODY_ATTACHMENT_LOCATION].type() != VC_VECTOR)
    {

        if(q->msg_download_callback)
            (*q->msg_download_callback)((int)q->vp, DWYCO_MSG_DOWNLOAD_ATTACHMENT_FETCH_FAILED, q->msg_id, q->mdc_arg1);
        se_emit_msg(SE_MSG_DOWNLOAD_ATTACHMENT_FETCH_FAILED, q->msg_id, from);
        q->cancel();
        delete q;
        return;
    }

    // need to fetch the attachment before saving
    // anything to the inbox.

    // else message came thru server, so
    // we fetch attachment from server, even tho
    // the vid might already be here, we don't
    // trust it for now.
    MMChannel *mc;
    vc ip = msg[QQM_BODY_ATTACHMENT_LOCATION][0];
    // this would normally be base + 1 (as set when the msg was stored)
    // we just add an offset to it to get the xfer new protocol
    vc port = msg[QQM_BODY_ATTACHMENT_LOCATION][1] + vc(DWYCO_SEND_FILE_PORT_OFFSET);
    // if the ip stored in the message isn't in our current set of
    // servers, just pick a random one and see if it is there. this
    // allows us to move attachment servers in some cases.
    if(!contains_xfer_ip(ip))
    {
        ip = get_random_xfer_server_ip(port);
        port = port + vc(1);
        port = port + vc(DWYCO_SEND_FILE_PORT_OFFSET);
    }
    if(!(mc = fetch_attachment(msg[QQM_BODY_ATTACHMENT], eo_xfer, m[1], 0, q->vp,
                               set_status, 0, q->vp, ip, port)))
    {
        if(q->msg_download_callback)
            (*q->msg_download_callback)((int)q->vp, DWYCO_MSG_DOWNLOAD_ATTACHMENT_FETCH_FAILED, q->msg_id, q->mdc_arg1);
        se_emit_msg(SE_MSG_DOWNLOAD_ATTACHMENT_FETCH_FAILED, q->msg_id, from);
        q->cancel();
        delete q;
        return;
    }
    if(q->msg_download_callback)
        (*q->msg_download_callback)((int)q->vp, DWYCO_MSG_DOWNLOAD_FETCHING_ATTACHMENT, q->msg_id, q->mdc_arg1);
    se_emit_msg(SE_MSG_DOWNLOAD_ATTACHMENT_FETCH_START, q->msg_id, from);
    q->xfer_channel = mc;

}

// "saving" a message now just means removing from the inbox
// which involves just removing the tag, unless it hasn't
// been fetched yet.
DWYCOEXPORT
int
dwyco_save_message(const char *msg_id)
{
    // NOTE: SERVER, check that it is a local message,
    // can't "save" a server message

    vc id(VC_BSTRING, msg_id, strlen(msg_id));
    vc summary = find_cur_msg(id);
    if(!summary.is_nil())
    {
        GRTLOG("save_message: msg isn't fetched %s", msg_id, 0);
        return 0;
    }

    if(sql_mid_has_tag(id, "_inbox"))
        Rescan_msgs = 1;
    sql_remove_mid_tag(id, "_inbox");
    return 1;
}

DWYCOEXPORT
int
dwyco_fetch_server_message(const char *msg_id, DwycoMessageDownloadCallback dcb, void *mdc_arg1, DwycoStatusCallback scb, void *scb_arg1)
{
    vc m(msg_id);

    if(BodyView::Bvqbm.exists_by_member(m, &BodyView::msg_id))
        return 0;

    BodyView *bv = new BodyView;

    bv->msg_id = m;
    bv->status_callback = scb;
    bv->scb_arg1 = scb_arg1;
    bv->msg_download_callback = dcb;
    bv->mdc_arg1 = mdc_arg1;
    dirth_send_get2(My_UID, bv->msg_id, QckDone(get_done, bv, bv->msg_id, bv->vp));
    se_emit_msg(SE_MSG_DOWNLOAD_START, m, vcnil);
    bv->progress_signal.connect_ptrfun(se_emit_msg_progress);
    return (int)bv->vp;
}

DWYCOEXPORT
void
dwyco_cancel_message_fetch(int fetch_id)
{
    ValidPtr p = cookie_to_ptr(fetch_id);
    if(p.is_valid())
    {
        BodyView *bv = (BodyView *)(void *)p;
        bv->cancel();
        delete bv;
        return;
    }
    GRTLOG("cancel_message_fetch: bad fetch id %d", fetch_id, 0);
}


// this api should probably go away.
// delete msg should probably just work no matter what
// state the message is in, on the server or whereever
DWYCOEXPORT
int
dwyco_delete_unfetched_message(const char *msg_id)
{
    vc id(msg_id);

    vc args(VC_VECTOR);
    args.append(vcnil);
    args.append(id);
    dirth_send_ack_get2(My_UID, id, QckDone(ack_get_done2, 0, args));
    dirth_send_addtag(My_UID, id, "_del", QckDone(0, 0));
    return 1;
}

DWYCOEXPORT
int
dwyco_delete_saved_message(const char *user_id, int len_uid, const char *msg_id)
{
    vc uid(VC_BSTRING, user_id, len_uid);
    vc mid(msg_id);
    delete_body3(uid, mid, 0);
    dirth_send_addtag(My_UID, mid, "_del", QckDone(0, 0));
    return 1;
}

// Pal list related stuff

DWYCOEXPORT
void
dwyco_pal_add(const char *user_id, int len_uid)
{
    vc uid(VC_BSTRING, user_id, len_uid);
    pal_add(uid);
}

DWYCOEXPORT
void
dwyco_pal_delete(const char *user_id, int len_uid)
{
    vc uid(VC_BSTRING, user_id, len_uid);
    pal_del(uid);
}

DWYCOEXPORT
int
dwyco_is_pal(const char *user_id, int len_uid)
{
    vc uid(VC_BSTRING, user_id, len_uid);
    return pal_user(uid);
}

DWYCOEXPORT
DWYCO_LIST
dwyco_pal_get_list()
{
    return dwyco_list_from_vc(pal_to_vector(1));
}

DWYCOEXPORT
void
dwyco_set_msg_tag(const char *mid, const char *tag)
{
    sql_add_tag(mid, tag);
}

DWYCOEXPORT
void
dwyco_unset_msg_tag(const char *mid, const char *tag)
{
    sql_remove_mid_tag(mid, tag);
}

DWYCOEXPORT
void
dwyco_unset_all_msg_tag(const char *tag)
{
    sql_remove_tag(tag);
}

DWYCOEXPORT
int
dwyco_get_tagged_mids(DWYCO_LIST *list_out, const char *tag)
{
    vc res = sql_get_tagged_mids(tag);
    *list_out = dwyco_list_from_vc(res);
    return 1;
}

DWYCOEXPORT
int
dwyco_get_tagged_mids2(DWYCO_LIST *list_out, const char *tag)
{
    vc res = sql_get_tagged_mids2(tag);
    *list_out = dwyco_list_from_vc(res);
    return 1;
}

DWYCOEXPORT
int
dwyco_get_tagged_idx(DWYCO_MSG_IDX *list_out, const char *tag)
{
    vc res;
    // super-kluge
    if(strcmp(tag, "*") == 0)
        res = sql_get_all_idx();
    else
        res = sql_get_tagged_idx(tag);
    *list_out = dwyco_list_from_vc(res);
    return 1;
}

DWYCOEXPORT
int
dwyco_mid_has_tag(const char *mid, const char *tag)
{
    return sql_mid_has_tag(mid, tag);
}

DWYCOEXPORT
int
dwyco_uid_has_tag(const char *uid, int len_uid, const char *tag)
{
    vc buid(VC_BSTRING, uid, len_uid);
    return sql_uid_has_tag(buid, tag);
}

DWYCOEXPORT
int
dwyco_uid_count_tag(const char *uid, int len_uid, const char *tag)
{
    vc buid(VC_BSTRING, uid, len_uid);
    return sql_uid_count_tag(buid, tag);
}

DWYCOEXPORT
int
dwyco_count_tag(const char *tag)
{
    return sql_count_tag(tag);
}


DWYCOEXPORT
void
dwyco_set_fav_msg(const char *mid, int fav)
{
    sql_fav_set_fav(mid, fav);
}

DWYCOEXPORT
int
dwyco_get_fav_msg(const char *mid)
{
    return sql_fav_is_fav(mid);
}

// INTERNAL API
DWYCOEXPORT
int
dwyco_run_sql(const char *stmt, const char *a1, const char *a2, const char *a3)
{
    vc s(stmt);
    vc va1 = (a1 ? vc(a1) : vcnil);
    vc va2 = (a2 ? vc(a2) : vcnil);
    vc va3 = (a3 ? vc(a3) : vcnil);
    return sql_run_sql(s, va1, va2, va3);
}

// ignore list stuff
int is_ignored_id_by_user(vc);
DWYCOEXPORT
int
dwyco_is_ignored(const char *user_id, int len_uid)
{
    vc uid(VC_BSTRING, user_id, len_uid);
    // note: this is a case where we don't want to allow
    // a user to know the mutual ignore list sent by the
    // server, so we just show them the ignores they have
    // set up explicitly

    return is_ignored_id_by_user(uid);
}

static void
ignore_done(vc m, void *t, vc id, ValidPtr)
{
    if(m[1].is_nil())
        return;
    add_ignore(id);
    //Refresh_users = 1;
}

DWYCOEXPORT
void
dwyco_ignore(const char *user_id, int len_uid)
{
    vc uid(VC_BSTRING, user_id, len_uid);
    add_ignore(uid);
    add_local_ignore(uid);
    //Refresh_users = 1;
    // NOTE: reinstate this when server-based ignore lists
    // arrive.
    //dirth_send_ignore(My_UID, uid, QckDone(ignore_done, 0, uid));

    // just get the assbase update, no other server storage is done
    dirth_send_ignore(My_UID, uid, QckDone());
}

static void
unignore_done(vc m, void *t, vc id, ValidPtr)
{
    if(m[1].is_nil())
        return;
    del_ignore(id);
    //Refresh_users = 1;
}

DWYCOEXPORT
void
dwyco_unignore(const char *user_id, int len_uid)
{
    vc uid(VC_BSTRING, user_id, len_uid);
    del_ignore(uid);
    del_local_ignore(uid);
    //Refresh_users = 1;
    dirth_send_unignore(My_UID, uid, QckDone(unignore_done, 0, uid));
}

DWYCOEXPORT
void
dwyco_session_ignore(const char *user_id, int len_uid)
{
    vc uid(VC_BSTRING, user_id, len_uid);
    Session_ignore.add(uid);
    //Refresh_users = 1;
}

DWYCOEXPORT
void
dwyco_session_unignore(const char *user_id, int len_uid)
{
    vc uid(VC_BSTRING, user_id, len_uid);
    Session_ignore.del(uid);
    //Refresh_users = 1;
}

DWYCOEXPORT
DWYCO_LIST
dwyco_ignore_list_get()
{
    return dwyco_list_from_vc(vc::set_to_vector(Cur_ignore));
}

DWYCOEXPORT
DWYCO_LIST
dwyco_session_ignore_list_get()
{
    return dwyco_list_from_vc(vc::set_to_vector(Session_ignore));
}

DWYCOEXPORT
void
dwyco_set_pals_only(int on)
{
    if(on)
    {
        chatq_send_pals_only(0, My_UID, vctrue);
        ZapAdvData.set_ignore(1);
    }
    else
    {
        chatq_send_pals_only(0, My_UID, vcnil);
        ZapAdvData.set_ignore(0);
    }
    ZapAdvData.save();
}

DWYCOEXPORT
int
dwyco_get_pals_only()
{
    return ZapAdvData.get_ignore();
}

#if 0
//
// this will use the given composer
// and text to generate a local message. the msgid of the message
// is saved, and when an auto-reply is triggered, that msg will be
// used if it can be found in the users folder.
// setting text to 0 or compid to 0 will remove the msgid, and cause
// autoreply to use a default msg.
//DWYCOEXPORT
//int
//dwyco_set_auto_reply_msg(const char *text, int len_text, int compid)
{
    if(text == 0 || compid == 0)
    {
        // delete autoreply msgid
        ZapAdvData.set_auto_reply_mid("");
        GRTLOG("removed auto-reply msgid", 0, 0);
        return 1;
    }
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("set_auto_reply: bad composer id (%d)", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    vc v(VC_VECTOR);
    v[0] = My_UID;
    m->rid_list = v;
    m->msg_text = DwString(text, 0, len_text);
    //m->message_send_callback = 0;
    //m->mscb_arg1 = 0;
    m->status_callback = 0;
    m->scb_arg1 = 0;
    m->no_forward = 0; // this is for auto-reply, so limiting forwarding is pointless
    m->send_buttonClick();
    // m->qfn has the file name
    vc msg = do_local_store(m->qfn.c_str(), vcnil);
    if(msg.is_nil())
    {
        GRTLOG("set_auto_reply: cant store local", 0, 0);
        return 0;
    }
    ZapAdvData.set_auto_reply_mid((char *)(const char *)msg[QM_BODY_ID]);
    m->forceClose();
    GRTLOG("set_auto_reply_msg: %d msg successfully saved.", compid, 0);
    return 1;
}
#endif


#if 0
static
void
DWYCOCALLCONV
auto_reply_msg_send_callback(int id, int what, const char *recip, int recip_len, const char *server_msg, void *arg)
{
    switch(what)
    {
    case DWYCO_MSG_SEND_OK:
        GRTLOG("auto reply sent  ok", /*(const char *)to_hex(vc(VC_BSTRING, recip, recip_len))*/ 0, 0);
        break;
    //case DWYCO_MSG_SEND_FAILED:
    //case DWYCO_MSG_ATTACHMENT_FAILED:
    //case DWYCO_MSG_IGNORED:
    //case DWYCO_MSG_ATTACHMENT_DECLINED:

    default:
        GRTLOG("auto reply failed to %s (%d)\n", (const char *)to_hex(vc(VC_BSTRING, recip, recip_len)), what);
        dwyco_delete_zap_composition((int)(long)arg);
        break;
    }
}
#endif

#if 0
int
perform_auto_reply(vc recip_uid)
{

    vc mid = get_settings_value("zap/auto_reply_mid");
    int send_default = 0;
    if(mid.is_nil() || mid.type() != VC_STRING || mid.len() == 0)
    {
        GRTLOG("perform_auto_reply: no auto_reply_mid", 0, 0);
        send_default = 1;
    }
    int compid;
    if(send_default)
        compid = dwyco_make_zap_composition(0);
    else
        compid = dwyco_make_forward_zap_composition((const char *)My_UID,
                 My_UID.len(), (const char *)mid, 1);
    if(compid == 0)
    {
        GRTLOG("perform_auto_reply: can't create  comp", 0, 0);
        return 0;
    }
    ValidPtr p = cookie_to_ptr(compid);
    if(!p.is_valid())
    {
        GRTLOG("perform_auto_reply: bad composer id (%d)", compid, 0);
        return 0;
    }
    TMsgCompose *m = (TMsgCompose *)(void *)p;
    m->dont_save_sent = 1;

    const char *msg = "This is an Auto-reply: Your message was not seen by the recipient. "
                      "When your message was delivered, the user was only accepting messages from pals.";
    int res = dwyco_zap_send4(compid, (const char *)recip_uid, recip_uid.len(),
                              msg, strlen(msg), 0, 0, 0);
    if(res == 0)
    {
        GRTLOG("perform_auto_reply: can't send message", 0, 0);
        dwyco_delete_zap_composition(compid);
        return 0;
    }
    return 1;
}
#endif


DWYCOEXPORT
DWYCO_LIST
dwyco_uid_to_info(const char *user_id, int len_uid, int* cant_resolve_now_out)
{
    if(cant_resolve_now_out)
        *cant_resolve_now_out = 0;
    vc uid(VC_BSTRING, user_id, len_uid);
    vc v(VC_VECTOR);
    vc ai = make_best_local_info(uid, cant_resolve_now_out);
    v.append(ai[0]);
    v.append(ai[2]);
    v.append(ai[1]);

    vc prf;
    if(load_profile(uid, prf))
    {
        v.append(prf[PRF_REVIEWED]);
        v.append(prf[PRF_REGULAR]);
        if(uid == My_UID)
            v.append(UserConfigData.get_email());
        else
            v.append("");
    }
    else
    {
        v.append(0);
        v.append(0);
        v.append("");
    }

    vc v1(VC_VECTOR);
    v1[0] = v;
    return dwyco_list_from_vc(v1);
}

//
// access functions for dwyco vector structures.
// after a bit of thought, i've decided to have
// the external users of this library send in
// special cookies that tell where to fetch fields
// (rather than flattening the structures and
// letting them use integers.) the reason for this
// is that the special cookies should work in OLD
// software, even if i change the structures in
// NEW software. basically, it allows more wiggle
// room to make changes in the data structures, and
// keep the old stuff still working with new changes.
//
// so, to access a list, the column is a string of this
// form: (nnn)*
// where n is [0-9].
//
// to fetch something at column 0, the string is 000
// if that item is a vector, and you want the first
// item in that vector, the string is 000000,
// for the next one, 000001, etc.
//
//
int
dwyco_get_next_idx(const char *& is)
{
    int i = (is[0] - '0') * 100 + (is[1] - '0') * 10 + (is[2] - '0');
    is += 3;
    return i;
}


DWYCO_LIST
dwyco_list_from_vc(vc vec)
{
    // vec is either a 1-d or 2-d vector that
    // can be indexed.
    vc *v = new vc(vec);
    return (DWYCO_LIST)v;
}

void
internal_list_release(DWYCO_LIST l)
{
    vc *v = (vc *)l;
    delete v;
}

// different entry point name because we don't want debug
// reports for non-user generated releases
DWYCOEXPORT
void
dwyco_list_release(DWYCO_LIST l)
{
    internal_list_release(l);
}

DWYCOEXPORT
int
dwyco_list_numelems(DWYCO_LIST l, int *rows_out, int *cols_out)
{
    vc& v = *(vc *)l;
    if(v.type() != VC_VECTOR)
        return 0;
    *rows_out = v.num_elems();
    if(!cols_out)
        return 1;
    if(*rows_out == 0)
    {
        *cols_out = -1;
        return 1;
    }
    if(v[0].type() != VC_VECTOR)
    {
        *cols_out = -1;
        return 1;
    }
    *cols_out = v[0].num_elems();
    return 1;

}

DWYCOEXPORT
int
dwyco_list_get(DWYCO_LIST l, int row, const char *col, const char **val_out, int *len_out, int *type_out)
{
    vc& v = *(vc *)l;
    if(v.type() != VC_VECTOR)
        return 0;
    if(row < 0 || row >= v.num_elems())
    {
        // don't allow indexing past the end, in the past
        // we allowed this, and it just returned nil, but
        // that can cause some problems
        oopanic("index past the end of dwyco list");
    }
    vc vec = v[row];
    while(*col)
    {
        if(vec.type() != VC_VECTOR)
            return 0;
        int i = dwyco_get_next_idx(col);
        vec = vec[i];
    }
    if(vec.type() == VC_INT)
    {
        *val_out = vec.peek_str();
        *len_out = strlen(vec.peek_str());
    }
    else if(vec.type() == VC_VECTOR)
    {
        // if we stopped on a vector, that usually means
        // something isn't being flattened right, or there is
        // something internal we don't want to show the user.
        // emit a warning and just return nil in this case.
        *val_out = "nil";
        *len_out = vec.num_elems();
        *type_out = DWYCO_TYPE_NIL;
        GRTLOG("shouldn't be fetching VECTOR from dwyco_list", 0, 0);
        return 1;
    }
    else
    {
        *val_out = (const char *)vec;
        *len_out = vec.len();
    }
    switch(vec.type())
    {
    case VC_INT:
        *type_out = DWYCO_TYPE_INT;
        break;
    case VC_STRING:
    case VC_BSTRING:
        *type_out = DWYCO_TYPE_STRING;
        break;
    case VC_NIL:
        *type_out = DWYCO_TYPE_NIL;
        break;
    case VC_VECTOR:
        *type_out = DWYCO_TYPE_VECTOR;
        break;
    default:
        *type_out = DWYCO_TYPE_NIL;
    }
    return 1;
}

DWYCOEXPORT
int
dwyco_list_print(DWYCO_LIST l)
{
    vc &v = *(vc *)l;
    vc_composite::new_dfs();
    v.printOn(VcError);
    return 1;
}

DWYCOEXPORT
DWYCO_LIST
dwyco_list_copy(DWYCO_LIST l)
{
    vc &v = *(vc *)l;
    vc c = v.copy();
    return dwyco_list_from_vc(c);
}

DWYCOEXPORT
DWYCO_LIST
dwyco_list_new()
{
    vc v(VC_VECTOR);
    return dwyco_list_from_vc(v);
}

DWYCOEXPORT
void
dwyco_list_append(DWYCO_LIST l, const char *val, int len, int type)
{
    vc &v = *(vc *)l;
    switch(type)
    {
    default:
    case DWYCO_TYPE_NIL:
        v.append(vcnil);
        break;
    case DWYCO_TYPE_STRING:
        v.append(vc(VC_BSTRING, val, len));
        break;
    case DWYCO_TYPE_INT:
        v.append(vc(VC_INT, val, 0));
        break;
    }
}

DWYCOEXPORT
void
dwyco_list_append_int(DWYCO_LIST l, int i)
{
    vc &v = *(vc *)l;
    vc vi(i);
    v.append(vi);
}

DWYCOEXPORT
void
dwyco_list_to_string(DWYCO_LIST l, const char **str_out, int *len_out)
{
    vc &v = *(vc *)l;
    *str_out = "";
    *len_out = 0;
    vc s = serialize(v);
    char *b = new char[s.len()];
    memcpy(b, (const char *)s, s.len());
    *str_out = b;
    *len_out = s.len();
}

DWYCOEXPORT
int
dwyco_list_from_string(DWYCO_LIST *list_out, const char *str, int len_str)
{
    vc v(VC_BSTRING, str, len_str);
    vc res;
    if(!deserialize(v, res))
        return 0;
    *list_out = dwyco_list_from_vc(res);
    return 1;
}






// this interface has gone from windows specific
// to a simple encapsulation of various video capture
// setups, including non-windows stuff. this only encapsulates
// the device selection, start/stop the device, source adjustment dialogs,
// hardware previewing.
//
// in windows,
//		* compile with VIDGRAB_HACKS (this
//		causes the DLL to setup the vg stuff internally.)
//		* you can switch between regular VFW (the default)
//		and "external" video acquisition (which encapsulates the
//		VidGrab library, which does DirectX 9 capture.)
//
// in linux and macos, there is obviously no VFW.
// if the client needs video capture, it must provide a video capture implementation.
// it sets the implemention using the "set_external_video_capture" functions.
// (video capture varies a *lot* in its
// functionality and robustness on various platforms, so the actual function of the
// API varies a bit and usually needs to be tweaked.)
//
// in macosx link with macdrv.a, which is compiled externally using xcode on the mac. the client calls "init_mac_drivers" to initialize things.
// likewise with LINUX, linke with v4lcap.a and call the external setup functions.
//
// on windows, compiling with DWYCO_NO_VIDEO_CAPTURE eliminates VFW and
// the internal setup of DX9. this is
// useful for debugging since video capture can be a problem in some environments.

#ifdef DWYCO_NO_VIDEO_CAPTURE
#undef USE_VFW
#else
#ifdef __WIN32__
// NOTE: this interface is WINDOWS SPECIFIC
#ifdef USE_VFW
#include "vfwdll.h"
#endif
#ifdef VIDGRAB_HACKS
#include "vgexp.h"
#endif
#endif
#endif

// video device control
DwycoCACallback dwyco_vidacq_get_vid_devices;
DwycoFCACallback dwyco_vidacq_free_vid_list;
DwycoVICallback dwyco_vidacq_set_vid_device;
DwycoVCallback dwyco_vidacq_stop_vid_device;
DwycoVCallback dwyco_vidacq_show_source_dialog;
DwycoVVCallback dwyco_vidacq_hw_preview_on;
DwycoVCallback dwyco_vidacq_hw_preview_off;
DwycoVVCallback dwyco_vidacq_set_app_data;

DWYCOEXPORT
DWYCO_LIST
dwyco_get_vfw_drivers()
{
    if(ExternalVideoAcquisition)
    {
        char **d = 0;
        if(dwyco_vidacq_get_vid_devices)
            d = (*dwyco_vidacq_get_vid_devices)();
        else
        {
            vc v(VC_VECTOR);
            return dwyco_list_from_vc(v);
        }
        char **tmp = d;
        int i = 0;
        vc v(VC_VECTOR);
        while(*d)
        {
            vc v2(VC_VECTOR);
            v2[0] = i++;
            v2[1] = *d;
            v2[2] = "unknown";
            ++d;
            v.append(v2);
        }
        if(dwyco_vidacq_free_vid_list)
            (*dwyco_vidacq_free_vid_list)(tmp);
        return dwyco_list_from_vc(v);
    }

#if defined(__WIN32__) && defined(USE_VFW)
    char szDeviceName[80];
    char szDeviceVersion[80];
    vc v(VC_VECTOR);

    for (int wIndex = 0; wIndex < 10; wIndex++) {
        if (capGetDriverDescription (wIndex, szDeviceName,
                                     sizeof (szDeviceName), szDeviceVersion,
                                     sizeof (szDeviceVersion)))
        {
            vc v2(VC_VECTOR);
            v2[0] = wIndex;
            v2[1] = szDeviceName;
            v2[2] = szDeviceVersion;
            v.append(v2);
        }
    }
    return dwyco_list_from_vc(v);
#endif
    return 0;
}

DWYCOEXPORT
int
dwyco_start_vfw(int idx, void *main_hwnd, void *client_hwnd)
{
    if(ExternalVideoAcquisition)
    {
        if(dwyco_vidacq_set_vid_device)
            (*dwyco_vidacq_set_vid_device)(idx);
        return 1;
    }
#if defined(__WIN32__) && defined(USE_VFW)
    return VFWShitDLL::fire_up_vfw(idx, (HWND)main_hwnd, (HWND)client_hwnd);
#else
    return 0;
#endif
}

DWYCOEXPORT
int
dwyco_shutdown_vfw()
{
    if(ExternalVideoAcquisition)
    {
        // this is a problem, don't stop the device unless it has
        // been initialized... really need something reasonable
        // in this area (either make stop_video innocuous if it hasn't
        // been initted, or define wtf it means to have the device
        // initialized
        if(TheAq)
        {
            if(dwyco_vidacq_stop_vid_device)
                (*dwyco_vidacq_stop_vid_device)();
        }
        return 1;
    }
#if defined(__WIN32__) && defined(USE_VFW)
    return VFWShitDLL::shutdown_vfw();
#endif
    return 0;
}

DWYCOEXPORT
int
dwyco_change_driver(int new_idx)
{
    if(ExternalVideoAcquisition)
    {
        if(dwyco_vidacq_set_vid_device)
            (*dwyco_vidacq_set_vid_device)(new_idx);
        return 1;
    }
#if defined(__WIN32__) && defined(USE_VFW)
    if(!TheVFWMgr)
        return 0;
    return TheVFWMgr->change_driver(new_idx);
#endif
    return 0;
}

DWYCOEXPORT
int
dwyco_is_preview_on()
{
#if defined(__WIN32__) && defined(USE_VFW)
    if(!TheVFWMgr)
        return 0;
    return TheVFWMgr->is_preview_on();
#endif
    return 0;
}

DWYCOEXPORT
int
dwyco_preview_on(void *display_window)
{
    if(ExternalVideoAcquisition)
    {
        if(dwyco_vidacq_hw_preview_on)
            (*dwyco_vidacq_hw_preview_on)(display_window);
        return 1;
    }
#if defined(__WIN32__) && defined(USE_VFW)
    if(!TheVFWMgr)
        return 0;
    ((VFWShitDLL *)TheVFWMgr)->ext_child_hwnd = (HWND)display_window;
    return TheVFWMgr->start_preview();
#endif
    return 0;
}

DWYCOEXPORT
int
dwyco_preview_off()
{
    if(ExternalVideoAcquisition)
    {
        if(dwyco_vidacq_hw_preview_off)
            (*dwyco_vidacq_hw_preview_off)();
        return 1;
    }
#if defined(__WIN32__) && defined(USE_VFW)
    if(!TheVFWMgr)
        return 1;
    TheVFWMgr->preview_off();
    return 1;
#endif
    return 0;
}

DWYCOEXPORT
int
dwyco_vfw_format()
{
    if(ExternalVideoAcquisition)
    {
        // for testing, no need to change format
        // since it is setup automatically.
        return 1;
    }
#if defined(__WIN32__) && defined(USE_VFW)
    if(!TheVFWMgr)
        return 0;
    return TheVFWMgr->change_format();
#endif
    return 0;
}

DWYCOEXPORT
int
dwyco_vfw_source()
{
    if(ExternalVideoAcquisition)
    {
        if(dwyco_vidacq_show_source_dialog)
            (*dwyco_vidacq_show_source_dialog)();
        return 1;
    }
#if defined(__WIN32__) && defined(USE_VFW)
    if(!TheVFWMgr)
        return 0;
    return TheVFWMgr->source_clicked();
#endif
    return 0;
}

DWYCOEXPORT
int
dwyco_set_external_video(int v)
{
    dwyco_shutdown_vfw();
    if(v)
    {
        if(dwyco_vidacq_set_app_data)
            (*dwyco_vidacq_set_app_data)(0);
    }
    ExternalVideoAcquisition = v;
    return 1;
}

#ifdef _Windows
// this interface is to capture certain messages
// the DLL needs to know about for doing asynch
// dns lookups, and entropy culling, etc.
// windows specific

DWYCOEXPORT
void
dwyco_set_main_msg_window(void *w)
{
    Main_window = (HWND)w;
    //Main_window = ::GetActiveWindow();


}

DWYCOEXPORT
void
dwyco_handle_msg(const char *msg, int len_msg, unsigned int message, unsigned int wp, unsigned int lp)
{
    if(message == WM_USER + 400)
    {

        //GRTLOG("network msg %d %d", (int)Msg.wParam, (int)Msg.lParam);
        async_handler(wp, lp);
    }
    else if(message == WM_USER + 402)
    {
        async_lookup_handler((HANDLE)wp, lp);
    }
    add_entropy_timer((char *)msg, len_msg);

}


#endif

// EXTERNAL VIDEO CAPTURE INTERFACE

DwycoVVCallback dwyco_vidacq_new;
DwycoVVCallback dwyco_vidacq_delete;
DwycoIVICallback dwyco_vidacq_init;
DwycoIVCallback dwyco_vidacq_has_data;
DwycoVVCallback dwyco_vidacq_need;
DwycoVVCallback dwyco_vidacq_pass;
DwycoVVCallback dwyco_vidacq_stop;
DwycoVidGetDataCallback dwyco_vidacq_get_data;
DwycoVVCallback dwyco_vidacq_free_data;

// sorry about the run-on arg list, but the tracing stuff
// really wants this all on one line.
DWYCOEXPORT
void
dwyco_set_external_video_capture_callbacks( DwycoVVCallback nw, DwycoVVCallback del, DwycoIVICallback init, DwycoIVCallback has_data, DwycoVVCallback need, DwycoVVCallback pass, DwycoVVCallback stop, DwycoVidGetDataCallback get_data, DwycoVVCallback free_data, DwycoCACallback get_vid_devices, DwycoFCACallback free_vid_list, DwycoVICallback set_vid_device, DwycoVCallback stop_vid_device, DwycoVCallback show_source_dialog, DwycoVVCallback hw_preview_on, DwycoVCallback hw_preview_off, DwycoVVCallback set_app_data)
{
    dwyco_vidacq_new = nw;
    dwyco_vidacq_delete = del;
    dwyco_vidacq_init = init;
    dwyco_vidacq_has_data = has_data;
    dwyco_vidacq_need = need;
    dwyco_vidacq_pass = pass;
    dwyco_vidacq_stop = stop;
    dwyco_vidacq_get_data = get_data;
    dwyco_vidacq_free_data = free_data;

    dwyco_vidacq_get_vid_devices = get_vid_devices;
    dwyco_vidacq_free_vid_list = free_vid_list;
    dwyco_vidacq_set_vid_device = set_vid_device;
    dwyco_vidacq_stop_vid_device = stop_vid_device;
    dwyco_vidacq_show_source_dialog = show_source_dialog;
    dwyco_vidacq_hw_preview_on = hw_preview_on;
    dwyco_vidacq_hw_preview_off = hw_preview_off;
    dwyco_vidacq_set_app_data = set_app_data;


}

DwycoVVIICallback dwyco_audacq_new;
DwycoVVCallback dwyco_audacq_delete;
DwycoIVCallback dwyco_audacq_init;
DwycoIVCallback dwyco_audacq_has_data;
DwycoVVCallback dwyco_audacq_need;
DwycoVVCallback dwyco_audacq_pass;
DwycoVVCallback dwyco_audacq_stop;
DwycoVVCallback dwyco_audacq_on;
DwycoVVCallback dwyco_audacq_off;
DwycoVVCallback dwyco_audacq_reset;
DwycoIVCallback dwyco_audacq_status;
DwycoAudGetDataCallback dwyco_audacq_get_data;

DWYCOEXPORT
void
dwyco_set_external_audio_capture_callbacks( DwycoVVIICallback nw, DwycoVVCallback del, DwycoIVCallback init, DwycoIVCallback has_data, DwycoVVCallback need, DwycoVVCallback pass, DwycoVVCallback stop, DwycoVVCallback on, DwycoVVCallback off, DwycoVVCallback reset, DwycoIVCallback status, DwycoAudGetDataCallback get_data)
{
    dwyco_audacq_new = nw;
    dwyco_audacq_delete = del;
    dwyco_audacq_init = init;
    dwyco_audacq_has_data = has_data;
    dwyco_audacq_need = need;
    dwyco_audacq_pass = pass;
    dwyco_audacq_stop = stop;
    dwyco_audacq_on = on;
    dwyco_audacq_off = off;
    dwyco_audacq_reset = reset;
    dwyco_audacq_status = status;
    dwyco_audacq_get_data = get_data;
}

// external Audio Output interface

DwycoVVCallback dwyco_audout_new;
DwycoVVCallback dwyco_audout_delete;
DwycoIVCallback dwyco_audout_init;
DwycoDevOutputCallback dwyco_audout_output;
DwycoDevDoneCallback dwyco_audout_done;
DwycoIVCallback dwyco_audout_stop;
DwycoIVCallback dwyco_audout_reset;
DwycoIVCallback dwyco_audout_status;
DwycoIVCallback dwyco_audout_close;
DwycoIICallback dwyco_audout_buffer_time;
DwycoIVCallback dwyco_audout_play_silence;
DwycoIVCallback dwyco_audout_bufs_playing;

DWYCOEXPORT
void
dwyco_set_external_audio_output_callbacks( DwycoVVCallback nw, DwycoVVCallback del, DwycoIVCallback init, DwycoDevOutputCallback output, DwycoDevDoneCallback done, DwycoIVCallback stop, DwycoIVCallback reset, DwycoIVCallback status, DwycoIVCallback close, DwycoIICallback buffer_time, DwycoIVCallback play_silence, DwycoIVCallback bufs_playing)
{
    dwyco_audout_new = nw ;
    dwyco_audout_delete = del ;
    dwyco_audout_init = init ;
    dwyco_audout_output = output ;
    dwyco_audout_done = done ;
    dwyco_audout_stop = stop ;
    dwyco_audout_reset = reset ;
    dwyco_audout_status = status ;
    dwyco_audout_close = close ;
    dwyco_audout_buffer_time = buffer_time ;
    dwyco_audout_play_silence = play_silence ;
    dwyco_audout_bufs_playing = bufs_playing ;
}

// Auto-update functionality for desktop clients

static void
check_for_update_done(vc m, void *, vc, ValidPtr p)
{
    if(!autoupdate_status_callback)
        return;

    TAutoUpdate *q;
    const char *desc = 0;
    int status;

    if(!p.is_valid())
        q = 0;
    else
        q = (TAutoUpdate *)(void *)p;

    if(m[1].is_nil())
    {
        status = DWYCO_AUTOUPDATE_CHECK_FAILED;
    }
    else if(m[1].type() == VC_STRING && m[1] == vc("t"))
    {
        status = DWYCO_AUTOUPDATE_CHECK_NOT_NEEDED;
    }
    else if(m[1].type() != VC_VECTOR)
        return;
    else
    {
        status = DWYCO_AUTOUPDATE_CHECK_AVAILABLE;
        vc patch = m[1];
        // vector(desc type file version cur-hash new-hash sig nil nil nil vector(ip port))
        desc = (const char *)patch[0];
        if(patch[1] == vc("compulsory1"))
            status = DWYCO_AUTOUPDATE_CHECK_AVAILABLE_COMPULSORY1;
        else if(patch[1] == vc("compulsory2"))
            status = DWYCO_AUTOUPDATE_CHECK_AVAILABLE_COMPULSORY2;
        else if(patch[1] == vc("user1"))
            status = DWYCO_AUTOUPDATE_CHECK_USER1;
        else if(patch[1] == vc("user2"))
            status = DWYCO_AUTOUPDATE_CHECK_USER2;

        if(q)
        {
            q->patch = patch;
            if(patch[1] == vc("compulsory1"))
                q->compulsory = 1;
            else if(patch[1] == vc("compulsory2"))
                q->compulsory = 2;
            else if(patch[1] == vc("user1"))
                q->compulsory = 3;
            else if(patch[1] == vc("user2"))
                q->compulsory = 4;
        }
    }
    (*autoupdate_status_callback)(status, desc);
}

static int
bounce_autoupdate_available(MMChannel *, vc m, vc, vc)
{
    static int doneit;
    if(doneit)
        return 0;
    ++doneit;
    TAutoUpdate *q = TheAutoUpdate;
    q->check_results = m;
    check_for_update_done(m, 0, vcnil, TheAutoUpdate->vp);
    return 1;
}

DWYCOEXPORT
void
dwyco_force_autoupdate_check()
{
    dirth_send_check_for_update(My_UID, QckDone(check_for_update_done, 0, vcnil, TheAutoUpdate->vp));
}

DWYCOEXPORT
void
dwyco_set_autoupdate_status_callback(DwycoAutoUpdateStatusCallback sb)
{
    autoupdate_status_callback = sb;
}

DWYCOEXPORT
int
dwyco_start_autoupdate_download(DwycoStatusCallback cb, void *arg1, DwycoAutoUpdateDownloadCallback dcb)
{
    return TheAutoUpdate->fetch_update(cb, arg1, dcb);
}

DWYCOEXPORT
int
dwyco_start_autoupdate_download_bg()
{
    return TheAutoUpdate->fetch_update_background();
}

DWYCOEXPORT
int
dwyco_run_autoupdate()
{
    return TheAutoUpdate->run();
}

DWYCOEXPORT
void
dwyco_abort_autoupdate_download()
{
    TheAutoUpdate->abort_fetch();
}

// must call dwyco_free_array on returned pointer
extern vc STUN_server;
DWYCOEXPORT
void
dwyco_network_diagnostics2(char **report_out, int *len_out)
{
    DwString res;
    int num_adapters;
    res = "";
//	rfc3489(STUN_server, num_adapters, res);
    res += "\r\nmy connection: ";
    res += (const char *)My_connection;

    *report_out = new char[res.length()];
    *len_out = res.length();
    memcpy(*report_out, res.c_str(), res.length());
}

DWYCOEXPORT
void
dwyco_estimate_bandwidth2(int *out_bw_out, int *in_bw_out)
{
    DwString out_res;
    DwString in_res;
    long bwo = simple_bw_out(out_res);
    long bwi = simple_bw_in(in_res);
    if(out_bw_out)
        *out_bw_out = bwo;
    if(in_bw_out)
        *in_bw_out = bwi;
}

DWYCOEXPORT
void
dwyco_set_alert(const char *uid, int len_uid, int val)
{
    vc u(VC_BSTRING, uid, len_uid);
    if(val)
        online_noise_add(u);
    else
        online_noise_del(u);
}

DWYCOEXPORT
int
dwyco_get_alert(const char *uid, int len_uid)
{
    vc u(VC_BSTRING, uid, len_uid);
    return online_noise(u);
}


#include "fetch_to_inbox.h"
#ifndef WIN32
#include "poll.h"
#include <pthread.h>
// this is a simple condition variable we use to signal
// the java stuff to re-check for messages (so it can post
// a notification.)
static pthread_cond_t Msg_cond = PTHREAD_COND_INITIALIZER;
static pthread_mutex_t Msg_cond_mutex = PTHREAD_MUTEX_INITIALIZER;
#endif

DWYCOEXPORT
void
dwyco_signal_msg_cond()
{
#ifndef WIN32
    pthread_mutex_lock(&Msg_cond_mutex);
    pthread_cond_signal(&Msg_cond);
    pthread_mutex_unlock(&Msg_cond_mutex);
#endif

}

// the java stuff calls into this in another thread
// when we signal, it means a new message has arrived
DWYCOEXPORT
void
dwyco_wait_msg_cond(int ms)
{
#ifndef WIN32
    pthread_mutex_lock(&Msg_cond_mutex);
    pthread_cond_wait(&Msg_cond, &Msg_cond_mutex);
    pthread_mutex_unlock(&Msg_cond_mutex);
#endif

}


// this is just a goofy way to keep this background
// processing from interfering with the UI (which does
// its own processing for everything.)

// return -1 if there is some error
// return 0 if the port appears locked
// return 1 is the port looks unlocked
DWYCOEXPORT
int
dwyco_test_funny_mutex(int port)
{
#ifdef WIN32
    if(vc_winsock::startup() == 0)
        return -1;
#endif
    int s = socket(AF_INET, SOCK_STREAM,  0);
    if(s == -1)
        return -1;
#ifdef WIN32
    {
        u_long on = 1;
        if(ioctlsocket(s, FIONBIO, &on) != 0)
            return -1;
    }
#else
    if(fcntl(s, F_SETFL, O_NONBLOCK) == -1)
        return -1;
#endif
    struct sockaddr_in sap;
    memset(&sap, 0, sizeof(sap));
    sap.sin_family = AF_INET;
    sap.sin_addr.s_addr = inet_addr("127.0.0.1");
    sap.sin_port = htons(port);
    int i;
    for(i = 0; i < 2; ++i)
    {
        if(bind(s, (struct sockaddr *)&sap, sizeof(sap)) == -1)
        {
#ifdef WIN32
            int e = WSAGetLastError();
            if(e == WSAEADDRINUSE)
            {
                SleepEx(10, 0);
                continue;
            }
            closesocket(s);
#else
            if(errno == EADDRINUSE)
            {
                usleep(10000);
                continue;
            }
            close(s);
#endif

            return -1;
        }
        else
            break;
    }
#ifdef WIN32
        closesocket(s);
#else
        close(s);
#endif
    if(i == 2)
    {
        return 0;
    }

    return 1;
}

static
int
get_funny_mutex(int port)
{
#ifdef WIN32
    if(vc_winsock::startup() == 0)
        return -1;
#endif
    int s = socket(AF_INET, SOCK_STREAM,  0);
    if(s == -1)
        return -1;
#ifdef WIN32
    {
        u_long on = 1;
        if(ioctlsocket(s, FIONBIO, &on) != 0)
            return -1;
    }
#else
    if(fcntl(s, F_SETFL, O_NONBLOCK) == -1)
        return -1;
#endif
    struct sockaddr_in sap;
    memset(&sap, 0, sizeof(sap));
    sap.sin_family = AF_INET;
    sap.sin_addr.s_addr = inet_addr("127.0.0.1");
    sap.sin_port = htons(port);
    int i;
    const int tries = 100;
    for(i = 0; i < tries; ++i)
    {
        if(bind(s, (struct sockaddr *)&sap, sizeof(sap)) == -1)
        {
#ifdef WIN32
            int e = WSAGetLastError();
            if(e == WSAEADDRINUSE)
            {
                SleepEx(10, 0);
                continue;
            }
            closesocket(s);
#else
            if(errno == EADDRINUSE)
            {
                usleep(10000);
                continue;
            }
            close(s);
#endif

            return -1;
        }
        else
            break;
    }
    if(i == tries)
    {
#ifdef WIN32
        closesocket(s);
#else
        close(s);
#endif
        return -1;
    }
    if(listen(s, 5) == -1)
    {
#ifdef WIN32
        closesocket(s);
#else
        close(s);
#endif
        return -1;
    }
    return s;
}

static
void
DWYCOCALLCONV
dwyco_background_db_login_result(const char *str, int what)
{
    if(what == 0)
    {
        // exit the process since there isn't anything more
        // we can do really, unless there are direct connects...
        // if there are no direct connections, for sure quit
        GRTLOG("bg db login fail %s", str, 0);
    }
    else
    {
        GRTLOG("bg db login ok", 0, 0);
    }
}


DWYCOEXPORT
int
dwyco_background_processing(int port, int exit_if_outq_empty, const char *sys_pfx, const char *user_pfx, const char *tmp_pfx, const char *token)
{
#ifndef WIN32
    signal(SIGPIPE, SIG_IGN);
#endif
    //alarm(3600);
    srand(time(0));

    int s;
    s = get_funny_mutex(port);
    // first run, if the UI is blocking us, something is wrong
    if(s == -1)
        return 1;

    //dwyco_set_login_result_callback(dwyco_db_login_result);
    dwyco_set_fn_prefixes(sys_pfx, user_pfx, tmp_pfx);

    // quick check, and nothing else
    if(exit_if_outq_empty == 2)
    {
        int tmp = msg_outq_empty();
        close(s);
        return tmp;
    }

    dwyco_set_client_version("dwycobg", 7);
    dwyco_set_initial_invis(1);
    dwyco_set_login_result_callback(dwyco_background_db_login_result);
    dwyco_bg_init();
    if(token)
        dwyco_write_token(token);

    set_listen_state(0);
    // for now, don't let any channels get setup via the
    // server ... not strictly necessary, but until we get the
    // calling stuff sorted out (needs a protocol change to alert
    // regarding incoming calls, etc.) we just let everything go
    // via the server.
    dwyco_inhibit_sac(1);
    dwyco_inhibit_pal(1);

    if(dwyco_get_create_new_account())
    {
        // only run on existing accounts
        return 1;
    }

    dwyco_set_local_auth(1);
    dwyco_finish_startup();

    //int comsock = -1;
    vc asock = vc(VC_SOCKET_STREAM);
    asock.socket_init(s, vctrue);
    dwyco_signal_msg_cond();
    int signaled = 0;
    int started_fetches = 0;
    while(1)
    {
        int spin = 0;
        int snooze = dwyco_service_channels(&spin);
        if(exit_if_outq_empty && msg_outq_empty())
            break;
#ifdef WIN32
        if(accept(s, 0, 0) != INVALID_SOCKET)
        {
            break;
        }
        else
        {
            int e = WSAGetLastError();
            if(e != WSAEWOULDBLOCK)
                return 1;
        }
#else
        if(accept(s, 0, 0) != -1)
        {
            break;
        }
        else if(!(errno == EWOULDBLOCK || errno == EAGAIN))
            return 1;
#endif
        if(dwyco_get_rescan_messages())
        {
            GRTLOG("rescan %d %d", started_fetches, signaled);
            dwyco_set_rescan_messages(0);
            ns_dwyco_background_processing::fetch_to_inbox();
            GRTLOG("rescan2 %d %d", started_fetches, signaled);
            int tmp;
            if((tmp = sql_count_tag("_inbox")) > signaled)
            {
                GRTLOG("signaling newcount %d", tmp, 0);
                signaled = tmp;
                dwyco_signal_msg_cond();
            }
        }
        // note: this is a bit sloppy... rather than trying to
        // identify each socket that is waiting for write and
        // creating an exact poll call to check for that, we just
        // check to see if there is anything waiting to write
        // and just check a little more often. since this is a situation
        // that is pretty rare, it shouldn't be a huge problem (i hope.)
        if(spin || Response_q.num_elems() > 0 ||
                MMChannel::any_ctrl_q_pending() || SimpleSocket::any_waiting_for_write())
        {
            GRTLOG("spin %d short sleep", spin, 0);
#ifdef WIN32
            SleepEx(100, 0);
#else
            usleep(100000);
#endif
        }
        else
        {
            //usleep(500000);
            Socketvec res;

            int secs = snooze / 1000;
            // avoid problems with overflow, there is nothing here
            // that requires usec accuracy
            int usecs = (snooze % 1000) * 1000;
            GRTLOG("longsleep %d %d", secs, usecs);
            int n = vc_winsock::poll_all(VC_SOCK_READ, res, secs, usecs);
            GRTLOG("wakeup %d", n, 0);
            if(n < 0)
                return 1;

            for(int i = 0; i < res.num_elems(); ++i)
            {
                if(asock.socket_local_addr() == res[i]->socket_local_addr())
                {
                    GRTLOG("req to exit", 0, 0);
                    goto out;
                }
            }
        }
    }
out:
    ;
    // note: we don't close the "sync" socket here, so the
    // requester will be blocked until we can clean up, and the
    // caller can clean up too and exit the process

    // explicitly stop transfers, even though we are not
    // going to resume, just doing an exit may be too abrupt
    // sometimes.
    //dwyco_suspend();
    dwyco_bg_exit();
    //exit(0);
    return 0;
}

DWYCOEXPORT
void
dwyco_create_backup()
{
    create_msg_backup();
}

static
void
move_version(const DwString& ofn)
{
    DwString vfn = ofn;
    vfn.insert(vfn.length() - 4, ".old");
    move_replace(ofn, vfn);
}

DWYCOEXPORT
int
dwyco_copy_out_backup(const char *dir, int force)
{
    DwString fn = newfn("bu.sql");
    DwString filename = dir;
    filename += DIRSEPSTR;
    filename += "dwyco-backup-%1.sql";
    filename.arg((const char *)to_hex(My_UID));
    // only copy out the main backup if it is newer
    // than the existing one
    int do_copy = 0;
    if(!force)
    {
        struct stat s;
        if(stat(filename.c_str(), &s) == -1)
            do_copy = 1;
        else
        {
            struct stat s2;
            if(stat(fn.c_str(), &s2) == -1)
                do_copy = 1;
            else
            {
                if(s2.st_mtime > s.st_mtime)
                {
                    do_copy = 1;
                    move_version(filename);
                }
            }
        }
    }
    else
        do_copy = 1;
    if(do_copy)
    {
        if(!CopyFile(fn.c_str(), filename.c_str(), 0))
            return 0;
    }
    fn = newfn("dbu.sql");
    filename = dir;
    filename += DIRSEPSTR;
    filename += "dwyco-backup-diff-%1.sql";
    filename.arg((const char *)to_hex(My_UID));
    move_version(filename);
    if(!CopyFile(fn.c_str(), filename.c_str(), 0))
        return 0;
    return 1;
}

DWYCOEXPORT
void
dwyco_remove_backup()
{
    DwString fn = newfn("bu.sql");
    DeleteFile(fn.c_str());
    fn = newfn("dbu.sql");
    DeleteFile(fn.c_str());
}

DWYCOEXPORT
int
dwyco_restore_from_backup(const char *bu_fn, int msgs_only)
{
    if(!restore_msgs(bu_fn, msgs_only))
        return 0;
    DwString dfn(bu_fn);
    int pos;
    if((pos = dfn.find("dwyco-backup-")) == DwString::npos)
        return 0;
    dfn.insert(pos + 13, "diff-");
    if(!restore_msgs(dfn.c_str(), msgs_only))
        return 0;

    exit(0);
}

// these are some functions that are called from java (via swig interface)
// that are just helpers for importing data from an android environment
// back into the c++ environment
// note: normally we would have (str,len) pairs so we could process
// any sort of data, but that won't work with java strings, since they
// are assumed to be utf-8, and explicit lengths could be wrong for
// non-ascii strings. so, we rely on null-termination, which is dumb, but
// oh well.

static vc Aux_string;
static vc Contact_list(VC_VECTOR);

DWYCOEXPORT
void
dwyco_set_aux_string(const char *str)
{
    Aux_string = str;
    GRTLOG("set_aux_string", 0, 0);
    GRTLOGVC(Aux_string);
}

DWYCOEXPORT
void
dwyco_write_token(const char *token)
{
    vc tok(VC_BSTRING, token, strlen(token));
    save_info_e(tok, "token.dif");
}

DWYCOEXPORT
void
dwyco_clear_contact_list()
{
    Contact_list = vc(VC_VECTOR);
}

DWYCOEXPORT
int
dwyco_add_contact(const char *name, const char *phone, const char *email)
{
    vc v(VC_VECTOR);
    v[0] = name;
    v[1] = phone;
    v[2] = email;
    GRTLOG("add contact", 0, 0);
    GRTLOGVC(v);
    Contact_list.append(v);
    return 1;
}

// note: these are not called via java, rather, they are called from c++
// to get the values that were stored via the above functions.
DWYCOEXPORT
int
dwyco_get_contact_list(DWYCO_LIST *list_out)
{
    GRTLOG("get contact list", 0, 0);
    GRTLOGVC(Contact_list);
    *list_out = dwyco_list_from_vc(Contact_list);
    return 1;
}

// you must call "dwyco_free_array" on the returned pointer
// after copying it out
DWYCOEXPORT
int
dwyco_get_aux_string(const char **str_out, int *len_str_out)
{
    if(Aux_string.type() != VC_STRING ||
            str_out == 0 || len_str_out == 0)
        return 0;
    int len = Aux_string.len();
    char *str = new char[len + 1];
    memcpy(str, (const char *)Aux_string, len);
    str[len] = 0;
    *str_out = str;
    *len_str_out = len;
    return 1;
}


// these functions are called by the core when certain sounds
// should be emitted. this is just a convenience, the user of the
// dll can elect to do this all on their own if needed.
// note: removed filtering via TheAudioOutput (presumable we don't want
// sounds playing while we are outputting sound for some other channel)
// because with the chat room with sound, the audio output is *always* up,
// so we need to let the app do the filtering. for the audioinput it is
// similar, it is too restrictive to limit the events here, gotta let the app
// do it.
void
play_new_zap_alert()
{
    if(!dwyco_alert_callback)// || TheAudioOutput || TheAudioInput)
        return;
    (*dwyco_alert_callback)("alert_zap", 0, 1, 0);
}

// note: this is only called if the uid has the "alert" flag set
void
play_online_alert()
{
    if(!dwyco_alert_callback)// || TheAudioOutput || TheAudioInput)
        return;
    (*dwyco_alert_callback)("alert_online", 0, 1, 0);
}

void
play_call_alert()
{
    if(!dwyco_alert_callback)// || TheAudioOutput || TheAudioInput)
        return;
    (*dwyco_alert_callback)("alert_call", 0, 1, 0);
}

void
play_incoming_zap_alert()
{
    if(!dwyco_alert_callback)// || TheAudioOutput || TheAudioInput)
        return;
    (*dwyco_alert_callback)("alert_direct_zap", 0, 1, 0);
}

#define TEST_LAYER

#ifdef TEST_LAYER
//
// this is a thin layer that allows us to translate between
// the internals of the DLL to a very generic set of
// data structures that just about anyone can deal with.
//


#include <mmsystem.h>

#include <stdio.h>
#include "doinit.h"
#include "mmchan.h"
#include "aconn.h"
#include "gvchild.h"
#include "pval.h"
#include "aq.h"
#include "audi.h"
#include "audo.h"
#include "tpgmdec.h"
#include "chatdisp.h"
#include "aqkey.h"


static HWND
get_main_window(MMChannel *)
{
    return Main_window;
}

static HWND
get_client_window(MMChannel *)
{
    return Main_window;
}

static
void
entropy_display(int val)
{
}

static void
kill_za(MMChannel *mc, vc, void *p, ValidPtr)
{
    mc->call_appearance_death_callback = 0;
}

static int
popup_za(MMChannel *mc, vc name, vc filename, vc size)
{
#if 0
#ifdef _Windows
    if(!TheAudioOutput && !TheAudioInput)
    {
        PlaySound("zap.wav", 0, SND_ASYNC|SND_FILENAME|SND_NOWAIT|SND_NOSTOP);
    }
#endif
#endif
    mc->call_appearance_death_callback = kill_za;
    mc->cad_arg2 = 0;

    DwString msg = (const char *)name;
    msg += " wants to send you a direct Audio/Video Message (size ";
    char sz[255];
    sprintf(sz, "%d", (int)size);
    msg += sz;
    msg += ")";
    return 0;
}

static int
set_pb_caption(MMChannel *mc, vc pbid, vc caption, vc)
{
    return 1;
}

static int
set_pb_status(MMChannel *mc, vc pbid, vc str, vc barval)
{

    return 1;
}

static int
remove_cb(MMChannel *mc, vc pbid, vc, vc)
{
    return 1;
}



static void
update_connection_lists(MMChannel *, vc, void *, ValidPtr)
{
    if(dbg_msg_callback)
        (*dbg_msg_callback)(0, "--CONNLISTUPDATE--", 0, 0);
    scoped_ptr<ChanList> cl(MMChannel::get_serviced_channels_net());
    ChanListIter cli(cl.get());
    for(; !cli.eol(); cli.forward())
    {
        MMChannel *mc = cli.getp();
        char a[200];
        sprintf(a, "my id %d\n", mc->myid);
        if(dbg_msg_callback)
            (*dbg_msg_callback)(0, a, 0, 0);
    }
}

void set_caption_by_id(int gv_id, const char *txt);
void
caption_update(int gv_id, const char *str)
{
    set_caption_by_id(gv_id, str);
}

static
int
popup_message_box(MMChannel *, vc str, vc, vc)
{
    if(dbg_msg_callback)
        (*dbg_msg_callback)(0, str, 0, 0);
    TRACK_ADD_VC(str, 1);
    return 0;
}


class ChatDisplayText : public ChatDisplay
{
public:
    int output(vc log, int id);
    int output(const char *who, int len_who, const char *msg, int len_msg, vc from_uid, int = -1);
};

int
ChatDisplayText::output(vc log, int id)
{
    return 1;
}

int
ChatDisplayText::output(const char *who, int len_who, const char *msg, int len_msg, vc from_uid, int)
{
    return 1;
}

ChatDisplay *
gen_text_chatbox_display(MMChannel *)
{
    return new ChatDisplayText;
}
ChatDisplay *
gen_text_private_chat_display(MMChannel *)
{
    return new ChatDisplayText;
}


static void
setup_callbacks()
{
    MMChannel::get_mdi_client_window_callback = get_client_window;
    MMChannel::get_main_window_callback = get_main_window;
    MMChannel::gen_public_chat_display_callback = gen_bounce_chatbox_display;
    MMChannel::gen_private_chat_display_callback = gen_bounce_private_chat_display;
    MMChannel::popup_zap_accept_box_callback = zap_appeared_bounce;
    MMChannel::call_appeared_callback = call_appeared_bounce;
    MMChannel::call_accepted_callback = call_accepted_bounce;
    MMChannel::connection_list_changed_callback = update_connection_lists;
    MMChannel::popup_message_box_callback = popup_message_box;
    MMChannel::popup_update_box_callback = bounce_autoupdate_available;
    MMChannel::uc_message_callback = bounce_uc_callback;
    MMChannel::call_screening_callback = bounce_call_screening;
    TPGMMSWDecoderColor::display_info_in_titlebar_callback = caption_update;
    extern void (*Entropy_display_callback)(int);
    Entropy_display_callback = entropy_display;
}

#endif

// XXX bogus, most of these probably need to be callbacks of
// some sort.
int Mcheck;

void
set_status_text_by_id(int gv_id, const char *txt)
{
    if(dwyco_call_bandwidth_callback)
        (*dwyco_call_bandwidth_callback)(gv_id, txt, 0, 0);
}

void
set_caption_by_id(int gv_id, const char *txt)
{
    if(dwyco_call_bandwidth_callback)
        (*dwyco_call_bandwidth_callback)(gv_id, txt, 0, 0);
}

void
set_indicator_by_id(int gv_id, int ind, int val)
{
}


int
map_external_gv(ValidPtr , int )
{
    return ++UI_ids;
}

void
set_audio_status(int)
{
}

void
reset_audio_menus()
{
#if 0
    extern int All_mute;
    All_mute = 1;
#endif
    Squelched = 1;
}

void
set_squelch(int a)
{
// squelch off, means we heard something
    Squelched = !a;
}

#ifdef __WIN32__
void
pump_messages()
{
}
#endif

#ifdef LINUX
void
pump_messages()
{
}
void
vspin()
{
}
void
vunlock()
{
}
void
dwsleep(int, int *, int)
{
}
#endif

